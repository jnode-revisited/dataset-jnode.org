<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head><script type="text/javascript" src="/_static/js/bundle-playback.js?v=4R5OHjEN" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=txqj7nKC" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://www.jnode.org:80/book/export/html/1","20200119030613","https://web.archive.org/","web","/_static/",
	      "1579403173");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=S1zqJCYt" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

<title>JNode handbook</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><base href="https://web.archive.org/web/20200119030613/http://www.jnode.org/"/>
<style type="text/css">
@import url(/web/20200119030613cs_/http://www.jnode.org/misc/print.css);
</style>
</head>
<body>
<div id="node-1" class="section-1">
<h1 class="book-heading">JNode handbook</h1>
<p>This book contains all JNode documentation.</p>
<div id="node-5" class="section-2">
<h1 class="book-heading">Goals</h1>
<p>JNode is a <i>Java New Operating System Design Effort</i>.<br/>
<br/>
The goal is to create an easy to use and install Java operating system for personal use.  Any java application should run on it, fast &amp; secure!</p>
</div>
<div id="node-42" class="section-2">
<h1 class="book-heading">User guide</h1>
<p>General user information.</p>
<div id="node-174" class="section-3">
<h1 class="book-heading">History</h1>
<p>Already very early in the Java history, around JDK 1.0.2, Ewout Prangsma (the founder of JNode) dreamed of building a Java Virtual Machine in Java.<br/>
It should be a system that was not only a VM, but a complete runtime environment that does not need any other form of operating system. So is had to be a light weight and most important flexibel system.<br/>
<br><br/>
Ewout made various attempts in achieving these goals, starting with JBS; the Java Bootable System. It became a somewhat functional system, but had far too much native code (C and assembler) in it. So he started working on a new JBS system, called JBS2 and finally JNode. It had with a simple target, using NO C code and only a little bit of assembly code.</p>
<p>In may on 2003 Ewout came public with JNode and development proceeded ever faster from that point on.<br/>
Several versions have been released and there are now concrete plans for the first major version.</p>
</div>
<div id="node-2365" class="section-3">
<h1 class="book-heading">Application testing list</h1>
<p>This page lists java applications that we use to test JNode.</p>
<ul>
<li>(Should) work</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2366">JUnit</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2368">nanohttpd</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2366">javac</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2367">ecj</a></li>
</ul>
<li>Partially usable</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2366">Jetty6</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2369">Beanshell</a></i>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2370">Rhino</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2371">hsqldb</a></li>
</ul>
<li>Starts but doesn't really work yet</li>
<ul>
<li><i>empty</i></li>
</ul>
<li>Needs work</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2373">Ant</a></li>
</ul>
<li>Needs (lots of) work</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2366">JEdit</a></li>
</ul>
<li>Not tested yet</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2372">tomcat</a></li>
</ul>
</ul>
<div id="node-2373" class="section-4">
<h1 class="book-heading">Applications starting with A</h1>
<p>Here is details about applications whose name starts with A</p>
<ul>
<li><u>Ant</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/https://ant.apache.org/" title="http://ant.apache.org/">http://ant.apache.org/</a><br/>
comments :
</ul>
</div>
<div id="node-2369" class="section-4">
<h1 class="book-heading">Applications starting with B</h1>
<p>Here is details about applications whose name starts with B</p>
<ul>
<li><u>Beanshell</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/http://www.beanshell.org/" title="http://www.beanshell.org/">http://www.beanshell.org/</a><br/>
comments :
</ul>
</div>
<div id="node-2367" class="section-4">
<h1 class="book-heading">Applications starting with E</h1>
<p>Here is details about applications whose name starts with E</p>
<ul>
<li><u>ecj (eclipse compiler for java)</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/https://www.eclipse.org/" title="http://www.eclipse.org">http://www.eclipse.org</a> ???<br/>
comments :
</ul>
</div>
<div id="node-2371" class="section-4">
<h1 class="book-heading">Applications starting with H</h1>
<p>Here is details about applications whose name starts with H</p>
<ul>
<li><u>hsqldb</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/http://hsqldb.org/" title="http://hsqldb.org/">http://hsqldb.org/</a><br/>
comments :
</ul>
</div>
<div id="node-2366" class="section-4">
<h1 class="book-heading">Applications starting with J</h1>
<p>Here is details about applications whose name starts with J</p>
<ul>
<li><u>JUnit</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/http://junit.org/" title="http://junit.org/">http://junit.org/</a><br/>
comments : only tested in console mode.</p>
<li><u>javac</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/https://openjdk.java.net/" title="http://openjdk.java.net/">http://openjdk.java.net/</a><br/>
comments : the sun compiler for java.  It works fine, but you can run into GC bugs when you compile your first program.  The following "warm-up" sequence avoids this:</p>
<ol>
<li>Run "gc".
<li>Run "javac" with no arguments.
<li>Run "gc" again.
<li>Use "javac" to compile a (small) program.
</ol>
<li><u>Jetty6</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/http://www.mortbay.org/" title="http://www.mortbay.org/">http://www.mortbay.org/</a><br/>
comments : it works partially</p>
<li><u>JEdit</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/http://www.jedit.org/" title="http://www.jedit.org/">http://www.jedit.org/</a><br/>
comments : by using jedit.jar alone, I only see the splash screen. If I try the installer, it fails at 0% of progress with an "IOException" dialog box but no stacktrace.</p>
<li><u>JChatIRC</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/http://jchatirc.sourceforge.net/" title="http://jchatirc.sourceforge.net/">http://jchatirc.sourceforge.net/</a><br/>
comments :
</ul>
</div>
<div id="node-2368" class="section-4">
<h1 class="book-heading">Applications starting with N</h1>
<p>Here is details about applications whose name starts with N</p>
<ul>
<li><u>NanoHttpd</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/http://elonen.iki.fi/code/nanohttpd/" title="http://elonen.iki.fi/code/nanohttpd/">http://elonen.iki.fi/code/nanohttpd/</a><br/>
comments :
</ul>
</div>
<div id="node-2370" class="section-4">
<h1 class="book-heading">Applications starting with R</h1>
<p>Here is details about applications whose name starts with R</p>
<ul>
<li><u>Rhino</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/https://www.mozilla.org/rhino/" title="http://www.mozilla.org/rhino/">http://www.mozilla.org/rhino/</a><br/>
comments :
</ul>
</div>
<div id="node-2372" class="section-4">
<h1 class="book-heading">Applications starting with T</h1>
<p>Here is details about applications whose name starts with T</p>
<ul>
<li><u>tomcat</u></li>
<p>website : <a href="https://web.archive.org/web/20200119030613/https://tomcat.apache.org/" title="http://tomcat.apache.org/">http://tomcat.apache.org/</a><br/>
comments :
</ul>
</div>
</div>
<div id="node-25" class="section-3">
<h1 class="book-heading">Getting Started</h1>
<p>To start using JNode you have two options:</p>
<ol>
<li><a href="/web/20200119030613/http://www.jnode.org/node/25#bin">Download the latest released CD-ROM image</a></li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/25#src">Download the latest sources and build them</a></li>
</ol>
<h2><a name="bin"></a>Getting the latest released CD-ROM image</h2>
<ul>
<li>Download the bootable CDROM image from <a href="/web/20200119030613/http://www.jnode.org/downloads">here</a>.
<li>Unzip it</li>
<li>Burn it to CD-ROM</li>
<li>Boot a test PC from it or start in in VMWare</li>
</ul>
<h2><a name="src"></a>Getting the latest sources and building them</h2>
<ul>
<li>Checkout the jnode module from GitHub. See the <a href="https://web.archive.org/web/20200119030613/https://github.com/jnode/jnode">GitHub jnode repository page</a> for details.</li>
<li>Build JNode using the build.bat (on windows) or build.sh (on unix) script.<br/>
Without parameters, these scripts will give all build options. You probably want to use the cd-x86 option that builds the CD-ROM image.</li>
<li>Boot a test PC from it or start in in VMWare</li>
</ul>
<h2><a name="src"></a>Getting nightly builds</h2>
<ul>
<li>Download the <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/releases/nightly-builds/">nightly-builds</a></li>
<li>You can also get the sources and a ready-to-use vmx file for VMWare</li>
</ul>
<h2>Running JNode</h2>
<p>Once JNode has booted, you will see a JNode &gt; command prompt. See the shell reference for available commands. </p>
<div id="node-798" class="section-4">
<h1 class="book-heading">The 20 minute guided tour.</h1>
<p>This is a quick guide to get started with JNode. It will help you to  download a JNode boot image, and explain how to use it.  It also will give you get you started with exploring JNode's capabilities and give you some tips on how to use the JNode user interfaces.</p>
<p>To start with, you need to download a JNode boot image.  Go to <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/taxonomy/term/2">this page</a> and click on the link for the latest version. This will take you to a page with the downloadable files for the version.  The page also has a link to a page listing the JNode hardware requirements.</p>
<p>At this point, you have two choices. You can create a bootable CD ROM and then run JNode on real hardware by booting your PC from the CD ROM drive.  Alternatively, you can run JNode on virtual PC using VMWare.</p>
<p>To run JNode on real hardware:</p>
<ol>
<li>Download the "gzip compressed ISO image" from the JNode download page.
<li>Uncompress the ISO image using "gunzip".
<li>Use your favorite CD burning software to burn the ISO image onto a blank CD ROM.
<li>Shutdown your PC.
<li>Put the JNode boot CD into the CD drive
<li>Boot from the CD, following the PC manufacturer's instructions.
</ol>
<p>To run JNode from VMWare:</p>
<ol>
<li>Download a <i>free</i> copy of <a href="https://web.archive.org/web/20200119030613/https://www.vmware.com/download/player/">VMware-Player</a>.  (You can also use the <i>free</i> <a href="https://web.archive.org/web/20200119030613/https://www.vmware.com/download/server/">VMware-Server</a> which allows to modify the VM parameters and so on, or you buy one of the more advanced VMWare products.)
<li>Install VMWare following the instructions provided.
<li>Download the "gzip compressed ISO image" <i>and</i> the "vmx" file from the JNode download page.
<li>Uncompress the ISO image using "gunzip", and make sure that the image is in the same directory as the "vmx" file.
<li>Launch VMWare, browse to find the JNode "vmx" file, and launch it as described in the VMWare user guide.
</ol>
<p>When you start up JNode, the first thing you will see after the BIOS messages is the Grub bootloader menu allowing you to select between various JNode configurations.  If you have at 500MB or more of RAM (or 500MB assigned to the VM if you are using VMware), we recommend the "JNode (all plugins)" configuration.  This allows you to run the GUI.  Otherwise, we recommend the "JNode (default)" or "JNode (minimal shell)" configurations.  (For more information on the available JNode configurations, ...).</p>
<p>Assuming that you choose one of the recommended configurations, JNode will go through the bootstrap sequence, and start up a text console running a command shell, allowing you to issue commands.  The initial command will look like this:</p>
<p><i>JNode /&gt;</i></p>
<p>Try a couple of commands to get you started:</p>
<p><i>JNode /&gt;</i> <b>dir</b></p>
<p>will list the JNode root directory,</p>
<p><i>JNode /&gt;</i> <b>alias</b></p>
<p>will list the commands available to you, and </p>
<p><i>JNode /&gt;</i> <b>help &lt;command&gt;</b></p>
<p>will show you a command's online help and usage informatiom.</p>
<p>There are a few more useful things to see:</p>
<ul>
<li>Entering <b>ALT+F7</b> (press the ALT and F7 keys at the same time) will switch to the logger console.  Entering <b>ALT+F1</b> switches you back to the shell console.
<li>Entering <b>SHIFT+UP-ARROW</b> and <b>SHIFT+DOWN-ARROW</b> scroll the current console backwards and forwards.
<li>Entering <b>TAB</b> performs command name and argument completion.
<li>Entering <b>UP-ARROW</b> and <b>DOWN-ARROW</b> allows you to choose commands from the command history.
</ul>
<p>The JNode completion mechanism is more sophisticated than the analogs in typical Linux and Windows shells.  In addition to performing command name and file name completion, it can do completion of command options and context sensitive argument completion.  For example, if you want to set up your network card using the "dhcp" command, you don't need to go hunting for the name of the JNode network device.  Instead, enter the following:</p>
<p><i>JNode /&gt;</i> <b>dhcp eth&lt;TAB&gt;</b></p>
<p>The completer will show a list of known ethernet devices allowing you to select the appropriate one.  In this case, there is typically one name only, so this will be added to the command string.</p>
<p>For more information on using the shell, please refer to the <a href="/web/20200119030613/http://www.jnode.org/node/88">JNode Shell</a> page,</p>
<p>I bet you are bored with text consoles by now, and you are eager to see the JNode GUI.  You can start it as follows:</p>
<p><i>JNode /&gt;</i> <b>gc</b><br><i>JNode /&gt;</i> <b>startawt</b></p>
<p>The GUI is intended to be intuitive, so give it a go.  It currently includes a "Text Console" app for entering commands, and a couple of games.  If you have problems with the GUI, <b>ALT+F12</b> should kill the GUI and drop you back to the text console.</p>
<p>By the way, you can switch the font rendering method used by the GUI before you run "startawt", as follows: </p>
<p><i>JNode /&gt;</i> <b>set jnode.font.renderer ttf|bdf</b></p>
<p>If you have questions or you just want to talk to us, please consider joining our IRC channel (<a href="https://web.archive.org/web/20200119030613/irc://irc.oftc.net/JNode.org">#<span class="__cf_email__" data-cfemail="88c2c6e7eceda6e7faefc8e1faeba6e7eefceba6e6edfc">[email&#160;protected]</span></a>). We're all very friendly and try to help everyone *g*</p>
<p>If you find a bug, we would really appreciate you posting a bug report via our <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/bugs">bug tracker</a>.  You can also enter support and feature requests there.</p>
<p>Feel free to continue trying out JNode.  If you have the time and the skills, please consider joining us to make it better.</p>
</div>
<div id="node-68" class="section-4">
<h1 class="book-heading">Booting from the network</h1>
<p>2 options are available here</p>
<div id="node-103" class="section-5">
<h1 class="book-heading">Network boot disk</h1>
<p>If you do not have a bootable network card, you can create a network boot disk instead. See the GRUB manual for details, or use <a href="https://web.archive.org/web/20200119030613/http://rom-o-matic.net/">ROM-o-matic</a> or the <a href="https://web.archive.org/web/20200119030613/http://i30www.ira.uka.de/~ud3/mkgrubdisk/">GRUB network boot-disk creator</a>.</p>
</div>
<div id="node-69" class="section-5">
<h1 class="book-heading">NIC-based network boot</h1>
<p>To boot JNode from the network, you will need a bootable network card, a DHCP/BOOTP and TFTP server setup.</p>
<ul>
<li>Set the TFTP base directory to &lt;JNode dir&gt;/all/build/x86/netboot
<li>Set the boot file to nbgrub-&lt;card&gt; where &lt;card&gt; is the card you are using
<li>Set DHCP option 150 to (nd)/menu-nb.lst
</ul>
</div>
</div>
<div id="node-13790" class="section-4">
<h1 class="book-heading">Booting from USB memory stick</h1>
<p>This guide shows you how to boot JNode from an USB memory stick.<br/>
You'll need a Windows machine to build on and a clean USB memory stick (it may be wiped!).</p>
<p>Step 1: Build a JNode iso image (e.g. build cd-x86-lite)<br/>
Step 2: Download <a href="https://web.archive.org/web/20200119030613/https://sites.google.com/site/shamurxboot/">XBoot</a>.<br/>
Step 3: Run XBoot with Administrator rights<br/>
Step 4: Open file: select the ISO created in step 1. Choose "Add grub4dos using iso emulation".<br/>
Step 5: Click "Create USB"</p>
<p>XBoot will now install a bootloader (choose the default) and prepare the USB memory stick.<br/>
After then, eject the memory stick and give it a try.</p>
<p>When it boots, you'll first have to choose JNode from the menu. Then the familiar JNode Grub boot menu appears.</p>
</div>
<div id="node-614" class="section-4">
<h1 class="book-heading">Eclipse Howto</h1>
<p>This chapter explains how to use the <a href="https://web.archive.org/web/20200119030613/https://www.eclipse.org/">Eclipse</a> 3.2 IDE with JNode.</p>
<h2>Starting</h2>
<p>JNode contains several Eclipse projects within a single SVN module. To checkout and import these projects into Eclipse, execute the following steps:</p>
<ol>
<li>Checkout the jnode module from SVN using any SVN tool you like.<br/>
Look at the <a href="https://web.archive.org/web/20200119030613/https://sourceforge.net/svn/?group_id=80882">sourceforge SVN</a> page for more details.</li>
<li>Start Eclipse</li>
<li>Select File - Import. You wil get this screen.
<p><img src="/web/20200119030613im_/http://www.jnode.org/toolguides/eclipse-import.png" title="" alt=""/></p>
</li>
<li>Select "Existing project into workspace". </li>
<li>Enter the root directory of the imported jnode CVS module in this screen.
<p><img src="/web/20200119030613im_/http://www.jnode.org/toolguides/eclipse-import-projects.png" title="" alt=""/></p>
<p>The listed projects will appear when the root directory has been selected.
</li>
<li>Select Finish</li>
<li>You will end up with all projects into your Eclipse workspace like this:
<p><img src="/web/20200119030613im_/http://www.jnode.org/toolguides/eclipse-import-result.png" title="" alt=""/></p>
</li>
</ol>
<h2>Building</h2>
<p>You can build JNode within Eclipse by using the build.xml Ant file found in the JNode-All project. However, due to the memory requirements of the build process, it is better to run the build from the commandline using build.bat (on windows) or build.sh (on unix).</p>
</div>
<div id="node-27" class="section-4">
<h1 class="book-heading">Running in Bochs</h1>
<p>Running JNode in Bochs does not seem to work out of the box yet. It fails on setting CPU register CR4 into 4Mb paging mode.<br/>
A compile setting that enables 4Mb pages is known to solve this problem. To enable this settings, running configure with the --enable-4meg-pages argument or add #define BX_SUPPORT_4MEG_PAGES 1 to config.h.</p>
</div>
<div id="node-2750" class="section-4">
<h1 class="book-heading">Running in KVM</h1>
<h3>Setup</h3>
<p>If you have a CPU with hardware virtualization support you can run JNode in kvm wich is much faster than vmware-[player|server] (at least for me). You need a CPU that either supports Intel's IVT (aka Vanderpool) or AMD's AMD-V (aka Pacifica).</p>
<p>With</p>
<pre>egrep '^flags.*(vmx|svm)' /proc/cpuinfo"</pre><p>you can easily check if your CPU supports VT or not. If you receive output your CPU is supported, else it is not. If your CPU is supported also check that VT is enabled in your system bios.</p>
<p>Load the kvm modules matching your CPU, either "modprobe kvm_intel" or "modprobe kvm_amd", install kvm user tools and setup permissions so users may run kvm (Have a look at a HOWTO for your distro for details: <a href="https://web.archive.org/web/20200119030613/https://help.ubuntu.com/community/KVM">Ubuntu</a>, <a href="https://web.archive.org/web/20200119030613/http://gentoo-wiki.com/HOWTO_KVM">Gentoo</a>).</p>
<p>Once you have setup everything you can start kvm from the commandline (I think there are GUI frontends too, but I'm using the command line). You should be carefull though, acpi in JNode seems to kill kvm, so allways disable acpi. I also had to deactivate the kvm-irqchip as it trashed JNode. The command that works for me is:</p>
<pre>kvm -m 768 -cdrom jnode-x86-lite.iso -no-acpi -no-kvm-irqchip -serial stdout -net none -std-vga
</pre><p>
The "-serial" switch is optional but I need it for kdb (kernel debugger). If you want to use the Vesa mode of JNode you should also use "-std-vga", overwise you will not have a vesa mode. Set the memory whatever you like (768MB is my default).</p>
<h3>Things that still need to be tested:</h3>
<li> "-drive/-hda/.." allow to supply harddisks, test if this works too
<li> "-smp n" allows to give n cores to kvm (difficult as JNode is not SMP safe atm)
<li> "-audio/soundhw" allows sound emulation
<li> test "-usb/.."
<li> Test network. Atm I'm missing some kernel modules so I deactivated network for the moment.
<li> Test gdb with kvm. This should be more fun than using qemu <img src="/web/20200119030613im_/http://www.jnode.org/modules/smileys/packs/example/smile.png" title="Smiling" alt="Smiling"/>
<li> Test other CPUs, especially the qemu64 (i.e. 64bit CPU) support once JNode's 64bit version works again<br/>
</div>
<div id="node-753" class="section-4">
<h1 class="book-heading">Running in parallels</h1>
<p>I found an only way to run JNode with <a href="https://web.archive.org/web/20200119030613/https://www.parallels.com/en/download/">parallels</a>.</p>
<p>In <i>Options</i>-&gt;<i>Emulation flags</i>, there is a parameter called <i>Acceleration level</i> that takes 3 values :<br/>
- <i>disabled</i> : JNode will work but that's very slow<br/>
- <i>normal</i> : JNode won't boot (freeze at "Detected 1 processor")<br/>
- <i>high</i> : JNode won't boot (freeze at "Detected 1 processor")</p>
</div>
<div id="node-2753" class="section-4">
<h1 class="book-heading">Running in VBox</h1>
<p>You can now run JNode on virtual box too. ACPI is not working but you'll get a prompt and can use JNode.</p>
<p>TODO: Test network, usb,...</p>
</div>
<div id="node-684" class="section-4">
<h1 class="book-heading">Running in Virtual PC</h1>
<p>This page will discripe how to run JNode in Virtual PC</p>
<p>At the current state JNode doesn't run in Virtual PC.</p>
</div>
<div id="node-28" class="section-4">
<h1 class="book-heading">Running in VMWare</h1>
<p><b><u>Basic Procedure</u></b></p>
<p>The JNode build process creates a VMWare compatible ".vmx" file that allows you to run JNode using recent releases of VMWare Player.</p>
<p>Assuming that you build JNode using the "cd-x86-lite" target, the build will create an ISO format CDROM image called "jnode-x86-lite.iso" in the "all/build/cdroms/" directory.  In the same directory, the build also generates a file called "jnode-x86-lite.iso.vmx" for use with VMWare.  To boot JNode from this ".iso" file, simply run the player as follows:</p>
<p>&nbsp;&nbsp;$ <b>vmplayer all/build/cdroms/jnode-x86-lite.iso.vmx</b></p>
<p><b><u>Altering the VMWare virtual machine configuration</u></b></p>
<p>By default, the generated ".vmx" file configures a virtual machine with a virtual CDROM for the ISO, a bridged virtual ethernet and a virtual serial port that is connected to a "debugger.txt" file.  If you want to configure the VMWare virtual machine differently, the simplest option is to buy VMWare Workstation and use its graphical interfaces to configure and run JNode.  (Copy the generated ".vmx" file to a different location, and use that as the starting point.)</p>
<p>If you don't want to pay for VMWare Workstation, you can achieve the same effect by changing the ".vmx" file by hand.  However, changes you make that way will be clobbered next time you run the "build" script.  The solution is to do the following:</p>
<p><i>This procedure assumes some changes in a patch that is waiting to be committed.</i></p>
<ol>
<li>Create a file containing the VMX properties that you want to add or replace.  Put this file somewhere that won't be clobbered by "build clean".
<li>Copy the "jnode.properties.dist" file to "jnode.properties".
<li>Open the "jnode.properies" file in a text editor.
<li>Find the line that starts "#vmware.vmx.overrides=".
<li>Remove the "#" and replace the characters after the "=" with the override file's pathname.
<li>Save the file.
<li>Run "build cd-x86-lite" (or whatever you normally use to build a CDROM image).
</ol>
<p>This should create the "jnode-x86-lite.iso.vmx" file with the VMX settings from your file as overrides to the default settings.</p>
<p>Unfortunately, VMWare have not released any documentation for the myriad VMX settings.  The best 3rd-party documentation that I can find is the <a href="https://web.archive.org/web/20200119030613/http://sanbarrow.com/vmx.html">sanbarrow.com</a> website.  There are also various "builder" applications around, but they don't look all that good.</p>
<p><b><u>VMWare disks and Boot device order</u></b><br/>
If you add a VMWare virtual (or real) disk drive, the VMWare virtual machine's BIOS will try to boot from that drive.  Unless you have set up the drive to be bootable, this won't work.  The easy way to fix this is to change VMWare's BIOS settings to alter the boot device order.</p>
<ol>
<li>Run vmplayer as above.
<li>Quickly click the VMWare window to give it keyboard focus and hit [F2].  (You have small window to do this ... just a second or two!).
<li>In the BIOS settings screen, select the "Booting" panel and move the "cdrom" to the top; i.e. the first device to be tried.
<li>Save the BIOS settings to the virtual NVRAM and exit the BIOS settings editor to continue the boot.
</ol>
<p>By default the NVRAM settings are stored in the "JNode.nvram" file in "all/build/cdroms" directory, and will be clobbered when you run "build clean".  If this is a problem, create a VMX override (see above) with a "nvram" entry that uses a different location for the file.</p>
</div>
<div id="node-26" class="section-4">
<h1 class="book-heading">Running on a PC</h1>
<p>To run JNode on a PC using the bootable CDROM, your PC must comply with the following specifications: </p>
<ul>
<li>Pentium or above CPU<br/>
128Mb RAM or more (i'm not sure what the minimum is) </li>
<li>Bootable CDROM drive that supports El-Torito harddisk emulation </li>
<li>VGA compatible video card </li>
<li>Keyboard </li>
</ul>
</div>
<div id="node-1499" class="section-4">
<h1 class="book-heading">The GRUB Boot Menu</h1>
<p>The first JNode related information you will see after booting from a JNode CDROM image is the GRUB bootloader page.  The GNU GRUB bootloader is responsible for selecting a JNode configuration from a menu, loading the corresponding kernel image and parameters into RAM and causing the JNode kernel to start executing.</p>
<p>When GRUB starts, it displays the bootloader page and pauses for a few seconds.  If you do nothing, GRUB will automatically load and start the default configuration.  Pressing any key at this point will interrupt the automatic boot sequence and allow you to select a specific configuration.  You can use the <b>UP-ARROW</b> and <b>DOWN-ARROW</b> to choose a JNode configuration, then hit <b>ENTER</b> to boot it up.</p>
<p>There are a number of JNode configurations in the menu:</p>
<ul>
<li>The configurations that include "MP" in the description enable JNode's multiprocessor support on a capable machine.  Since JNode's multiprocessor support is not fully functional, you should probably avoid these configurations for now.
<li>The configurations the include "GUI" in the description will start up the JNode GUI.  Configurations without this tag will start up the JNode command shell on a text console.
<li>The other difference between the configurations is in the sets of plugins that they load.  In general, loading more plugins will cause JNode to use more RAM.
</ul>
<p>It is currently not a good idea to boot JNode straight to the GUI.  If want to run the GUI, it is best to boot the one of the non-GUI configurations; typically "JNode (all plugins)".  Then from the text console, run the following commands:</p>
<p><i>JNode /&gt;</i> <b>gc</b></p>
<p><i>JNode /&gt;</i> <b>startawt</b></p>
</div>
</div>
<div id="node-91" class="section-3">
<h1 class="book-heading">Hardware Compatibility List</h1>
<p>Use <a href="/web/20200119030613/http://www.jnode.org/devices">this list</a> to find out if JNode already supports your hardware.</p>
<p>If you find out that your device is not on the list, or the information provided here is incorrect, please <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#701500023005031502035e031f05021315161f0217155e1e1504">submit</a><br/>
your changes.</p>
</div>
<div id="node-573" class="section-3">
<h1 class="book-heading">Hardware requirements</h1>
<p>To be able to run JNode, you're hardware should be at least equal to or better then:</p>
<ul>
<li>Pentium class CPU with Page Size Extensions (PSE) feature</li>
<li>512MB RAM</li>
</ul>
<p>In order to run JNode the following hardware is recommended:</p>
<ul>
<li>Pentium i3 or better</li>
<li>1GB RAM</li>
<li>CDROM drive</li>
<li>Modern VGA card (see <a href="/web/20200119030613/http://www.jnode.org/devices">devices</a>)</li>
</ul>
</div>
<div id="node-2053" class="section-3">
<h1 class="book-heading">JNode Commands</h1>
<p>This page contains the available documentation for most of the useful JNode commands.  For commands not listed below, try running <b>help &lt;alias&gt;</b> at the JNode command prompt to get the command's syntax description and built-in help.  Running <b>alias</b> will list all available command aliases.</p>
<p>If you come across a command that is not documented, please raise an issue.  (Better still, if you have website content authoring access, please add a page yourself using one of the existing command pages as a template.)</p>
<div id="node-2054" class="section-4">
<h1 class="book-heading">acpi</h1>
<p><b>acpi</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td colspan="2"><i>acpi</i></td>
<td>displays ACPI details</td>
</tr>
<tr>
<td><i>acpi</i></td>
<td><i>--dump | -d</i></td>
<td>lists all devices that can be discovered and controlled through ACPI</td>
</tr>
<tr>
<td><i>acpi</i></td>
<td><i>--battery | -b</i></td>
<td>displays information about installed batteries</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>acpi</i> command currently just displays some information that can be gleaned from the host's "Advanced Configuration &amp; Power Interface" (ACPI).  In the future we would like to interact with ACPI to do useful things.  However, this appears to be a complex topic, rife with compatibility issues, so don't expect anything soon.</p>
<p>
The ACPI specifications can be found on the net, also have a look at <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Advanced_Configuration_and_Power_Interface">wikipedia</a>.
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
This command does nothing useful at the moment; it is a work in progress.
</td>
</tr>
</table>
</div>
<div id="node-2055" class="section-4">
<h1 class="book-heading">alias</h1>
<p><b>alias</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>alias</i></td>
<td></td>
<td>prints all available aliases and corresponding classnames</td>
</tr>
<tr>
<td><i>alias</i></td>
<td><i>&lt;alias&gt; &lt;classname&gt;</i></td>
<td>creates an alias for a given classname</td>
</tr>
<tr>
<td><i>alias</i></td>
<td><i>-r &lt;alias&gt;</i></td>
<td>removes an existing alias</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>alias</i> command creates a binding between a name (the alias) and the fully qualified Java name of the class that implements the command.  When an alias is created, no attempt is made to check that the supplied Java class name denotes a suitable Java class.  If the alias name is already in use, <i>alias</i> will update the binding.</p>
<p>If the classname argument is actually an existing alias name, the <i>alias</i> command will create a new alias that is bound to the same Java classname as the existing alias.  </p>
<p>A command class (e.g. one whose name is given by an aliased classname) needs to implement an entry point method with one of the following signatures:</p>
<dl>
<dt><i>public void execute(CommandLine cmd, InputStream in, PrintStream out, PrintStream err);</i></dt>
<dd>This is the JNode preferred entry point.  It allows stream redirection in any invoker / interpreter that supports this. In addition, the CommandLine object provides the alias and arguments in both String and Token form.</dd>
<dt><i>public static void main(String[] args);</i></dt>
<dd>This is the classic Java entry point signature.  It does not allow the command class to find out the alias name that was used to invoke it.  In JNode, this makes stream redirection problematic unless the command is executed in an isolate or a proclet.</dd>
</dl>
<p>If a command class has both <i>execute</i> and <i>main</i> methods, most invokers will use the former in preference to the latter.  Ideally, a command class should extend <i>org.jnode.shell.AbstractCommand</i>.
</td>
</tr>
</table>
</div>
<div id="node-2092" class="section-4">
<h1 class="book-heading">arp</h1>
<p><b>arp</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>arp</i></td>
<td></td>
<td>prints the ARP cache</td>
</tr>
<tr>
<td><i>arp</i></td>
<td><i>-d</i></td>
<td>clears the ARP cache</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
ARP (the Address Resolution Protocol) is a low level protocol for discovering the MAC address of a network interface on the local network.  MAC address are the low-level network addresses for routing IP (and other) network packets on a physical network.  </p>
<p>
When a host needs to comminutate with an unknown local IP address, it broadcasts an ARP request on the local network, asking for the MAC address for the IP address.  The node with the IP address broadcasts a response giving the MAC address for the network interface corresponding to the IP address.</p>
<p>
The ARP cache stores IP to MAC address mappings that have previously been discovered.  This allows the network stack to send IP packets without repeatedly broadcasting for MAC addresses.</p>
<p>
The <i>arp</i> command allows you to examine the contents of the ARP cache, and if necessary clear it to get rid of stale entries.
</td>
</tr>
</table>
</div>
<div id="node-2988" class="section-4">
<h1 class="book-heading">basename</h1>
<p><b>basename</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>basename</b> String [Suffix]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    Strip directory and suffix from filenames
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode basename is posix compatible.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.opengroup.org/onlinepubs/009695399/utilities/basename.html">POSIX basename</a>
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2093" class="section-4">
<h1 class="book-heading">beep</h1>
<p><b>beep</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>beep</i></td>
<td colspan="2">makes a beep noise</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
Useful for alerting the user, or annoying other people in the room.
</td>
</tr>
</table>
</div>
<div id="node-3060" class="section-4">
<h1 class="book-heading">bindkeys</h1>
<p><b>bindkeys</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>bindkeys</i></td>
<td></td>
<td>print the current key bindings</td>
</tr>
<tr>
<td><i>bindkeys</i></td>
<td><i>--reset</i></td>
<td>reset the key bindings to the JNode defaults</td>
</tr>
<tr>
<td><i>bindkeys</i></td>
<td><i>--add &lt;action&gt; (&lt;vkSpec&gt; | &lt;character&gt;)</i></td>
<td>add a key binding</td>
</tr>
<tr>
<td><i>bindkeys</i></td>
<td><i>--remove &lt;action&gt; [&lt;vkSpec&gt; | &lt;character&gt;]</i></td>
<td>remove a key binding</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>bindkeys</i> command prints or changes the JNode console's key bindings; i.e. the mapping from key events to input editing actions.  The <i>bindkeys</i> form of the command prints the current bindings to standard output, and the <i>bindkeys --reset</i> form resets the bindings to the hard-wired JNode default settings.</p>
<p>The <i>bindkeys --add ...</i> form of the command adds a new binding.  The <i>&lt;action&gt;</i> argument specifies an input editing action; e.g. 'KR_ENTER' causes the input editor to append a newline to the input buffer and 'commit' the input line for reading by the shell or application.  The <i>&lt;vkSpec&gt;</i> or <i>&lt;character&gt;</i> argument specifies an input event that is mapped to the <i>&lt;action&gt;</i>.</p>
<p>The recognized <i>&lt;action&gt;</i> values are listed in the output the no-argument form of the <i>bindkeys</i> command.</p>
<p>The <i>&lt;vkSpec&gt;</i> values are formed from the "VK_xxx" constants defined by the "java.awt.event.KeyEvent" class and "modifier" names; e.g. "Shift+VK_ENTER".</p>
<p>The <i>&lt;character&gt;</i> values are either single ASCII printable characters or standard ASCII control character names; e.g. "NUL", "CR" and so on.</p>
<p>The <i>bindkeys --add ...</i> form of the command removes a single binding or (if you leave out the optional <i>&lt;vkSpec&gt;</i> or <i>&lt;character&gt;</i> argument) all bindings for the supplied <i>&lt;action&gt;</i>.</p>
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
Changing the key bindings in one JNode console affects all consoles.</p>
<p>The bindkeys command provides no online documentation for what the action codes mean / do.
</td>
</tr>
</table>
</div>
<div id="node-2096" class="section-4">
<h1 class="book-heading">bootp</h1>
<p><b>bootp</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>bootp</i></td>
<td><i>&lt;device&gt;</i></td>
<td>configures a network interface using BOOTP</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>bootp</i> command configures the network interface given by <i>&lt;device&gt;</i> using settings obtained using BOOTP.  BOOTP is a network protocol that allows a host to obtain its IP address and netmask, and the IP of the local gateway from a service on the local network.
</td>
</tr>
</table>
</div>
<div id="node-2591" class="section-4">
<h1 class="book-heading">bsh</h1>
<p><b>bsh</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>bsh</i></td>
<td><i>[ --interactive | -i ] [ --file | -f &lt;file&gt; ] [ --code | -c &lt;code&gt; ]</td>
<td>Run the BeanShell interpreter</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>bsh</i> command runs the BeanShell interpreter.  The options are as follows:</p>
<ul>
<li><i>--interactive | -i</i> start an interactive BeanShell.
<li><i>--file | -f &lt;file&gt;</i> take BeanShell input from <i>&lt;file&gt;</i>.   If <i>--interactive</i> is also given, the BeanShell will go into interactive mode after processing the file.
<li><i>--code | -c &lt;code&gt; </i> execute <i>&lt;code&gt;</i> as a BeanShell code.   If <i>--interactive</i> is also given, the BeanShell will go into interactive mode after processing the code.
</ul>
<p>If no arguments are given, <i>--interactive</i> is assumed.
</td>
</tr>
</table>
</div>
<div id="node-2986" class="section-4">
<h1 class="book-heading">bzip2</h1>
<p><b>bzip2</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>bzip2</b> [Options] [File ...]<br/>
    <b>bunzip2</b> [Options] [File ...]<br/>
    <b>bzcat</b> [File ...]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    The bzip2 program handles compression and decompression of files in the bzip2 format.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode bzip2 aims to be fully compatible with BZip2.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.bzip.org/1.0.5/bzip2.txt">BZip2</a>
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2097" class="section-4">
<h1 class="book-heading">cat</h1>
<p><b>cat</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>cat</i></td>
<td></td>
<td>copies standard input to standard output</td>
</tr>
<tr>
<td><i>cat</i></td>
<td><i>&lt;filename&gt; ... </i></td>
<td>copies files to standard output</td>
</tr>
<tr>
<td><i>cat</i></td>
<td><i>--urls | -u &lt;url&gt; ... </i></td>
<td>copies objects  identified by URL to standard output</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>cat</i> command copies data to standard output, depending on the command line arguments:</p>
<ul>
<li>If there are no arguments, <i>cat</i> copies from standard input to standard output until it encounters "end of file" on the input stream.  If standard input is coming from the console, <b>CTRL-D</b> is used to denote end of file.
<li>If the arguments consist of file names, the corresponding file's contents are copied to standard output in the order specified.
<li>If the first argument is <i>--urls</i> or <i>-u</i>, the arguments are URLs.  The <i>cat</i> opens each URL in turn and copies the resulting data streams to standard output.  Supported URL protocols include "file:", "http:" and "ftp:".
</ul>
<p>The name "cat" is borrowed from UNIX, and is short for "concatenate".
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
There is no <i>dog</i> command.
</td>
</tr>
</table>
</div>
<div id="node-2136" class="section-4">
<h1 class="book-heading">cd</h1>
<p><b>cd</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>cd</i></td>
<td><i>[ &lt;dirName&gt; ]</i></td>
<td>change the current directory</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>cd</i> command changes the "current" directory for the current isolate, and everything running within it.  If a &lt;dirName&gt; argument is provided, that will be the new "current" directory.  Otherwise, the current directory is set to the user's "home" directory as given by the "user.home" property.</p>
<p>JNode currently changes the "current" directory by setting the "user.dir" property in the system properties object.</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
The global (to the isolate) nature of the "current" directory is a problem.  For example, if you have two non-isolated consoles, changing the current directory in one will change the current directory for the other,
</td>
</tr>
</table>
</div>
<div id="node-2463" class="section-4">
<h1 class="book-heading">class</h1>
<p><b>class</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>class</i></td>
<td><i>&lt;className&gt;</i></td>
<td>print details of a class</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>class</i> command allows you to print some details of any class on the shell's current classpath.  The <i>&lt;className&gt;</i> argument should be a fully qualified Java class name.  Running <i>class</i> will cause the named class to be loaded if this hasn't already happened.
</td>
</tr>
</table>
</div>
<div id="node-2535" class="section-4">
<h1 class="book-heading">classpath</h1>
<p><b>classpath</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>classpath</i></td>
<td></td>
<td>prints the current classpath</td>
</tr>
<tr>
<td><i>classpath</i></td>
<td><i>&lt;url&gt;</i></td>
<td>adds the supplied url to the end of the classpath</td>
</tr>
<tr>
<td><i>classpath</i></td>
<td><i>--clear</i></td>
<td>clears the classpath</td>
</tr>
<tr>
<td><i>classpath</i></td>
<td><i>--refresh</i></td>
<td>cause classes loaded from the classpath to be reloaded on next use</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>classpath</i> command controls the path that the command shell uses to locate commands to be loaded.  By default, the shell loads classes from the currently loaded plug-ins.  If the shell's classpath is non-empty, the urls on the path are searched ahead of the plug-ins.  Each shell instance has its own classpath.</p>
<p>If the &lt;url&gt; argument ends with a '/', it will be interpreted as a base directory that may contain classes and resources.  Otherwise, the argument is interpreted as the path for a JAR file.  While "file:" URLs are the norm, protocols like "ftp:" and "http:" should also work.
</td>
</tr>
</table>
</div>
<div id="node-2550" class="section-4">
<h1 class="book-heading">clear</h1>
<p><b>clear</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>clear</i></td>
<td></td>
<td>clear the console screen</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>clear</i> command clears the screen for the current command shell's console.
</td>
</tr>
</table>
</div>
<div id="node-2554" class="section-4">
<h1 class="book-heading">compile</h1>
<p><b>compile</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>compile</i></td>
<td><i>[ --test ] [ --level &lt;level&gt; ] &lt;className&gt;</i></td>
<td>compile a class to native code</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>compile</i> command uses the native code compiler to compile or recompile a class on the shell's class path.  The &lt;className&gt; argument should be the fully qualified name for the class to be compiled</p>
<p>The <i>--level</i> option allows you to select the optimization level.  The <i>--test</i> option allows you to compile with the "test" compilers.</p>
<p>This command is primarily used for <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/37">native code compiler</a> development.  JNode will automatically run the native code compiler on any class that is about to be executed for the first time.
</td>
</tr>
</table>
</div>
<div id="node-2597" class="section-4">
<h1 class="book-heading">console</h1>
<p><b>console</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>console</i></td>
<td><i>--list | -l</i></td>
<td>list all registered consoles</td>
</tr>
<tr>
<td><i>console</i></td>
<td><i>--new | -n [--isolated | --i]</i></td>
<td>starts a new console running the CommandShell</td>
</tr>
<tr>
<td><i>console</i></td>
<td><i>--test | -t</i></td>
<td>starts a raw text console (no shell)</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>console</i> command lists the current consoles, or creates a new one.</p>
<p>The first form of the <i>console</i> command list all consoles registered with the console manager.  The listing includes the console name and the "F&lt;n&gt;" code for selecting it.  (Use <b>ALT F&lt;n&gt;</b> to switch consoles.)</p>
<p>The second form of the <i>console</i> command starts and registers a new console running a new instance of CommandShell.  If the <i>--isolate</i> option is used with <i>--new</i>, the new console's shell will run in a new Isolate.</p>
<p>The last form of the <i>console</i> command starts a raw text console without a shell.  This is just for testing purposes.
</ul>
</td>
</tr>
</table>
</div>
<div id="node-2601" class="section-4">
<h1 class="book-heading">cpuid</h1>
<p><b>cpuid</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>cpuid</i></td>
<td></td>
<td>print the computer's CPU id and metrics</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>cpuid</i> command prints the computer's CPU id and metrics to standard output.
</td>
</tr>
</table>
</div>
<div id="node-2555" class="section-4">
<h1 class="book-heading">date</h1>
<p><b>date</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>date</i></td>
<td></td>
<td>print the current date</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>date</i> command prints the current date and time to standard output.  The date / time printed are relative to the machine's local time zone.</p>
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
A fixed format is used to output date and times.</p>
<p>Printing date / time values as UTC is not supported.</p>
<p>This command will not help your love life.</p>
</td>
</tr>
</table>
</div>
<div id="node-2580" class="section-4">
<h1 class="book-heading">del</h1>
<p><b>del</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>del</i></td>
<td><i>[ -r | --recursive ] &lt;path&gt; ...</i></td>
<td>delete files and directories</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>del</i> command deletes the files and/or directories given by the  <i>&lt;path&gt;</i> arguments.  </p>
<p>Normally, the <i>del</i> command will only delete a directory if it is empty apart from the '.' and '..' entries. The <i>-r</i> option tells the <i>del</i> command to delete directories and their contents recursively.
</td>
</tr>
</table>
</div>
<div id="node-2596" class="section-4">
<h1 class="book-heading">device</h1>
<p><b>device</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>device</i></td>
<td></td>
<td>shows all devices</td>
</tr>
<tr>
<td><i>device</i></td>
<td><i>&lt;device&gt;</i></td>
<td>shows a specific device</td>
</tr>
<tr>
<td><i>device</i></td>
<td><i>( start | stop | restart | remove ) &lt;device&gt;</i></td>
<td>perform an action on a device</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>device</i> command shows information about JNode devices and performs generic  management actions on them.</p>
<p>The first form of the <i>device</i> command list all devices registered with the device manager, showing their device ids, driver class names and statuses.  </p>
<p>The second form of the <i>device</i> command takes a device id given as the <i>&lt;device&gt;</i> argument.  It shows the above information for the corresponding device, and also lists all device APIs implemented by the device.  Finally, if the device implements the "DeviceInfo" API, it is used to get further device-specific information.</p>
<p>The last form of the <i>device</i> command performs actions on the device denoted by the device id given as the <i>&lt;device&gt;</i> argument.  The actions are as follows:</p>
<ul>
<li><i>start</i> - starts the device.
<li><i>stop</i> - stops the device.
<li><i>restart</i> - equivalent to <i>stop</i> followed by <i>start</i>.
<li><i>remove</i> - performs a <i>stop</i> and then removes the device from the device manager.
</ul>
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
This command does not allow you to perform device-specific actions.
</td>
</tr>
</table>
</div>
<div id="node-2630" class="section-4">
<h1 class="book-heading">df</h1>
<p><b>df</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>df</i></td>
<td><i>[ &lt;device&gt; ]</i></td>
<td>display disk space usage info</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>df</i> command prints disk space usage information for file systems.  If a <i>&lt;device&gt;</i>, usage information is displayed for the file system on the device.  Otherwise, information is displayed for all registered file systems.
</td>
</tr>
</table>
</div>
<div id="node-2610" class="section-4">
<h1 class="book-heading">dhcp</h1>
<p><b>dhcp</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>dhcp</i></td>
<td><i>&lt;device&gt;</i></td>
<td>configures a network interface using DHCP</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>dhcp</i> command configures the network interface given by <i>&lt;device&gt;</i> using settings obtained using DHCP.  DHCP is the most commonly used network configuration protocol.  The protocol provides an IP address and netmask for the machine, and the IP addresses of the local gateway and the local DNS service. </p>
<p>DHCP allocates IP address dynamically.  A DHCP server will often allocate the same IP address to a given machine, but this is not guaranteed.  If you require a fixed IP address for your JNode machine, you should use <i>bootp</i> or <i>ifconfig</i>.  (And, if you have a DHCP service on your network, you need to configure it to not reallocate your machine's staticly assigned IP address.)
</td>
</tr>
</table>
</div>
<div id="node-2633" class="section-4">
<h1 class="book-heading">dir</h1>
<p><b>dir</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>dir</i></td>
<td><i>[ &lt;path&gt; ]</td>
<td>list a file or directory</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>dir</i> command lists the file or directory given by the  <i>&lt;path&gt;</i> argument.  If no argument is provided, the current directory is listed.
</td>
</tr>
</table>
</div>
<div id="node-2989" class="section-4">
<h1 class="book-heading">dirname</h1>
<p><b>dirname</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>dirname</b> String
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    Strip non-directory suffix from file names
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode dirname is posix compatible.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.opengroup.org/onlinepubs/009695399/utilities/dirname.html">POSIX dirname</a>
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2556" class="section-4">
<h1 class="book-heading">disasm</h1>
<p><b>disasm</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>disasm</i></td>
<td><i>[ --test ] [ --level &lt;level&gt; ] &lt;className&gt; [ &lt;methodName&gt; ]</i></td>
<td>disassemble a class or method</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>disasm</i> command disassembles a class or method for a class on the shell's class path  The &lt;className&gt; argument should be the fully qualified name for the class to be compiled.  The &lt;methodName&gt; should be a method declared by the class.  If the method is overloaded, all of the overloads will be disassembled.</p>
<p>The <i>--level</i> option allows you to select the optimization level.  The <i>--test</i> option allows you to compile with the "test" compilers.</p>
<p>This command is primarily used for <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/37">native code compiler</a> development.  Note, contrary to its name and description above, the command doesn't actually disassemble the class method(s).  Instead it runs the native compiler in a mode that outputs assembly language rather than machine code.
</td>
</tr>
</table>
</div>
<div id="node-2553" class="section-4">
<h1 class="book-heading">echo</h1>
<p><b>echo</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>echo</i></td>
<td><i>[ &lt;text&gt; ... ]</i></td>
<td>print the argument text</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>echo</i> command prints the text arguments to standard output.  A single space is output between the arguments, and text is completed with a newline.
</td>
</tr>
</table>
</div>
<div id="node-2666" class="section-4">
<h1 class="book-heading">edit</h1>
<p><b>edit</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>edit</i></td>
<td><i>&lt;filename&gt;</i></td>
<td>edit a file</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>edit</i> command edits a text file given by the <i>&lt;filename&gt;</i> argument.  This editor is based on the "charva" text forms system.</p>
<p>The <i>edit</i> command displays a screen with two parts.  The top part is the menu section; press <b>ENTER</b> to display the file action menu.  The bottom part is the text editing window.    The <b>TAB</b> key selects menu entries, and also moves the cursor between the two screen parts.</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
This command needs more comprehensive user documentation.
</td>
</tr>
</table>
</div>
<div id="node-2635" class="section-4">
<h1 class="book-heading">eject</h1>
<p><b>eject</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>eject</i></td>
<td><i>[ &lt;device&gt; ... ]</td>
<td>eject a removable medium</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>eject</i> command ejects a removable medium (e.g. CD or floppy disk) from a device.
</td>
</tr>
</table>
</div>
<div id="node-2569" class="section-4">
<h1 class="book-heading">env</h1>
<p><b>env</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>env</i></td>
<td><i>[ -e | --env ] </i></td>
<td>print the system properties or environment variables</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
By default, the <i>env</i> command prints the system properties to standard output.  The properties are printed one per line in ascending order based on the property names.  Each line consists of a property name, the '=' character, and the property's value.</p>
<p>
If the <i>-e</i> or <i>--env</i> option is given, the <i>env</i> command prints out the current shell environment variables.  At the moment, this only works with the <a href="/web/20200119030613/http://www.jnode.org/node/88#CommandInterpreter">bjorne CommandInterpreter</a> and the <a href="/web/20200119030613/http://www.jnode.org/node/88#CommandInvoker">proclet CommandInvoker</a>.
</td>
</tr>
</table>
</div>
<div id="node-2572" class="section-4">
<h1 class="book-heading">exit</h1>
<p><b>exit</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>exit</i></td>
<td></td>
<td>cause the current shell to exit</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>exit</i> command causes the current shell to exit.  If the current shell is the JNode main console shell, JNode will shut down.
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
This should be handled as a shell interpreter built-in, and it should only kill the shell if the user runs it directly from the shell's command prompt.
</td>
</tr>
<tr>
</table>
</div>
<div id="node-2573" class="section-4">
<h1 class="book-heading">gc</h1>
<p><b>gc</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>gc</i></td>
<td></td>
<td>run the garbage collector</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>gc</i> command manually runs the garbage collector.</p>
<p>In theory, it should not be necessary to use this command.  The garbage collector should run automatically at the most appropriate time.  (A modern garbage collector will run most efficiently when it has lots of garbage to collect, and the JVM is in a good position to know when this is likely to be.)</p>
<p>In practice, it is necessary to run this command:</p>
<ul>
<li>to cope with GC-related issues; e.g. before running <i>startawt</i>,
<li>when debugging the garbage collector, and
<li>when doing performance-related benchmarking.
</ul>
</td>
</tr>
</table>
</div>
<div id="node-2575" class="section-4">
<h1 class="book-heading">grep</h1>
<p><b>grep</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>grep</b> [Options] Pattern [File ...]
  </td>
</tr>
<tr>
<td>
    <b>grep</b> [Options] [ -e Pattern | -f File ...] [File ...]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    <b>grep</b> searches the input <i>File</i>s (or standard input if not files are give, or if - is given as a file name) for lines containing a match to the <i>Pattern</i>. By default <b>grep</b> prints the matching lines.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode grep implements most of the POSIX grep standard<br/>
    JNode grep implements most of the GNU grep extensions
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.opengroup.org/onlinepubs/009695399/utilities/grep.html">Posix grep</a>
<li><a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/grep/doc/grep.html">GNU grep</a>
    </ul>
</td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Bugs</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li>grep -E and grep -B do not really work, instead they default to grep -P.
<li>grep -o/--only-matching does not work
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2985" class="section-4">
<h1 class="book-heading">gzip</h1>
<p><b>gzip</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>gzip</b> [Options] [-S suffix] [File ...]<br/>
    <b>gunzip</b> [Options] [-S suffix] [File ...]<br/>
    <b>zcat</b> [-f] [File ...]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    The gzip program handles the compress and decompression of files in the gzip format.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode gzip aims to be fully compatible with gnu zip.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.gzip.org/">GNU zip</a>
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2599" class="section-4">
<h1 class="book-heading">halt</h1>
<p><b>reboot</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>halt</i></td>
<td></td>
<td>shutdown and halt JNode</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>halt</i> command shuts down JNode services and devices, and puts the machine into a state in which it is safe to turn off the power.
</ul>
</td>
</tr>
</table>
</div>
<div id="node-2577" class="section-4">
<h1 class="book-heading">help</h1>
<p><b>help</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>help</i></td>
<td><i>[ &lt;name&gt; ]</i></td>
<td>print command help</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>help</i> command prints help for the command corresponding to the <i>&lt;name&gt;</i> argument.  This should be either an alias known to the current shell, or a fully qualified name of a Java command class.  If the <i>&lt;name&gt;</i> argument is omitted, this command prints help information for itself.</p>
<p>Currently, <i>help</i> prints command usage information and descriptions that it derives from a command's old or new-style argument and syntax descriptors.  This means that (unlike Unix "man" for example), the usage information will always be up-to-date.  </p>
<p>No help information is printed for Java applications which have no JNode syntax descriptors.
</td>
</tr>
</table>
</div>
<div id="node-2636" class="section-4">
<h1 class="book-heading">hexdump</h1>
<p><b>hexdump</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>hexdump</i></td>
<td><i>&lt;path&gt;</i></td>
<td>print a hex dump of a file</td>
</tr>
<tr>
<td><i>hexdump</i></td>
<td><i>-u | --url &lt;url&gt;</i></td>
<td>print a hex dump of a URL</td>
</tr>
<tr>
<td><i>hexdump</i></td>
<td></td>
<td>print a hex dump of standard input</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>hexdump</i> command prints a hexadecimal dump of a file, a URL or standard input.
</td>
</tr>
</table>
</div>
<div id="node-2578" class="section-4">
<h1 class="book-heading">history</h1>
<p><b>history</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>history</i></td>
<td></td>
<td>print the history list</td>
</tr>
<tr>
<td><i>history</i></td>
<td><i>[-t | --test] &lt;index&gt; | &lt;prefix&gt; </i></td>
<td>find and execute a command from the history list</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>history</i> command takes two form.  The first form (with no arguments) simply prints the current command history list.  The list is formatted with one entry per line, with each line starting with the history index.</p>
<p>The second form of the <i>history</i> command finds and executes a command from the history list and executes it.  If an <i>&lt;index&gt;</i> "i" is supplied, the "ith" entry is selected, with "0" meaning the oldest entry, "1" the second oldest and so on.  If a <i>&lt;prefix&gt;</i> is supplied, the first command found that starts with the prefix is executed.  The <i>--test</i> (or <i>-t</i>) flag tells the <i>history</i> command to print the selected command instead of executing it.
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>history</i> command currently does not execute the selected command.  This is maybe a good thing.  </p>
<p>When the shell executes a command, the history list gets reordered in a rather non-intuitive way.
</td>
</tr>
</table>
</div>
<div id="node-2611" class="section-4">
<h1 class="book-heading">ifconfig</h1>
<p><b>ifconfig</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>ifconfig</i></td>
<td><i></i></td>
<td>List IP address assignments for all network devices</td>
</tr>
<tr>
<td><i>ifconfig</i></td>
<td><i>&lt;device&gt;</i></td>
<td>List IP address assignments for one network device</td>
</tr>
<tr>
<td><i>ifconfig</i></td>
<td><i>&lt;device&gt; &lt;ipAddress&gt; [ &lt;subnetMask&gt; ]</i></td>
<td>Assign an IP address to a network device</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>ifconfig</i> command is used for assigning IP addresses to network devices, and printing network address bindings.</p>
<p>The first form prints the MAC address, assigned IP address(es) and MTU for all network devices.  You should see the "loopback" device in addition to devices corresponding to each of your machine's ethernet cards.</p>
<p>The second form prints the assigned IP address(es) for the given <i>&lt;device&gt;</i>.</p>
<p>The final form assigns the supplied IP address and associated subnet mask to the given <i>&lt;device&gt;</i>.
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
Only IPv4 addresses are currently supported.</p>
<p>When you attempt to bind an address, the output shows the address as "null", irrespective of the actual outcome.  Run "<i>ifconfig &lt;device&gt;</i>" to check that it succeeded
</td>
</tr>
</table>
</div>
<div id="node-2582" class="section-4">
<h1 class="book-heading">java</h1>
<p><b>java</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>java</i></td>
<td><i>&lt;className&gt; [ &lt;arg&gt; ... ]</i></td>
<td>run a Java class via its 'main' method</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>java</i> command runs the supplied class by calling its 'public static void main(String[])' entry point.  The &lt;className&gt; should be the fully qualified name of a Java class.  The <i>java</i> command will look for the class to be run on the current shell's classpath.  If that fails, it will look in the current directory.  The &lt;arg&gt; list (if any) is passed to the 'main' method as a String array.
</td>
</tr>
</table>
</div>
<div id="node-2602" class="section-4">
<h1 class="book-heading">kdb</h1>
<p><b>kdb</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>kdb</i></td>
<td></td>
<td>show the current kdb state</td>
</tr>
<tr>
<td><i>kdb</i></td>
<td><i>--on</i></td>
<td>turn on kdb</td>
</tr>
<tr>
<td><i>kdb</i></td>
<td><i>--off</i></td>
<td>turn off kdb</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>kdb</i> command allows you to control "kernel debugging" from the command line.  At the moment, the kernel debugging functionality is limited to copying the output produced by the light-weight "org.jnode.vm.Unsafe.debug(...)" calls to the serial port.  If you are running under VMWare, you can configure it to capture this in a file in the host OS.</p>
<p>The <i>kdb</i> command turns this on and off.  Kernel debugging is normally off when JNode boots, but you can alter this with a bootstrap switch.
</td>
</tr>
</table>
</div>
<div id="node-2664" class="section-4">
<h1 class="book-heading">leed, levi</h1>
<p><b>leed &amp; levi</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>leed</i></td>
<td><i>&lt;filename&gt;</i></td>
<td>edit a file</td>
</tr>
<tr>
<td><i>levi</i></td>
<td><i>&lt;filename&gt;</i></td>
<td>view a file</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>leed</i> and <i>levi</i> command respectively edit and view the text file given by the <i>&lt;filename&gt;</i> argument.  These commands open the editor in a new text console, and provide simple intuitive screen-based editing and viewing.</p>
<p>The <i>leed</i> command understands the following control functions:</p>
<ul>
<li><b>CTRL-S</b> saves the file.
<li><b>CTRL-Q</b> quits the editor.
</ul>
<p>The <i>levi</i> command understands the following control function:</p>
<ul>
<li><b>q</b> quits the viewer.
</ul>
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
These commands need more comprehensive user documentation.
</td>
</tr>
</table>
</div>
<div id="node-2583" class="section-4">
<h1 class="book-heading">loadkeys</h1>
<p><b>loadkeys</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>loadkeys</i></td>
<td></td>
<td>print the current keyboard interpreter</td>
</tr>
<tr>
<td><i>loadkeys</i></td>
<td><i>&lt;country&gt; [ &lt;language&gt; [&lt;variant&gt; ] ]</i></td>
<td>change the keyboard interpreter</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>loadkeys</i> command allows you to change the current keyboard interpreter. A JNode keyboard interpreter maps device specific codes coming from the physical keyboard into device independent keycodes.  This mapping serves to insulate the JNode operating system and applications from the fact that keyboards designed for different countries have different keyboard layouts and produce different codes.</p>
<p>A JNode keyboard interpreter is identified by a triple consisting of a 2 character ISO country code, together with an optional 2 character ISO language code and an optional variant identifier.  Examples of valid country codes include "US", "FR", "DE", and so on. Examples of language code include "en", "fr", "de" and so on.  (You  can use JNode completion to get complete lists of the codes.  Unfortunately, you cannot get the set of supported triples.)</p>
<p>When you run "<i>loadkeys &lt;country&gt; ...</i>, the command will attempt to find a keyboard interpreter class that matches the supplied triple.  These classes are in the "org.jnode.driver.input.i10n" package, and should be part of the plugin with the same identifier.  If <i>loadkeys</i> cannot find an interpreter that matches your triple, try making it less specific; i.e. leave out the &lt;language&gt; and &lt;variant&gt; parts of the triple.</p>
<p>Note: JNode's default keyboard layout is given by the "org/jnode/shell/driver/input/KeyboardLayout.properties" file.  (The directory location in the JNode source code tree is "core/src/driver/org/jnode/driver/input/".)
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b>
</td>
</tr>
<tr>
<td colspan="3">
<i>Loadkeys</i> should allow you to find out what keyboard interpreter are available without looking at the JNode source tree or plugin JAR files.</p>
<p><i>Loadkeys</i> should allow you to set the keyboard interpreter independently for each connected keyboard.</p>
<p><i>Loadkeys</i> should allow you to change key bindings at the finest granularity.  For example, the user should be able to (say) remap the "Windows" key to "Z" to deal with a broken "Z" key.  This would allow you to configure JNode to use a currently unsupported keyboard type.  (It would also help those game freaks out there who have been pounding on the "fire" key too much.)</p>
</td>
</tr>
</table>
</div>
<div id="node-2584" class="section-4">
<h1 class="book-heading">locale</h1>
<p><b>locale</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>locale</i></td>
<td></td>
<td>print the current default Locale</td>
</tr>
<tr>
<td><i>locale</i></td>
<td><i>--list | -l</i></td>
<td>list all available Locales</td>
</tr>
<tr>
<td><i>locale</i></td>
<td><i>&lt;language&gt; [ &lt;country&gt; [&lt;variant&gt; ] ]</i></td>
<td>change the default Locale</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>locale</i> command allows you to print, or change JNode's default Locale, or list all available Locales.
</td>
</tr>
</table>
</div>
<div id="node-2598" class="section-4">
<h1 class="book-heading">log4j</h1>
<p><b>console</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>log4j</i></td>
<td><i>--list | -l</i></td>
<td>list the current log4j Loggers</td>
</tr>
<tr>
<td><i>log4j</i></td>
<td><i>&lt;configFile&gt;</i></td>
<td>reloads log4j configs from a file</td>
</tr>
<tr>
<td><i>log4j</i></td>
<td><i>--url | -u &lt;configURL&gt;</i></td>
<td>reloads log4j configs from a URL</td>
</tr>
<tr>
<td><i>log4j</i></td>
<td><i>--setLevel | -s &lt;level&gt; [ &lt;logger&gt; ]</i></td>
<td>changes logging levels</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>log4j</i> command manages JNode's log4j logging system.  It can list loggers and logging levels, reload the logging configuration and adjust logging levels.</p>
<p>The first form of the <i>log4j</i> command list the currently defined Loggers and there explicit or effective logging levels.  An effective level is typically inherited from the "root" logger, and is shown in parentheses.</p>
<p>The second and third forms of the <i>log4j</i> command reload the log4j configurations from a file or URL.</p>
<p>The final form of the <i>log4j</i> command allows you to manually change logging levels.  You can use completion to see what the legal logging levels and the current logger names are.  If no &lt;logger&gt; argument is given, the command will change the level for the root logger.
</ul>
</td>
</tr>
</table>
</div>
<div id="node-2634" class="section-4">
<h1 class="book-heading">ls</h1>
<p><b>ls</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>ls</i></td>
<td><i>[ &lt;path&gt; ... ]</td>
<td>list files and directories</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>ls</i> command lists the files and/or directories given by the  <i>&lt;path&gt;</i> arguments.  If no arguments are provided, the current directory is listed.</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b>
</td>
</tr>
<tr>
<td colspan="3">
The current output format for 'ls' does not clearly distinguish between an argument that is a file and one that is a directory.  A format that looks more like the output for UNIX 'ls' would be better.
</td>
</tr>
</table>
</div>
<div id="node-2604" class="section-4">
<h1 class="book-heading">lsirq</h1>
<p><b>lsirq</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>lsirq</i></td>
<td></td>
<td>print IRQ handler information</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>lsirq</i> command prints interrupt counts and device names for each IRQ.
</td>
</tr>
</table>
</div>
<div id="node-2855" class="section-4">
<h1 class="book-heading">man</h1>
<p><b>man</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>man</i></td>
<td><i>[ &lt;name&gt; ]</i></td>
<td>print command help</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>man</i> command is an alias for <a href="/web/20200119030613/http://www.jnode.org/node/2577"><i>help</i></a>.<br/>
</tr>
</table>
</div>
<div id="node-2585" class="section-4">
<h1 class="book-heading">memory</h1>
<p><b>locale</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>memory</i></td>
<td></td>
<td>show JNode memory usage</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>memory</i> command shows how much JNode memory is in use and how much is free.
</td>
</tr>
</table>
</div>
<div id="node-2637" class="section-4">
<h1 class="book-heading">mkdir</h1>
<p><b>mkdir</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>mkdir</i></td>
<td><i>&lt;path&gt;</td>
<td>create a new directory</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>mkdir</i> command creates a new directory.  All directories in the supplied path must already exist.
</td>
</tr>
</table>
</div>
<div id="node-2638" class="section-4">
<h1 class="book-heading">mount</h1>
<p><b>mount</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>mount</i></td>
<td></td>
<td>show all mounted file systems</td>
</tr>
<tr>
<td><i>mount</i></td>
<td><i>&lt;device&gt; &lt;directory&gt; &lt;fsPath&gt; </i></td>
<td>mount a file system</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>mount</i> command manages mounted file systems.  The first form of the command shows all mounted file systems showing the mount points and the device identifiers.</p>
<p>The second form of the command mounts a file system.  The file system on <i>&lt;device&gt;</i> is mounted as <i>&lt;directory&gt;</i>, with <i>&lt;fsPath&gt;</i> specifying the directory in the file system being mounted that will be used as the root of the file system.  Note that the mount point given by <i>&lt;directory&gt;</i> must not exist before <i>mount</i> is run.  (JNode mounts the file system <b>as</b> the mount point, not on top of it as UNIX and Linux do.)
</td>
</tr>
</table>
</div>
<div id="node-2587" class="section-4">
<h1 class="book-heading">namespace</h1>
<p><b>locale</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>namespace</i></td>
<td></td>
<td>Print the contents of the system namespace</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>namespace</i> command shows the contents of the system namespace.  The output   gives the class names of the various managers and services in the namespace.
</td>
</tr>
</table>
</div>
<div id="node-2613" class="section-4">
<h1 class="book-heading">netstat</h1>
<p><b>netstat</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>netstat</i></td>
<td></td>
<td>Print network statistics</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>netstat</i> command prints address family and protocol statistics gathered by JNode's network protocol stacks.
</td>
</tr>
</table>
</div>
<div id="node-2588" class="section-4">
<h1 class="book-heading">onheap</h1>
<p><b>onheap</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>onheap</i></td>
<td><i>[--minCount &lt;count&gt;] [--minTotalSize &lt;size&gt;] [--className &lt;size&gt;]*</td>
<td>Print per-class heap usage statistics</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>onheap</i> command scans the heap to gather statistics on heap usage.  Then it outputs a per-class breakdown, showing the number of instances of each class and the total space used by those instances.</p>
<p>When you run the command with no options, the output report shows the heap usage for all classes.  This is typically too large to be directly useful.  If you are looking for statistics for specific classes, you can pipe the output to the <i>grep</i> command and select the classes of interest with a regex.  If you are trying to find out what classes are using a lot of space, you can use the <i>onheap</i> command's options to limit the output as follows:</p>
<ul>
<li><i>--minCount &lt;count&gt;</i> : this option filters out any classes that have less than &lt;count&gt; instances.
<li><i>--minTotalSize &lt;size&gt;</i> : this option filters out any classes for which the total space usage is less than &lt;size&gt; bytes.
<li><i>--className &lt;substring&gt;</i> : this option filters out any classes whose name doesn't contain &lt;substring&gt;.
</ul>
</td>
</tr>
</table>
</div>
<div id="node-2796" class="section-4">
<h1 class="book-heading">page</h1>
<p><b>page</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>page</i></td>
<td><i>[ &lt;file&gt; ]</i></td>
<td>page a file</td>
</tr>
<tr>
<td><i>page</i></td>
<td></td>
<td>page standard input</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>page</i> command displays the supplied file a screen page at a time on a new virtual console.  If no arguments are provided, standard input is paged.</p>
<p>
The command uses keyboard input to control paging.  For example, a space character advances one screen page and ENTER advances one line.   Enter 'h' for a listing of the available pager commands and actions.
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b>
</td>
</tr>
<tr>
<td colspan="3">
While the current implementation does not pre-read an input stream, nothing will be displayed until the next screen full is available.  Also, the entire contents of the file or input stream will be buffered in memory.</p>
<p>
A number useful features supported by typical 'more' and 'less' commands have not been implemented yet.
</td>
</tr>
</table>
</div>
<div id="node-2614" class="section-4">
<h1 class="book-heading">ping</h1>
<p><b>ping</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>ping</i></td>
<td><i>&lt;host&gt;</i></td>
<td>Ping a remote host</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>ping</i> command sends ICMP PING messages to the remote host given by <i>&lt;host&gt;</i> and prints statistics on the replies received.  Pinging is a commonly used technique for testing that a remote host is contactable.  However, ping "failure" does not necessarily mean that the machine is uncontactable.  Gateways and even hosts are often configured to silently block or ignore PING messages.</p>
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>ping</i> command uses hard-wired parameters for the PING packet's TTL, size, count, interval and timeout.  These should be command line options.
</td>
</tr>
</table>
</div>
<div id="node-2609" class="section-4">
<h1 class="book-heading">plugin</h1>
<p><b>plugin</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>plugin</i></td>
<td></td>
<td>List all plugins and their status</td>
</tr>
<tr>
<td><i>plugin</i></td>
<td><i>&lt;plugin&gt;</i></td>
<td>List a given plugin</td>
</tr>
<tr>
<td><i>plugin</i></td>
<td><i>--load | -l &lt;plugin&gt; [ &lt;version&gt; ]</i></td>
<td>Load a plugin</td>
</tr>
<tr>
<td><i>plugin</i></td>
<td><i>--unload | -u &lt;plugin&gt;</i></td>
<td>Unload a plugin</td>
</tr>
<tr>
<td><i>plugin</i></td>
<td><i>--reload | -r &lt;plugin&gt; [ &lt;version&gt; ]</i></td>
<td>Reload a plugin</td>
</tr>
<tr>
<td><i>plugin</i></td>
<td><i>--addLoader | -a &lt;url&gt;</i></td>
<td>Add a new plugin loader</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>plugin</i> command lists and manages plugins and plugin loaders.</p>
<p>The no argument form of the command lists all plugins known to the system, showing each one's status.</p>
<p>The one argument form lists a single plugin.</p>
<p>The <i>--load</i>, <i>--unload</i> and <i>--reload</i> options tell the <i>plugin</i> command to load, unload or reload a specified plugin.  The <i>--load</i> and <i>--reload</i> forms can also specify a version of the plugin to load or reload.</p>
<p>The <i>--addLoader</i> option configures a new plugin loader that will load plugin from the location given by the <i>&lt;url&gt;</i>.
</td>
</tr>
</table>
</div>
<div id="node-2980" class="section-4">
<h1 class="book-heading">propset</h1>
<p><b>propset</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>propset</i></td>
<td><i>[ -s | --shell ] &lt;name&gt; [ &lt;value&gt; ] </i></td>
<td>Set or remove a property</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>propset</i> command sets and removes properties in either the System property space or (if <i>-s</i> or <i>--shell</i> is used) Shell property space.  If both <i>&lt;name&gt;</i> and <i>&lt;value&gt;</i> are supplied, the property <i>&lt;name&gt;</i> is set to the supplied <i>&lt;value&gt;</i>.  If just <i>&lt;name&gt;</i> is given, the named property is removed.</p>
<p>
The System property space consists of the properties returned by "System.getProperty()".  This space are currently isolate-wide, but there are moves afoot to make it proclet specific.  The Shell property space consists of properties stored by each Shell instance.  This space is is separate from an shell interpreter's variable space, and persists over changes in a Shell's interpreter.</p>
<p>
The 'set' command is an alias for 'propset', but if you are using the 'bjorne' interpreter the 'set' alias is obscured by the POSIX 'set' builtin command which has incompatible semantics.  Hence 'propset' is the recommended alias.
</td>
</tr>
</table>
</div>
<div id="node-2639" class="section-4">
<h1 class="book-heading">pwd</h1>
<p><b>pwd</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>pwd</i></td>
<td></td>
<td>print the pathname for current directory</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>pwd</i> command prints the pathname for the current directory; i.e. the value of the System "user.dir" property mapped to an absolute pathname.  Note that the current directory is not guaranteed to exist, or to ever have existed.
</ul>
</td>
</tr>
</table>
</div>
<div id="node-2629" class="section-4">
<h1 class="book-heading">ramdisk</h1>
<p><b>ramdisk</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>ramdisk</i></td>
<td><i>-c | --create [ -s | --size &lt;size&gt; ]</td>
<td></td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>ramdisk</i> command manages RAM disk devices.  A RAM disk is a simulated disk device that uses RAM to store its state.</p>
<p>The <i>--create</i> form of the command creates a new RAM disk with a size in bytes given by the <i>--size</i> option  The default size is 16K bytes.  Note that the RAM disk has a notional block size of 512 bytes, so the size should be a multiple of that.</p>
</td>
</tr>
</table>
</div>
<div id="node-2600" class="section-4">
<h1 class="book-heading">reboot</h1>
<p><b>reboot</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>reboot</i></td>
<td></td>
<td>shutdown and reboot JNode</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>reboot</i> command shuts down JNode services and devices, and then reboots the machine.
</ul>
</td>
</tr>
</table>
</div>
<div id="node-2593" class="section-4">
<h1 class="book-heading">remoteout</h1>
<p><b>remoteout</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>remoteout</i></td>
<td><i>[--udp | -u] --host | -h &lt;host&gt; [--port | -p &lt;port&gt;]</i></td>
<td>Copy console output and logging to a remote receiver</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
Running the <i>remoteout</i> command tells the shell to copy console output (both 'out' and 'err') and logger output to a remote TCP or UDP receiver.  The options are as follows:</p>
<ul>
<li><i>--host | -h &lt;host&gt;</i> - this option specifies the hostname or IP address of the host running the remote receiver.</li>
<li><i>--port | -p &lt;port&gt;</i> - this option specifies the port number for the remote receiver.  The default port is 5612.</li>
<li><i>--udp | -u</i> - this option tells <i>remoteout</i> to use UDP.  The default is to use TCP.  UDP is inherently lossy, but TCP mode currently does not allow logger output to be captured; see Bugs.</li>
</ul>
<p>Before you run <i>remoteout</i> on JNode, you need to start a TCP or UDP receiver on the relevant remote host and port.  The JNode codebase includes a simple receiver application implemented in Java.  You can run as follows:</p>
<p><i>&nbsp;&nbsp;&nbsp;&nbsp;java -cp $JNODE/core/build/classes org.jnode.debug.RemoteReceiver &amp;</i></p>
<p>Running the <i>RemoteReceiver</i> application with the <i>--help</i> option will print out a "usage" message.</p>
<p>Notes:</p>
<ol>
<li>Before you run <i>remoutout</i>, you will need to <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/527">configure JNode networking</a>.
<li>If you have problems getting <i>remoteout</i> to work, check that network access is not being blocked by a network firewall or local firewall software on the remote host.  (TCP and UDP access on non-standard ports like 5612 is often blocked by default.)
</ol>
</td>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b>
</td>
</tr>
<tr>
<td colspan="3">
In addition to the inherent lossiness of UDP, the UDPOutputStream implementation can discard output arriving simultaneously from multiple threads.</p>
<p>Logger output redirection is disabled in TCP mode due to a bug that triggers kernel panics.</p>
<p>There is currently no way to turn off console/logger copying once it has been started.</p>
<p>Running <i>remoteout</i> and a receiver on the same JNode instance, may cause JNode to lock up in a storm of console output.
</td>
</tr>
</tr>
</table>
</div>
<div id="node-2617" class="section-4">
<h1 class="book-heading">resolver</h1>
<p><b>resolver</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>resolver</i></td>
<td></td>
<td>List the DNS servers the resolver uses</td>
</tr>
<tr>
<td><i>resolver</i></td>
<td><i>--add | -a &lt;ipAddr&gt;</i></td>
<td>Add a DNS server to the resolver list</td>
</tr>
<tr>
<td><i>resolver</i></td>
<td><i>--del | -d &lt;ipAddr&gt;</i></td>
<td>Remove a DNS server from the resolver list</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>resolver</i> manages the list of DNS servers that the Resolver uses to resolve names of remote computers and services.</p>
<p>The zero argument form of <i>resolver</i> list the IP addresses of the DNS servers in the order that they are used.</p>
<p>The <i>--add</i> form adds a DNS aerver (identified by a numeric IP address) to the front of the resolver list.</p>
<p>The <i>--del</i> form removes a DNS server from the resolver list.
</td>
</tr>
</tr>
</table>
</div>
<div id="node-2619" class="section-4">
<h1 class="book-heading">route</h1>
<p><b>route</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>route</i></td>
<td></td>
<td>List the network routing tables</td>
</tr>
<tr>
<td><i>route</i></td>
<td><i>--add | -a &lt;target&gt; &lt;device&gt; [ &lt;gateway&gt; ]</i></td>
<td>Add a new route to the routing tables</td>
</tr>
<tr>
<td><i>route</i></td>
<td><i>--del | -d &lt;target&gt; &lt;device&gt; [ &lt;gateway&gt; ]</i></td>
<td>Remove a route from the routing tables</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The routing table tells the JNode network stacks which network devices to use to send packets to remote machines.  A routing table entry consists of the "target" address for a host or network, the device to use when sending to that address, and optionally the address of the local gateway to use.</p>
<p>The <i>route</i> command manages the routing table.  The no-argument form of the command lists the current routing table.  The <i>--add</i> and <i>--del</i> add and delete routes respectively.</p>
<p>For more information on how to use <i>route</i> to configure JNode networking, refer to the FAQ.
</td>
</tr>
</table>
</div>
<div id="node-2618" class="section-4">
<h1 class="book-heading">rpcinfo</h1>
<p><b>rpcinfo</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>rpcinfo</i></td>
<td><i>&lt;host&gt;</i></td>
<td>Probe a remote host's ONC portmapper service</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>rpcinfo</i> command sends a query to the OMC portmapper service running on the remote <i>&lt;host&gt;</i> and lists the results.
</td>
</tr>
</table>
</div>
<div id="node-2863" class="section-4">
<h1 class="book-heading">run</h1>
<p><b>run</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>run</i></td>
<td><i>&lt;file&gt;</i></td>
<td>Run a command script</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>run</i> command runs a command script.  If the script starts with a line of the form</p>
<pre>#!&lt;interpreter&gt;
</pre><p>where <i>&lt;interpreter&gt;</i> is the name of a registered CommandInterpreter, the script will be run using the nominated interpreter.  Otherwise, the script will be run using the shell's current interpreter.
</td>
</tr>
</table>
</div>
<div id="node-2866" class="section-4">
<h1 class="book-heading">startawt</h1>
<p><b>startawt</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>startawt</i></td>
<td></td>
<td>start the JNode Graphical User Interface</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>startawt</i> command starts the JNode GUI and launches the desktop class specified by the system property <i>jnode.desktop</i>.  The default value is <i>"org.jnode.desktop.classic.Desktop"</i></p>
<p>There is more information on the <a href="/web/20200119030613/http://www.jnode.org/node/936">JNode GUI</a> page, including information on how to exit the GUI.
</td>
</tr>
</table>
</div>
<div id="node-2545" class="section-4">
<h1 class="book-heading">syntax</h1>
<p><b>syntax</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>syntax</i></td>
<td></td>
<td>lists all aliases that have a defined syntax</td>
</tr>
<tr>
<td><i>syntax</i></td>
<td><i>--load | -l  </i></td>
<td>loads the syntax for an alias from a file</td>
</tr>
<tr>
<td><i>syntax</i></td>
<td><i>--dump | -d </i></td>
<td>dumps the syntax for an alias to standard output</td>
</tr>
<td><i>syntax</i></td>
<td><i>--dump-all</i></td>
<td>dumps all syntaxes to standard output</td>
</tr>
<tr>
<td><i>syntax</i></td>
<td><i>--remove | -r alias</i></td>
<td>remove the syntax for the alias</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>syntax</i> command allows you to override the built-in syntaxes for commands that use the new command syntax mechanism.  The command can "dump" a command's current syntax specification as XML, and "load" a new one from an XML file.  It can also "remove" a syntax, provided that the syntax was defined or overridden in the command shell's syntax manager.</p>
<p>The built-in syntax for a command is typically specified in the plugin descriptor for a parent plugin of the command class.  If there is no explicit syntax specification, a default one will be created on-the-fly from the command's registered arguments.</p>
<p>Note: not all classes use the new syntax mechanism.  Some JNode command classes use an older mechanism that is being phased out.  Other command classes use the classic Java approach of decoding arguments passed via a "public static void main(String[])" entry point.
</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b><br/>
</tr>
<tr>
<td colspan="3">
The XML produced by "--dump" or "--dump-all" should be pretty-printed to make it more readable / editable.
</td>
</tr>
</table>
</div>
<div id="node-2982" class="section-4">
<h1 class="book-heading">tar</h1>
<p><b>tar</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>tar</b> -Acdtrux [Options] [File ...]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    The tar program provides the ability to create tar archives, as well as various other kinds of manipulation. For example, you can use tar on previously created archives to extract files, to store additional files, or to update or list files which were already stored.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode tar aims to be fully compliant with gnu tar.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/tar/manual/html_node/index.html">GNU tar</a>
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2612" class="section-4">
<h1 class="book-heading">tcpinout</h1>
<p><b>tcpinout</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>tcpinout</i></td>
<td><i>&lt;host&gt; &lt;port&gt;</i></td>
<td>Run tcpinout in client mode</td>
</tr>
<tr>
<td><i>tcpinout</i></td>
<td><i>&lt;local port&gt;</i></td>
<td>Run tcpinout in server mode</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>tcpinout</i> command is a test utility that sets up a TCP connection to a remote host and then connects the command's input and output streams to the socket.  The command's standard input is read and sent to the remote machine, and simultaneously output from the remote machine is written to the command's standard output.  This continues until the remote host closes the socket or a network error occurs.</p>
<p>In "client mode", the <i>tcpinout</i> command opens a connection to the supplied <i>&lt;host&gt;</i> and <i>&lt;port&gt;</i>.  This assumes that there is a service on the remote host that is "listening" for connections on the port.</p>
<p>In "server mode", the <i>tcpinout</i> command listens for an incoming TCP connection on the supplied <i>&lt;local port&gt;</i>.
</td>
</tr>
</table>
</div>
<div id="node-2589" class="section-4">
<h1 class="book-heading">thread</h1>
<p><b>thread</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>thread</i></td>
<td><i>[--groupDump | -g]</td>
<td>Display info for all extand Threads</td>
</tr>
<tr>
<td><i>thread</i></td>
<td><i>&lt;threadName&gt;</td>
<td>Display info for the named Thread</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b>
</td>
</tr>
<tr>
<td colspan="3">
The <i>thread</i> command can display information for a single Thread or all Threads  that are still extant.</p>
<p>The first form of the command traverses the ThreadGroup hierarchy, displaying information for each Thread that it finds.  The information displayed consists of the Thread's 'id', its 'name', its 'priority' and its 'state'.  The latter tells you (for example) if the thread is running, waiting on a lock or exited.  If the Thread has died with an uncaught exception, you will also see a stacktrace.</p>
<p>If you set the <i>--groupDump</i> flag, the information is produced by calling the "GroupInfo.list()" debug method.  The output contains more information but the format is ugly.</p>
<p>The second form of the <i>thread</i> command outputs information for the thread given by the &lt;threadName&gt; argument.  No ThreadGroup information is shown.</p>
</td>
<tr class="groupHeader">
<td colspan="3">
<b>Bugs</b>
</td>
</tr>
<tr>
<td colspan="3">
The output does not show the relationship between ThreadGroups unless you use <i>--groupDump</i>.</p>
<p>The second form of the command should set a non-zero return code if it cannot find the requested thread.</p>
<p>There should be a variant for selecting Threads by 'id'.
</td>
</tr>
</tr>
</table>
</div>
<div id="node-2990" class="section-4">
<h1 class="book-heading">time</h1>
<p><b>time</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>time</b> Alias [Args]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    Executes the command given by <i>Alias</i> and outputs the total execution time of that command.
  </td>
</tr>
</table>
</div>
<div id="node-2137" class="section-4">
<h1 class="book-heading">touch</h1>
<p><b>cd</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>touch</i></td>
<td><i>&lt;filename&gt;</i></td>
<td>create a file if it does not exist</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>touch</i> command creates the named file if it does not already exist.  If the <i>&lt;filename&gt;</i> is a pathname rather than a simple filename, the command will also create parent directories as required.
</td>
</tr>
</table>
</div>
<div id="node-2984" class="section-4">
<h1 class="book-heading">unzip</h1>
<p><b>unzip</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>unzip</b> [Options] Archive [File ...] [-x Pattern] [-d Directory]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    The unzip program handles the extraction and listing of archives based on the PKZIP format.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode unzip aims to be compatible with INFO-Zip.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.info-zip.org/">INFO-Zip</a>
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2608" class="section-4">
<h1 class="book-heading">utest</h1>
<p><b>utest</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>utest</i></td>
<td><i>&lt;classname&gt;</i></td>
<td>runs the JUnit tests in a class.</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>utest</i> command loads the class given by &lt;className&gt; creates a JUnit TestSuite from it, and then runs the TestSuite using a text-mode TestRunner.  The results are written to standard output.
</td>
</tr>
</table>
</div>
<div id="node-2605" class="section-4">
<h1 class="book-heading">vminfo</h1>
<p><b>vminfo</b></p>
<table border="0">
<tr class="groupHeader">
<td colspan="3"><b>Synopsis</b></td>
</tr>
<tr>
<td><i>vminfo</i></td>
<td><i>[ --reset ]</i></td>
<td>show JNode VM information</td>
</tr>
<tr class="groupHeader">
<td colspan="3">
<b>Details</b><br/>
</tr>
<tr>
<td colspan="3">
The <i>vminfo</i> command prints out some statistics and other information about the JNode VM.  The <i>--reset</i> flag causes some VM counters to be zeroed after their values have been printed.
</td>
</tr>
</table>
</div>
<div id="node-2987" class="section-4">
<h1 class="book-heading">wc</h1>
<p><b>wc</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>wc</b> [-cmlLw] [File ...]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    print newline, word and byte counts for each file.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode wc is posix compatible.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.opengroup.org/onlinepubs/009695399/utilities/wc.html">POSIX wc</a>
    </ul>
</td>
</tr>
</table>
</div>
<div id="node-2983" class="section-4">
<h1 class="book-heading">zip</h1>
<p><b>zip</b></p>
<table border="0">
<tr class="groupHeader">
<td><b>Synopsis</b></td>
</tr>
<tr>
<td>
    <b>zip</b> [Options] [Archive] [File ...] [-xi Pattern]
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Details</b>
  </td>
</tr>
<tr>
<td>
    The zip program handles the creation and modification of zip archives based on the PKZIP format.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Compatibility</b>
  </td>
</tr>
<tr>
<td>
    JNode zip aims to be compatible with INFO-Zip.
  </td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<tr class="groupHeader">
<td>
    <b>Links</b>
  </td>
</tr>
<tr>
<td>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.info-zip.org/">INFO-Zip</a>
    </ul>
</td>
</tr>
</table>
</div>
</div>
<div id="node-936" class="section-3">
<h1 class="book-heading">JNode GUI</h1>
<p><b><u>Starting the JNode GUI</u></b></p>
<p>JNode supports a GUI which runs a graphical desktop and a limited number of applications.  The normal way to launch the JNode GUI is to boot JNode normally, and then at the console command prompt run the following:</p>
<pre>    JNode&gt; gc
    JNode&gt; startawt
</pre><p>
The screen will go blank for some time (30 to 60 seconds is common), and then the JNode desktop will be displayed.</p>
<p><b><u>Using the JNode GUI</u></b></p>
<p>The JNode GUI enables the following special key bindings:</p>
<table>
<tr>
<td>&lt;ALT&gt; + &lt;CTRL&gt; + &lt;F5&gt;</td>
<td>Refresh the GUI</td>
</tr>
<tr>
<td>&lt;ALT&gt; + &lt;F11&gt;</td>
<td>Leaves the GUI</td>
</tr>
<tr>
<td>&lt;ALT&gt; + &lt;F12&gt;</td>
<td>Quits the GUI</td>
</tr>
<tr>
<td>&lt;ALT&gt; + &lt;CTRL&gt; + &lt;BackSpace&gt;</td>
<td>Quits the GUI</td>
<td>(<b>Don't use this if you are under Linux/Unix</b> : it will quits Linux GUI)</td>
</tr>
</table>
<p><b><u>Trouble-shooting</u></b><br/>
If the GUI fails to come up after a reasonable length of time, try using &lt;ALT&gt; + &lt;F12&gt; or &lt;ALT&gt; + &lt;CTRL&gt; + &lt;BackSpace&gt; to return to the text console.  When you get back to the console, look for any relevant messages on the current console and on the logger console (&lt;ALT&gt; + &lt;F7&gt;).</p>
<p>One possible cause of GUI not launching is that JNode may run out of memory while compiling the GUI plugins to native code.  If this appears to be the case and you are running a virtual PC (e.g. using VMware, etc), try changing the memory size of the virtual PC.</p>
<p>Another possible cause of problems may be that JNode doesn't have a working device driver for your PC's graphics card.  If this is the case, you could try booting JNode in VESA mode.   To do this, simply boot JNode selecting a "(VESA mode)" entry from the GRUB boot menu.</p>
</div>
<div id="node-88" class="section-3">
<h1 class="book-heading">JNode Shell</h1>
<p><u><b>Introduction</b></u></p>
<p>The JNode command shell allows commands to be entered and run interactively from the JNode command prompt or run from command script files.  Input to entered at the command prompt (or read from a script file) is first split into command lines by a <i>command interpreter</i>; see below.  Each command line is split into command name (an <i>alias</i> in JNode parlance) and a sequence of arguments.  Finally, each command alias is mapped to a class name, and run by a  <i>command invoker</i>.</p>
<p>The available aliases can be listed by typing</p>
<p><i>JNode /&gt;</i> <b>alias&lt;ENTER&gt;</b></p>
<p>and an aliases syntax and built-in help can be displayed by typing</p>
<p><i>JNode /&gt;</i> <b>help <i>alias</i>&lt;ENTER&gt;</b></p>
<p>More extensive documentation for most commands can be found in the <a>JNode Commands</a> index.</p>
<p><u><b>Keyboard Bindings</b></u></p>
<p>The command shell (or more accurately, the keyboard interpreter) implements the following keyboard events:</p>
<table>
<tr>
<td><b>&lt;SHIFT&gt;+&lt;UP ARROW&gt;</b></td>
<td>Scroll the console up a line</td>
</tr>
<tr>
<td><b>&lt;SHIFT&gt;+&lt;DOWN-ARROW&gt;</b></td>
<td>Scroll the console down a line</td>
</tr>
<tr>
<td><b>&lt;SHIFT&gt;+&lt;PAGE-UP&gt;</b></td>
<td>Scroll the console up a page</td>
</tr>
<tr>
<td><b>&lt;SHIFT&gt;+&lt;PAGE-DOWN&gt;</b></td>
<td>Scroll the console down a page</td>
</tr>
<tr>
<td><b>&lt;ALT&gt;+&lt;F1&gt;</b></td>
<td>Switch to the main command console</td>
</tr>
<tr>
<td><b>&lt;ALT&gt;+&lt;F2&gt;</b></td>
<td>Switch to the second command console</td>
</tr>
<tr>
<td><b>&lt;ALT&gt;+&lt;F7&gt;</b></td>
<td>Switch to the Log console (read only)</td>
</tr>
<tr>
<td><b>&lt;ESC&gt;</b></td>
<td>Show command usage message(s)</td>
</tr>
<tr>
<td><b>&lt;TAB&gt;</b></td>
<td>Command / input completion</td>
</tr>
<tr>
<td><b>&lt;UP-ARROW&gt;</b></td>
<td>Go to previous history entry </td>
</tr>
<tr>
<td><b>&lt;DOWN-ARROW&gt;</b></td>
<td>Go to next history entry</td>
</tr>
<tr>
<td><b>&lt;LEFT-ARROW&gt;</b></td>
<td>Move cursor left</td>
</tr>
<tr>
<td><b>&lt;RIGHT-ARROW&gt;</b></td>
<td>Move cursor right</td>
</tr>
<tr>
<td><b>&lt;BACKSPACE&gt;</b></td>
<td>Delete character to left of cursor</td>
</tr>
<tr>
<td><b>&lt;DELETE&gt;</b></td>
<td>Delete character to right of cursor</td>
</tr>
<tr>
<td><b>&lt;CTRL&gt;+&lt;C&gt;</b></td>
<td>Interrupt command (currently disabled)</td>
</tr>
<tr>
<td><b>&lt;CTRL&gt;+&lt;D&gt;</b></td>
<td>Soft EOF</td>
</tr>
<tr>
<td><b>&lt;CTRL&gt;+&lt;Z&gt;</b></td>
<td>Continue the current command in the background</td>
</tr>
<tr>
<td><b>&lt;CTRL&gt;+&lt;L&gt;</b></td>
<td>Clear the console and the input line buffer</td>
</tr>
</table>
<p>Note: you can change the key bindings using the <a href="/web/20200119030613/http://www.jnode.org/node/3060">bindkeys</a> command.</p>
<p><u><b>Command Completion and Incremental Help</b></u></p>
<p>The JNode command shell has a sophisticated command completion mechanism that is tied into JNode's native command syntax mechanisms.  Completion is performed by typing the  &lt;TAB&gt; key.</p>
<p>If you enter a partial command name as follows.</p>
<p><i>JNode /&gt;</i> <b>if</b></p>
<p>If you now enter &lt;TAB&gt; the shell will complete the command as follows:</p>
<p><i>JNode /&gt;</i> <b>ifconfig </b></p>
<p>with space after the "g" so that you can enter the first argument.  If you enter &lt;TAB&gt;<br/>
again, JNode will list the possible completions for the first argument as follows:</p>
<p><i>eth-pci(0,16,0)</i><br><br/>
<i>loopback</i><br><br/>
<i>JNode /&gt;</i> <b>ifconfig </b></p>
<p>This is telling you that the possible values for the first argument are "eth-pci(0,16,0)" and "loopback"; i.e. the names of all network devices that are currently available.  If you now enter "l" followed by &lt;TAB&gt;, the shell will complete the first argument as follows:</p>
<p><i>JNode /&gt;</i> <b>ifconfig loopback</b></p>
<p>and so on.  Completion can be performed on aliases, option names and argument types such as file and directory paths and device and plugin names.</p>
<p>While completion can be used to jolt your memory, it is often useful to be able to see the syntax description for the command you are entering.  If you are in the middle of entering a command, entering &lt;CTRL-?&gt; will parse what you have typed in so far against the aliases syntax, and then print the syntax description for the alternative(s) that match what you have entered.</p>
<p><u><b>Command Interpreters</b></u><br/>
<a name="CommandInterpreter"></a></p>
<p>The JNode command shell uses a CommandInterpreter object to translate the characters typed at the command prompt into the names and arguments for commands to be executed.  There are currently 3 interpreters available:</p>
<ul>
<li>"default" - this bare-bones interpreter splits a line into a simple command name (alias) and arguments.  It understands argument quoting, but little else.
<li>"redirecting" - this interpreter adds the ability to use "&lt;" and "&gt;" for redirecting standard input and standard output, and "|" for simple command pipelines.  This is the default interpreter.
<li>"bjorne" - this interpreter is an implementation of the POSIX shell specification; i.e. it is like UNIX / GNU Linux shells such as "sh", "bash" and "ksh".  The bjorne interpreter is still under development.  Refer to the <a href="/web/20200119030613/http://www.jnode.org/node/2860">bjorne tracking issue</a> for a summary of implemented features and current limitations.
</ul>
<p>The JNode command shell currently consults the "jnode.interpreter" property to determine what interpreter to use.  You can change the current interpreter using the "propset -s" command; e.g.</p>
<p><i>JNode /&gt;</i> <b>propset -s jnode.interpreter bjorne</b></p>
<p>Note that this only affects the current console, and that the setting does not persist beyond the next JNode reboot. </p>
<p><u><b>Command Invokers</b></u></p>
<p><a name="CommandInvoker"></a></p>
<p>The JNode command shell uses a CommandInvoker object to execute commands extracted from the command line by the interpreter.  This allows us to run commands in different ways.  There are currently 4 command invokers available:</p>
<ul>
<li>"default" - this invoker runs the command in the current Java Thread.
<li>"thread" - this invoker runs the command in a new Java Thread.
<li>"proclet" - this invoker runs the command in a new Proclet.  The proclet mechanism is a light-weight process mechanism that gives a degree of isolation, so that the command can have its own standard input, output and error streams.  The command can also see the "environment" variables of the parent interpreter.  This is the default invoker.
<li>"isolate" - this invoker runs the command in a new Isolate.  The isolate mechanism gives the command its own statics, as if the command is executing in a new JVM.  Isolates and the IsolateInvoker are not fully implemented.
</ul>
<p>The JNode command shell currently consults the "jnode.invoker" property to determine what invoker to use.  You can change the current invoker using the "propset -s" command; e.g.</p>
<p><i>JNode /&gt;</i> <b>propset -s jnode.invoker isolate</b></p>
<p>Note that this only affects the current console, and that the setting does not persist beyond the next JNode reboot. </p>
</table>
<div id="node-721" class="section-4">
<h1 class="book-heading">Testing remote programs in shell</h1>
<p>If you want to test some java application, but don't want to recompile JNode completly every time you change your application, you can use the classpath command.</p>
<p>Set up your network, if you don't know how, read the <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/527">FAQ</a>.</p>
<p>Now you have to setup a webserver or tftp server on your remote mashine, where you place your .class or .jar files.<br/>
With the classpath command you can now add a remote path. E.g. "classpath add http://192.168.0.1/path/to/classes/". Using "classpath" without arguments shows you the list of added paths. To start your application simply type the class file's name.</p>
<p>For more info read the original forum <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/463">topic</a> from Ewout, read more about <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/88">shell commands</a> or have a look at the following example:</p>
<p><b>On your PC:</b><br/>
Install a Webserver (e.g. Apache) and start it up. Let's say it has 192.168.0.1 as its IP. Now create a HelloWorld.java, compile it and place the HelloWorld.class in a directory of your Webserver, for me that is <i>"/var/www/localhost/htdocs/jnode/"</i>.</p>
<p><b>Inside JNode:</b><br/>
Type the following lines inside JNode. You just have to replace IP addesses and network device by values matching your configuration.</p>
<p><i>ifconfig eth-pci(0,17,0) 192.168.0.6</i><br/>
<i>route add 192.168.0.1 eth-pci(0,17,0)</i><br/>
<i>classpath add http://192.168.0.1/jnode/</i></p>
<p>now that a new classpath is added you can run your HelloWorld App by simply typing</p>
<p><i>HelloWorld</i></p>
</div>
</div>
<div id="node-51" class="section-3">
<h1 class="book-heading">Performance</h1>
<p>Performance of an OS is critical. That's why many have suggested that an OS cannot be written in Java. JNode will not be the fastest OS around for quite some time, but it is and will be a proof that it can be done in Java. </p>
<p>Since release 0.1.6, the interpreter has been removed from JNode, so now all methods are compiled before being executed. Currently two new native code compilers are under development that will add various levels of optimizations to the current compiler. We expect these compilers to bring us much closer to the performance of Sun's J2SDK.</p>
<p>This page will keep track of performance of JNode, measured using various benchmarks, over time.<br/>
The performance tests are done on a Pentium4 2Ghz with 1GB of memory.</p>
<p><table cellspacing="0" cellpadding="3" width="100%">
<thead class="groupHeader">
<tr>
<td colspan="2">ArithOpt, org.jnode.test.ArithOpt</td>
<td colspan="2" align="right">Lower numbers are better.</td>
</tr>
<tr>
<td>Date</td>
<td>JNode Interpreted</td>
<td>JNode Compiled</td>
<td>Sun J2SDK</td>
</tr>
</thead>
<tr>
<td>12-jul-2003</td>
<td>1660ms</td>
<td>108ms</td>
<td>30ms</td>
</tr>
<tr>
<td>19-jul-2003</td>
<td>1639ms</td>
<td>105ms</td>
<td>30ms</td>
</tr>
<tr>
<td>17-dec-2003</td>
<td>771ms</td>
<td>63ms</td>
<td>30ms</td>
</tr>
<tr>
<td>20-feb-2004</td>
<td>n.a.</td>
<td>59ms</td>
<td>30ms</td>
</tr>
<tr>
<td>03-sep-2004</td>
<td>n.a.</td>
<td>27ms*</td>
<td>30ms</td>
</tr>
<tr>
<td>28-jul-2005</td>
<td>n.a.</td>
<td>20ms*</td>
<td>30ms**</td>
</tr>
<tr>
<td>&nbsp;</td>
</tr>
<thead class="groupHeader">
<tr>
<td colspan="2">Sieve, org.jnode.test.Sieve</td>
<td colspan="2" align="right">Higher numbers are better.</td>
</tr>
<tr>
<td>Date</td>
<td>JNode Interpreted</td>
<td>JNode Compiled</td>
<td>Sun J2SDK</td>
</tr>
</thead>
<tr>
<td>12-jul-2003</td>
<td>53</td>
<td>455</td>
<td>5800</td>
</tr>
<tr>
<td>19-jul-2003</td>
<td>55</td>
<td>745</td>
<td>5800</td>
</tr>
<tr>
<td>17-dec-2003</td>
<td>158</td>
<td>1993</td>
<td>5800</td>
</tr>
<tr>
<td>20-feb-2004</td>
<td>n.a.</td>
<td>2002</td>
<td>5800</td>
</tr>
<tr>
<td>03-sep-2004</td>
<td>n.a.</td>
<td>4320*</td>
<td>5800</td>
</tr>
<tr>
<td>28-jul-2005</td>
<td>n.a.</td>
<td>3660*</td>
<td>4252**</td>
</tr>
</table>
<p>
<p>
*)  Using L1A compiler<br/>
**) Using J2SDK 1.5.0 (others 1.4.2)</p>
</div>
<div id="node-50" class="section-3">
<h1 class="book-heading">Status</h1>
<p><b><i>JNode is now working on its second major release (0.3)</i></b>.</p>
<p>This second release will focus on stability, speed and memory usage. Further more it will add a real installer, provide isolates and many more.<br/>
In the mean time, we continue to release intermediate releases reflecting the state of development. Feel free to <a href="/web/20200119030613/http://www.jnode.org/taxonomy/page/or/2">download</a> them and enjoy using them.</p>
<p>Look <a href="/web/20200119030613/http://www.jnode.org/node/view/636">here</a> for the plans for this upcoming release.</p>
<p>We need <b>your</b> help to make it possible, so join us and help us realize the future of Operating Systems.<br/>
Look at the <a href="/web/20200119030613/http://www.jnode.org/node/455">contribute</a> page if you want to help us.</p>
<p>Bellow you will find various reports updated daily about the current state of the project:</p>
<ul>
<li><a href="/web/20200119030613/http://www.jnode.org/reports">Reports</a></li>
</ul>
<div id="node-52" class="section-4">
<h1 class="book-heading">Changelog</h1>
<p><b>Changes from JNode 0.2.8 to current SVN trunc version</b></p>
<ul>
</ul>
<div id="node-2880" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.7 to JNode 0.2.8</h1>
<pre>Features
========
progress with OpenJDK integration
class library updated to OpenJDK6 b13
JNode now builds  with both Java 6 SE and OpenJDK6+IcedTea
javac source level and target level raised to 1.6
introduced mauve based regression testing
improved isolate support
added isolate invoker
added Russian keyboard support
improved NTFS support
added HFS+ formatter
progress with Bjorne shell
improved modal dialogs
console &amp; shell improvements
a large number of bug fixes and improvements in the overall system
aiming better Java compatibility, stability and performance
real world applications starting to work: Jetty + recent Servlet/JSP examples, 
   PHP with Jetty + Quercus, JEdit, Groovy


Contributors to this release
============================
Levente Sntha
Fabien Duminy
Peter Barth
Martin Husted Hartvig
Stephen Crawley
Fabien Lesire
Daniel Noll
Tim Sparg
Stephen Meslin-Weber
Sergey Mashkov
Ben Bucksch
</pre></div>
<div id="node-2953" class="section-5">
<h1 class="book-heading">Incoming changes for the next release</h1>
<p>Features<br/>
============================</p>
<ul>
<li>added gzip/gunzip commands</li>
<li>added find, head and tail commands</li>
<li>integration of <a href="https://web.archive.org/web/20200119030613/http://jiic.berlios.de/">JIIC</a> as a pure java replacement of mkisofs</li>
</ul>
<p>Contributors to this release<br/>
============================</p>
<ul>
<li>name of the author of gzip/gunzip command (who is it ?)</li>
<li>bananenkasper</li>
<li>Tim Sparg</li>
<li>cluster</li>
<li>Wooden</li>
</ul>
<p>Special thanks to Jens Hatlak for integrating our patch to <a href="https://web.archive.org/web/20200119030613/http://jiic.berlios.de/">JIIC</a> (version named "a "JNode release")</p>
<p><i><u>Note to committers</u> : This topic will serve to build the changelogs for the next release (and avoid searching at release time).<br/>
Feel free to add the new features and their author (the patch submitter or, by default, you)</i></p>
</div>
<div id="node-2696" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.6 to JNode 0.2.7</h1>
<p>Features<br/>
========<br/>
Integrated the OpenJDK implementations of Swing and AWT<br/>
Improved java.awt.Graphics and Graphics2D<br/>
Improved BDF font rendering<br/>
Added VESA based frame buffer support<br/>
Added a frame buffer based console with custom backgrounds<br/>
Implemented software cursor support<br/>
Added a JPEG decoder<br/>
Various ImageIO improvements<br/>
Added a Samba file system (rw) and support for smb:// and nfs:// URLs<br/>
Replaced argument syntax and completion framework for shell commands<br/>
Converted existing commands to the new syntax framework<br/>
Added a configure tool for the JNode build environment<br/>
Various bugfixes to networking, memory management, math support, FAT support, and the core VM.</p>
<p>
Contributors to this release<br/>
============================<br/>
Levente Santha<br/>
Fabien Duminy<br/>
Peter Barth<br/>
Martin Husted Hartvig<br/>
Stephen Crawley<br/>
Fabien Lesire<br/>
Chris Boertien<br/>
Brett Lawrence<br/>
Daniel Noll<br/>
Jacob Kofod<br/>
Ian Darwin<br/>
Helmut Dersch<br/>
Stephen Meslin-Weber</p>
</div>
<div id="node-2402" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.5 to JNode 0.2.6</h1>
<p>Features<br/>
========</p>
<p>More progress with OpenJDK integration<br/>
Wildcards support in shell<br/>
NTFS improvements<br/>
NFS2 read write support<br/>
Command shell improvements<br/>
Improved support for pipes and command completion<br/>
Experimental Bjorne shell implementation<br/>
Added support for JDBC drivers<br/>
Fixed object serialization<br/>
Support for prefrences API<br/>
Improved support for native methods<br/>
Code hotswapping support<br/>
Fixed DNS support<br/>
Included Jetty6, Servlet and JSP support<br/>
Read-only HFS+ file system<br/>
File System API refactoring &amp; improvements<br/>
Experimental telnet server<br/>
Added CharvaCommander<br/>
Improved BDF font rendering</p>
<p>Contributors to this release<br/>
============================</p>
<p>Levente Santha<br/>
Martin Husted Hartvig<br/>
Fabien Duminy<br/>
Fabien Lesire<br/>
Stephen Crawley<br/>
Daniel Noll<br/>
Andrei Dore<br/>
Ian Darwin<br/>
Peter Barth<br/>
Robert Murphey<br/>
Michael Klaus<br/>
Tanmoy Deb<br/>
GriffenJBS (jstephen)</p>
</div>
<div id="node-1750" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.4 to JNode 0.2.5</h1>
<p>Features<br/>
========</p>
<p>Openjdk integration, roughly 80% completed<br/>
Included standard javac and javap from openjdk<br/>
Targetting Java 6 compatibility<br/>
Build process migrated to Java 6<br/>
netcat command<br/>
Improved Image I/O support<br/>
Improved build process (parallel build using fork)<br/>
Included BeanShell and Rhino (JavaScript) as scripting languages<br/>
(encouraging results with Jython, Kawa (Scheme), JRuby 1.0 and Scala)<br/>
Improved Eclipse support<br/>
Nanosecond accurate timer<br/>
Started JNode installer (grub support)<br/>
Improvements in text consoles<br/>
Experimental via-rhine NIC driver<br/>
PXE booting support for via-rhine<br/>
ANT is getting usable<br/>
Improved support for mauve based tests<br/>
A mechanism for supporting the native keyword for arbitrary applications<br/>
Experimental support for isolates (static data isolation, access to fs/net/gui from isolates)<br/>
Various gc and memory management related improvements<br/>
Improvements to jfat and ext2 filesystems<br/>
Promising experiments with JPC running under JNode and running FreeDOS on the JPC/JNode stack<br/>
Support for transparency in the GUI<br/>
Many improvement to command execution and input/output streams of commands<br/>
Introduced 'proclets' - small programs running in the same isolate with their own in/out/err streams<br/>
Proper command line editing and input line history for third party command line based programs (like bsh, rhino)</p>
<p>Contributors<br/>
============</p>
<p>Andrei Dore<br/>
Daniel Noll<br/>
Fabien Lesire<br/>
Fabien Duminy<br/>
Giuseppe Vitillaro<br/>
Levente Sntha<br/>
Michael Klaus<br/>
Martin Husted Hartvig<br/>
Peter Barth<br/>
Stephen Crawley<br/>
Tanmoy Deb</p>
</div>
<div id="node-891" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.3 to JNode 0.2.4</h1>
<p><b>Changes from JNode 0.2.3 to JNode 0.2.4</b></p>
<ul>
<li>JFat - a FAT32 file system implementation</li>
<li>RamFS - a simple in-memory file system</li>
<li>FTPFS - a read-only FTP based file system</li>
<li>javac command, included with the use of Eclipse JDT compiler</li>
<li>Integrated standard java tools: jar, native2ascii, serialver etc. from GNU Classpath</li>
<li>Text console improvements</li>
<li>Swing based console</li>
<li>New textconsole based editor</li>
<li>Many classpath patches</li>
<li>ImageIO support for PNG, GIF and BMP images from GNU Classpath</li>
<li>BDF font support</li>
<li>Changable desktop Look &amp; Feel</li>
<li>Isolate (JSR 121), not fully supported</li>
<li>Simple webserver under JNode</li>
<li>Various bugfixes in the resource loading, ISO9660, socket writing</li>
<li>Basic support for development under JNode</li>
</ul>
</div>
<div id="node-792" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.2 to JNode 0.2.3</h1>
<p><b>Changes from JNode 0.2.2 to JNode 0.2.3</b></p>
<ul>
<li>Many classpath patches</li>
<li>Improvements in AWT, Swing and desktop support</li>
<li>Various bugfixes in the JIT compiler, ISO9660 support, JIFS</li>
<li>Better support for testing JNode with Mauve (mauve plugins, invoker commands)</li>
</ul>
</div>
<div id="node-766" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.1 to JNode 0.2.2</h1>
<p><b>Changes from JNode 0.2.1 to JNode 0.2.2</b></p>
<ul>
<li>Added annotation support</li>
<li>Implemented much improved font renderer (can be enabled by setting the jnode.font.renderer property to "new"</li>
<li>Various performance improvements of native code compiler (invoke of final methods, optimized tableswitch)</li>
<li>Massive classpath improvements</li>
<li>Major GUI improvements</li>
</ul>
</div>
<div id="node-704" class="section-5">
<h1 class="book-heading">Changes from JNode 0.2.0 to JNode 0.2.1</h1>
<p><b>Changes from JNode 0.2.0 to JNode 0.2.1</b></p>
<ul>
<li>Implemented field alignments to minimize object size</li>
<li>Added fragmented plugin support</li>
<li>Added include support for plugin-list files</li>
<li>Many improvements on the gui</li>
<li>Fixed OpenMP detection bug</li>
<li>Many Classpath patches</li>
<li>Many memory usage improvements</li>
<li>Updated java.io to use NIO classes</li>
</ul>
</div>
<div id="node-643" class="section-5">
<h1 class="book-heading">Changes from JNode 0.1.10 to JNode 0.2.0</h1>
<p><b>Changes from JNode 0.1.10 to JNode 0.2.0</b></p>
<ul>
<li>Change J2SDK requirement to 5.0</li>
<li>Added support for most of the 5.0 language features (except annotations)</li>
<li>Added automatic creation of java.io.tmpdir</li>
<li>Many classpath patches</li>
<li>Automatic mounting of the jifs (information) filesystem</li>
<li>Added kill command</li>
<li>Sending output from shell commands to file</li>
<li>Piping between shell commands</li>
<li>Kill job/command when pressing ctrl+c in the shell</li>
</ul>
</div>
<div id="node-647" class="section-5">
<h1 class="book-heading">Old changelogs</h1>
<p>You'll find the changelogs for old releases below.</p>
<div id="node-554" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.9 to JNode 0.1.10</h1>
<p><b>Changes from JNode 0.1.9 to JNode 0.1.10</b></p>
<ul>
<li>Ported to AMD64</li>
<li>Improved ACPI structure</li>
<li>Improved BIOS structure</li>
<li>Renamed jnodesys.gz bootable image to jnode32.gz / jnode64.gz</li>
<li>Added classpath command</li>
<li>Added onheap command</li>
<li>Added JIFS JNode information filesystem</li>
<li>Lots of GNU Classpath patches</li>
<li>Addition of kernel debugger</li>
<li>Change in method calling approach (improves performance)</li>
</ul>
</div>
<div id="node-409" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.8 to JNode 0.1.9</h1>
<p><b>Changes from JNode 0.1.8 to JNode 0.1.9</b></p>
<ul>
<li>Major GUI improvements</li>
<li>AWT &amp; Swing now work for a large part</li>
<li>Improve ATI radeon driver</li>
<li>Lots of classpath updates</li>
</ul>
</div>
<div id="node-364" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.7  to JNode 0.1.8</h1>
<p><b>Changes from JNode 0.1.7 to JNode 0.1.8</b></p>
<ul>
<li>Added L1A baseline compiler with register allocation</li>
<li>Fixed build system for build with J2SDK 5.0</li>
<li>Major performance improvements</li>
<li>Detection of multi-processor systems</li>
<li>Lots of updates of Classpath</li>
<li>Lots of bugs fixes</li>
</ul>
</div>
<div id="node-265" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.6 to JNode 0.1.7</h1>
<p><b>Changes from JNode 0.1.6 to JNode 0.1.7</b></p>
<ul>
<li>Added Code security using Java Security architecture implementation.</li>
<li>Completed Lance network driver for VMWare 4</li>
<li>Improved IDE support</li>
<li>Improved PS2Mouse driver</li>
<li>Added runtime load/unload/reloading of plugins</li>
<li>Added runtime load/unload/reloading of device</li>
<li>Added ATI Radeon driver</li>
<li>Added Ext2 R/W support</li>
<li>Added Ext2 Format support</li>
<li>Added NT bootloader support using NT-GRUB</li>
<li>Many Classpath updates</li>
<li>Added reboot support</li>
<li>Added ATAPI driver</li>
<li>Added ATAPI-SCSI bridge driver</li>
<li>Added SCSI CDROM driver</li>
<li>Added ISO9660 filesystem</li>
<li>Improved KeyboardInterpreter framework</li>
<li>Added various keyboard interpreters</li>
<li>Lots of bugfixes</li>
</ul>
</div>
<div id="node-122" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.5 to JNode 0.1.6</h1>
<p><b>Changes from JNode 0.1.5 to JNode 0.1.6</b></p>
<ul>
<li>Added CHARVA based application support. Charva is now fully supported. Try charva.awt.Tutorial for an example </li>
<li>Added workmanager for asynchronous execution of small pieces of work</li>
<li>Added device startup timeout detection</li>
<li>Implemented method inlining</li>
<li>Removed interpreter, all code is now compiled before being executed</li>
<li>Improved the garbage collection, it is now triggered after 75% of the free memory has been allocated</li>
<li>finalization now works according to the specification</li>
<li>Moved build to Ant 1.6.0</li>
<li>Addition of initial jar support</li>
<li>Addition of read-only NTFS filesystem driver</li>
<li>Update the console management to work with named consoles instead of indexed consoles.</li>
<li>New shell command available to manage consoles.The command has the alias "console"</li>
</ul>
</div>
<div id="node-56" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.4 to JNode 0.1.5</h1>
<ul>
<li>Added DNS client</li>
<li>Added read-only ext2 filesystem</li>
<li>Added initial GUI widget toolkit</li>
<li>Improved VM performance for interpreted &amp; compiled code</li>
<li>Extended DeviceToDriverMapper interface to support "best match" drivers</li>
<li>Changed scheduling to yieldpoint scheduling</li>
<li>Added thread command</li>
<li>Added memory command</li>
<li>Added class command</li>
<li>Addition of Ramdisk</li>
<li>Addition of RTL8139 network driver</li>
<li>Addition of USB keyboard driver</li>
<li>Addition of USB HUB driver</li>
<li>Addition of USB mouse driver</li>
<li>Addition of USB framework</li>
<li>Addition of TCP over IPv4 layer</li>
<li>Addition of LOG4J support, debug logging into second console</li>
</ul>
</div>
<div id="node-55" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.3 to JNode 0.1.4</h1>
<ul>
<li>Addition hardware mouse support</li>
<li>Various bug fixes</li>
<li>Addition of logging via UDP connection</li>
<li>Addition of FDISK command</li>
<li>Addition of ACPI driver</li>
<li>Addition netboot target in Grub menu</li>
<li>Addition of DDC1 (monitor data) read-out</li>
<li>Addition of NVidia driver</li>
<li>Wheelmouse scrolls text-console</li>
<li>Addition Mouse driver</li>
<li>Improved build performance</li>
<li>Various graphics enhancements</li>
<li>Addition TrueType Font provider</li>
<li>Addition Font Manager</li>
</ul>
</div>
<div id="node-54" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.2 to JNode 0.1.3</h1>
<ul>
<li>Addition of a common help system for shell commands</li>
<li>Addition of Command Line Completion</li>
<li>Addition of Shell history</li>
<li>Addition of VMWare SVGA driver</li>
<li>Addition of VGA driver</li>
<li>Addition of initial FrameBufferAPI</li>
<li>Replaced synchronization implementation by thin-locks. It is now much faster!</li>
<li>Replaced RTC.getTime implementation. It now only creates one calendar for each thread instead of each invocation</li>
<li>Addition of compile command, to force the compilation of a given class</li>
<li>Addition of plugin command, to list all known plug-ins</li>
<li>Replaced invokeinterface implementation by IMT based implementation</li>
<li>Addition of Interface Method Table (IMT), a selector indexed array with support for index collisions</li>
<li>Replaced instanceof and checkcast implementation. The new implementation used a superclasses array found in the TIB</li>
<li>Replaced Virtual Method Table (VMT) by Type Information Block (TIB), an extended version of the old VMT</li>
<li>Replaced NetworkLayerManager.(un)registerLayer functions with extension-point</li>
<li>Replaced DeviceManager.(un)registerMapper functions with extension-point</li>
<li>Addition of plug-in architecture</li>
<li>Replaced Shell Command interface with an alias mechanism and static void main(String[]) methods</li>
<li>JNode has been verified to build using J2SDK 1.4.2</li>
</li>
</ul>
</div>
<div id="node-53" class="section-6">
<h1 class="book-heading">Changes from JNode 0.1.1 to JNode 0.1.2</h1>
<ul>
<li>JNode can now be build using J2SDK 1.4.2 (beta)</li>
<li>Addition of kernel parameters in systemproperty <i>jnode.cmdline</i></li>
<li>Addition of line numbers in stacktrace for compiled methods</li>
<li>Addition of floppy driver</li>
<li>Addition of device command</li>
<li>Addition of bootp command</li>
<li>Addition of help command</li>
<li>Addition of halt command</li>
<li>Addition of netstat command</li>
<li>Addition of route command</li>
<li>Addition of arp command</li>
<li>Addition of ifconfig command</li>
<li>Addition of BOOTP over IPv4 client</li>
<li>Addition of UDP over IPv4 layer</li>
<li>Addition of ICMP over IPv4 layer</li>
<li>Addition of IPv4 layer</li>
<li>Addition of ARP layer</li>
<li>Addition of 3c90x driver</li>
<li>Addition of RealTek 8029 driver</li>
<li>Addition of network framework</li>
</ul>
</div>
</div>
</div>
<div id="node-623" class="section-4">
<h1 class="book-heading">J2SDK 5.0 feature support</h1>
<p>This page gives an overview of the support for J2SDK 5.0 features.<br/>
It reflects the status of the SVN trunk.</p>
<table>
<tr>
<th>Feature</th>
<th>Status</th>
<th>Can be used</th>
</tr>
<tr>
<td>Generics</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Generics in collection framework</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Enhanced for loop</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Autoboxing/unboxing</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Typesafe enums</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Varargs</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Static import</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Metadata (annotations)</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
<tr>
<td>Covariant return types</td>
<td>Supported</td>
<td><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></td>
</tr>
</table>
</div>
</div>
</div>
<div id="node-13800" class="section-2">
<h1 class="book-heading">Classlib developers guide</h1>
<p>Look at <a href="https://web.archive.org/web/20200119030613/https://github.com/jnode-integration/classlib6/wiki">GitHub wiki</a></p>
</div>
<div id="node-3" class="section-2">
<h1 class="book-heading">Developer guide</h1>
<p>This part contains all technical documentation about JNode. This part is intended for JNode developers.</p>
<div id="node-175" class="section-3">
<h1 class="book-heading">Introduction</h1>
<p>This chapter is a small introduction to the technical documentation of JNode.<br/>
It covers the basic parts of JNode and refers to their specific documentation.</p>
<p>JNode is a Virtual Machine <b>and</b> an Operating System in a single package. This implies that the technical documentation covers both the <a href="/web/20200119030613/http://www.jnode.org/book/view/29">Virtual Machine</a> side and the <a href="/web/20200119030613/http://www.jnode.org/book/view/38">Operating System</a> side.<br/>
<br><br/>
Besides these two, there is one aspect to JNode that is shared by the Virtual Machine and the Operating System. This aspect is the <a href="/web/20200119030613/http://www.jnode.org/book/view/105">PluginManager</a>. Since every module in JNode is a Plugin, the PluginManager is a central component responsible for plugin lifecycle support, plugin permissions and plugin loading, unloading &amp; reloading.</p>
<p>The picture below gives an overview of JNode and its various components.<br/>
<img src="/web/20200119030613im_/http://www.jnode.org/images/architecture.png" title="An overview of JNode&amp;#039;s architecture" alt="An overview of JNode&amp;#039;s architecture"/></p>
<p>It also states which parts of JNode are written in Java (green) and which part are written in native assembler (red).</p>
<p>As can be seen in the picture above, many parts of the class library are implemented using services provided by the JNode Operating System. These services include filesystems, networking, gui and many more.</p>
</div>
<div id="node-2976" class="section-3">
<h1 class="book-heading">Getting the sources</h1>
<p>For developing JNode you first need to get the sources. There are basically 3 possible ways to get them with different advantages and disadvantages. These possibilities contain:</p>
<ul>
<li>Getting the sources from our nightly build server. You can find a tar.bzip2 file from <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/releases/nightly-builds/">here</a>. This is the fastest way to get the sources, but you should not use it for development as it makes it hard to update your local sources once modified.
<li>The second possibility is to use SVN, which is our main repository. SVN is easy to use but is a bit slow on the one hand and on the other hand you need access permissions to commit. For getting access permission one has to proove he's able to follow the JNode guidelines.
<li>For new developers the recommended way is to use git. We have a git repository that is kept in sync and makes it easy to create patches against trunk.
</ul>
<p>Have a look at the subpages for a more detailed description of the commands.</p>
<div id="node-850" class="section-4">
<h1 class="book-heading">SVN Usage (Deprecated : we have moved to GitHub)</h1>
<p><b>This page is deprecated since we have moved to <a href="https://web.archive.org/web/20200119030613/https://github.com/jnode">GitHub</a></b></p>
<p>This is a slight overview of SVN and how to use it. First of all there are three ways to access SVN: svn, svn+ssh and via https. Sourceforge uses WebDAV, that means you can also browse the repository online with your favorite browser, just click on <a href="https://web.archive.org/web/20200119030613/https://jnode.svn.sourceforge.net/svnroot/jnode/">this link</a>.</p>
<p>Subversion uses three toplevel directories named trunk, branches and tags. Trunk can be compared to CVS Head, branches and tags are self-explanatory, I think <img src="/web/20200119030613im_/http://www.jnode.org/modules/smileys/packs/example/smile.png" title="Smiling" alt="Smiling"/></p>
<p>To checkout the source simply type:<br/>
<b>svn  co  <a href="https://web.archive.org/web/20200119030613/https://jnode.svn.sourceforge.net/svnroot/jnode/trunk/" title="https://jnode.svn.sourceforge.net/svnroot/jnode/trunk/">https://jnode.svn.sourceforge.net/svnroot/jnode/trunk/</a>  jnode</b><br/>
which creates a new directory called jnode (Mind the space between "trunk/" and "jnode"!) . In this directory all stuff of the repository in /jnode/trunk will be copied to jnode/ on your local computer.</p>
<p><b>svn up|add|commit</b> as expected.</p>
<p>New to subversion is copy, move and delete. If you copy or move a file, the history is also copied or moved, if you e.g. delete a directory it will not show up anymore if you do a new checkout.</p>
<p>If you want to make a branch from a version currently in trunk you can simply copy the content from trunk/ to branches/, e.g. by:<br/>
<i>svn copy <a href="https://web.archive.org/web/20200119030613/https://jnode.svn.sourceforge.net/svnroot/jnode/trunk/" title="https://jnode.svn.sourceforge.net/svnroot/jnode/trunk/">https://jnode.svn.sourceforge.net/svnroot/jnode/trunk/</a> https://jnode.svn.sourceforge.net/svnroot/jnode/branches/my-big-change-branch/</i></p>
<p>I think that's the most important for the moment, for more information have a look at the SVN Handbook located <a href="https://web.archive.org/web/20200119030613/http://svnbook.red-bean.com/">here</a>.</p>
<p>Btw, for using SVN within eclipse you have to install subclipse located <a href="https://web.archive.org/web/20200119030613/http://subclipse.tigris.org/">here</a>.</p>
<div class="forum-topic-navigation clear-block"><a href="/web/20200119030613/http://www.jnode.org/node/370" class="topic-previous" title="Go to previous forum topic"> ATI developer needed</a></div></div>
<div id="node-2974" class="section-4">
<h1 class="book-heading">Using Git (at GitHub)</h1>
<p>The URLs for official git repository at GitHub are listed below :</p>
<pre>Site: <a href="https://web.archive.org/web/20200119030613/https://github.com/jnode/jnode" title="https://github.com/jnode/jnode">https://github.com/jnode/jnode</a>
Https: <a href="https://web.archive.org/web/20200119030613/https://github.com/jnode/jnode.git" title="https://github.com/jnode/jnode.git">https://github.com/jnode/jnode.git</a>
SSH: <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="97f0fee3d7f0fee3ffe2f5b9f4f8fa">[email&#160;protected]</a>:jnode/jnode.git
</pre><p>
For those who know what they are doing already and simply want push access, refer to the page on setting up push access. For those that are unfamiliar with git, there are a few git pages below that explain some of the common tasks of setting up and using git. This of course is not meant to be a replacement for the git manual.</p>
<pre>Git Manual: <a href="https://web.archive.org/web/20200119030613/https://www.kernel.org/pub/software/scm/git/docs/user-manual.html" title="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html">http://www.kernel.org/pub/software/scm/git/docs/user-manual.html</a>
Git Crash Course for SVN users: <a href="https://web.archive.org/web/20200119030613/http://git.or.cz/course/svn.html" title="http://git.or.cz/course/svn.html">http://git.or.cz/course/svn.html</a>
</pre><div id="node-2975" class="section-5">
<h1 class="book-heading">Setting up push access</h1>
<p>In order to gain push access to the repository you will have to create a username on the hosting site and upload a public ssh key. Have the key ready as it will as for it when you sign up. If you have a key already you can register your username <a href="https://web.archive.org/web/20200119030613/http://repo.or.cz/m/reguser.cgi">here</a> and give your username, email and public key. There's no password involved with the account, the only password is the one you put on your ssh key when you create it, if you choose to do so. Its not like there is sensitive material involved, so dont feel compelled to use a password.</p>
<p>In order to generate an ssh key will require ssh be installed. Most linux distributions will have this already. Simply type in:</p>
<pre>ssh-keygen
</pre><p>and your key will be generated. Your public key will be in ~/.ssh/ in a file with a .pub suffix, likely id_rsa.pub or id_dsa.pub. Open the file in a text editor (turn off line wrapping if its enabled), and copy/paste the key into your browser. Its important that the line not be broken over multiple lines.</p>
<p>Once your account has been created, send an email to the address found by the Owner tag on the jnode repo website, which is <a>here</a>. Once you are added you will need to configure your git configuration to use the new push url with your username.</p>
<p>When you originally cloned the repository the configuration setup a remote named origin that referenced the public repo using the anonymous pull url. We'll now change that using git-config.</p>
<pre>git config remote.origin.url <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="91f6f8e5d1f6f8e5f9e4f3bff2fefc">[email&#160;protected]</a>:[user]/jnode.git
</pre><p>Of course replacing [user] with your username, which is case sensitive.</p>
<p>Now you should be setup. Please see the page on push rules and etiquette before continuing.</p>
</div>
<div id="node-2977" class="section-5">
<h1 class="book-heading">Setting up your local git repo</h1>
<p>The first thing you want to do, obviously, is install git if its not already. Once git is intalled we need to clone the public repository to your local system. At this time of this writing this requires about a 130MB download.</p>
<p>First, position your current directory in the location where you want your working directory to be created. Don't create the working directory as git will refuse to init inside an existing directory. For this example we will clone to a jnode directory in ~/git/.</p>
<pre>cd ~/git
git clone <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="60070914200709140815024e030f0d">[email&#160;protected]</a>:jnode/jnode.git jnode
</pre><p>Once this has finished you will have a freshly created working directory in ~/git/jnode and the git repository itself will be located in ~/git/jnode/.git For more info see <a href="https://web.archive.org/web/20200119030613/https://www.kernel.org/pub/software/scm/git/docs/user-manual.html#repositories-and-branches">Git Manual Chapter 1: Repositories and Branches</a></p>
<p>This process has also setup what git refers to as a remote. The default remote after cloning is labeled as origin and it refers to the public repository. In order to keep your repository up to date with origin, you will have to fetch them. See <a href="https://web.archive.org/web/20200119030613/https://www.kernel.org/pub/software/scm/git/docs/user-manual.html#Updating-a-repository-With-git-fetch">Updating with git-fetch</a> for more info.</p>
<p>When fetch pulls in new objects, you may want to update any branches you have locally that are tracking branches on origin. This will almost always be true of the master branch, as it is highly recommended that you keep your master branch 'clean' and in sync with origin/master. It's not necessary, but it may make life easier until you understand git more fully. To update your master branch to that of origin/master simply</p>
<pre>git rebase origin master
</pre><p>Then if you wish to rebase your local topic branches you can</p>
<pre>git rebase master [branch]
</pre><p>The reason we're using git rebase instead of git merge is because we do not generally want merge commits to be created. This is partly to do with the svn repo that commits will eventually be pulled into. svn does not handle git merges properly, as a git merge object has multiple parent commits, and svn has no concept of parents. Where git employs a tree structure for its commits, svn is more like a linked list, and is therefore strictly linear. This is why its also important to fetch and rebase often, as it will make the transition of moving branches over to the svn repo much easier.</p>
<p>To learn more about branches refer to the git manual. It is highly recommended that new users to git read through chapters 1-4, as this explains alot of how git operates, and you will likely want to keep it bookmarked for quick referencing until you get a handle on things.</p>
<p>For those users that find the git command line a bit much, there is also `git gui` that is a very nice tool. It allows you to do alot of the tasks you would do on the command line via gui. There is also an eclipse plugin that is under development called egit, part of the jgit project implementing a pure java git implementation.</p>
</div>
<div id="node-2978" class="section-5">
<h1 class="book-heading">Git Etiquette</h1>
<p>Once you have push access to the public git repo, there are a few simple rules i'd like everyone to observe.</p>
<p>1) Do not push to origin/master<br/>
This branch is to be kept in sync with the svn repo. This branch is updated hourly. When it is updated, any changes made to it will be lost anyway as the udpate script is setup in overwrite mode. Even with this, if someone goes to fetch changes from origin/master before the update script has had a chance to bring it back in sync, then those people will have an out of sync master, which is a pain for them. To be on the safe side, when pulling from origin master, it doesnt hurt to do a quick 'git log origin/master' before fetching to see if the commit messages have a git-svn-id: in the message. This is embedded by git for commits from svn. If the top commits do not have this tag, then someone has pushed into origin/master.</p>
<p>2) Do not push into branches unless you know whats going on with it.<br/>
If you have a branch created on your local repo and you would like to have your changes pulled upstream then push your branch to the repo and ask for it to be pulled. You can push your branch to the public repo by</p>
<pre>git push origin [branch]
</pre><p>so long as a branch by that name does not already exist. Once the changes have been pulled the branch will be removed from the public repo. That is unless the branch is part of some further development. You will still have your branch on your local repo to keep around or delete at your leisure.</p>
<p>3) Sign-off on your work.<br/>
Although git preserves the author on its commits, svn overwrites this information when it is commited. Also it is your waying of saying that this code is yours, or that you have been given permission to submit it to the project under the license of the project. <b>Commits will not be pulled upstream without a sign-off</b>. The easiest way to set this up is to configure git with two variables.</p>
<pre>git config user.name [name]
git config user.email [email]
</pre><p>Then when you go to make your commit, add an -s flag to git commit and it will automatically append a Signed-off-by: line to the commit message. This is not currently being enforced project wide, although it should be. Also if someone sends you a patch, you can add a Created-by: tag for that person, along with your own sign-off tag.</p>
</div>
</div>
</div>
<div id="node-2682" class="section-3">
<h1 class="book-heading">Configuration process</h1>
<p>JNode has a number of configuration options that can be adjusted prior to performing a build.  This section describes those options, the process of configuring those options, and the tools that support the process.</p>
<p>JNode is currently configured by copying the "jnode.properties.dist" file to "jnode.properties" and editing this and other configuration files using a text editor.</p>
<p>In the future, we will be moving to a new command-line tool that interactively captures configuration settings, and creates or updates the various configuration files.</p>
<div id="node-2685" class="section-4">
<h1 class="book-heading">The Configure tool</h1>
<p>The Configure tool is a Java application that is designed to be run in the build environment to capture and record JNode's build-time configuration settings.  The first generation of this tool is a simple command-line application that asks the user questions according to an XML "script" file and captures and checks the responses, and records them in property files and other kinds of file.</p>
<p>The Configuration tool supports the following features:</p>
<ul>
<li>Property types are specified in terms of regexes or value enumerations.
<li>Properties are specified in terms of a property name and type, with an optional default value.
<li>Property sets are collections of properties associated with files:
<ul>
<li>They are typically loaded from the file, updated by the tool and written back to the file.
<li>Properties can be expanded into templates XML and Java source files as well as classic Java properties files.
<li>A "FileAdapter" API allows new file formats to be added as plugin classes.
</ul>
<li>Property values are captured in "screens" consists of a sequence of "items" which define the questions that are presented to the user.
<ul>
<li>Each "item" consists of a property name and a multi-line "text" that explains the property to the user.
<li>A screen can be made conditional, with a "guard" property that determines whether or not the properties in the screen are captured.
</ul>
<li>A configuration script file can "import" other script files, allowing the configuration process to modularised.  All relative pathnames in scripts are resolved relative to the script file that specifies them.
</ul>
<p>The configuration tool is launched using the "configure.sh" script:</p>
<pre>   $ ./configure.sh
</pre><p>When run with no command arguments as above, the script launches the tool using the configuration script at "all/conf-source/script.xml".  The full command-line syntax is as follows:</p>
<pre>   ./configure.sh
   ./configure.sh --help
   ./configure.sh [--verbose] [--debug] &lt;script-file&gt;
</pre><p>The command creates and/or updates various configuration files, depending on what the script says.  Before a file is updated, a backup copy is created by renaming the existing file with a ".bak" suffix.</p>
</div>
<div id="node-2686" class="section-4">
<h1 class="book-heading">Configuration script files</h1>
<p>The Configure tool uses a "script" to tell it what configuration options to capture, how to capture them and where to put them.  Here is a simple example illustrating the basic structure of a script file:</p>
<pre>&lt;configureScript&gt;
  &lt;type name="integer.type" pattern="[0-9]+"/&gt;
  &lt;type name="yesno.type"&gt;
    &lt;alt value="yes"/&gt;
    &lt;alt value="no"/&gt;
  &lt;/type&gt;

  &lt;propFile name="test.properties"&gt;
    &lt;property name="prop1" type="integer.type"
              description="Enter an integer"
              default="0"/&gt;
    &lt;property name="prop2" type="yesno.type"
              description="Do you want to?"
              default="no"/&gt;
  &lt;/propFile&gt;

  &lt;screen title="Testing set 1"&gt;
    &lt;item property="prop1"/&gt;
    &lt;item property="prop2"/&gt;
  &lt;/screen&gt;
&lt;/configureScript&gt;
</pre><p>The main elements of a script are "types", "property sets" and "screens".  Lets describe these in that order.</p>
<p>A "type" element introduces a property type which defines a set of allowed values for properties specified later in the script file.  A property type's value set can be defined using a regular expression (pattern) or by listing the value set.  For more details refer to the <a href="/web/20200119030613/http://www.jnode.org/node/2687">"Specifying property types"</a> page.</p>
<p>A "propFile" element introduces a property set consisting of the properties to be written to a given property file.  Each property in the property set is specified in terms of a property name and a previously defined type, together with a (one line) description and an optional default value.  For more details refer to the <a href="/web/20200119030613/http://www.jnode.org/node/2688">"Specifying property files"</a> page.</p>
<p>A "screen" element defines the dialog sequence that is used to request configuration properties from the user.  The screen consists of a list of properties, together with (multi-line) explanations to be displayed to the user.  For more details refer to the <a href="/web/20200119030613/http://www.jnode.org/node/2689">"Specifying property screens"</a> page.</p>
<p>Finally, the <a href="/web/20200119030613/http://www.jnode.org/node/2690">"Advanced features"</a> page describes the control properties and the import mechanism.</p>
<div id="node-2687" class="section-5">
<h1 class="book-heading">Specifying property types</h1>
<p>Configuration property types define sets of allowable values that can be used in values defined elsewhere in a script file.  A property type can be defined either using a regular expression or by listing the set of allowable values.  For example:</p>
<pre>  &lt;type name="integer.type" pattern="[0-9]+"/&gt;
  &lt;type name="yesno.type"&gt;
    &lt;alt value="yes"/&gt;
    &lt;alt value="no"/&gt;
  &lt;/type&gt;
</pre><p>The first "type" element defines a type whose values are unsigned integer literals.  The second one defines a type that can take the value "yes" or "no".  </p>
<p>In both cases, the value sets are modeled in terms of the "token" character sequences that are entered by the user and the "value" character sequences that are written to the property files.  For a property types specified using regular expressions, the "token" and "value" sequences are the same, with one exception.  The exception is that a sequence of zero characters is not a valid input token.  So if the "pattern" could match an empty token, you must define an "emptyToken" that the user will use to enter this value.  For example, the following defines a variant of the previous "integer.type" in which the token "none" is used to specify that the corresponding property should have an empty value:</p>
<pre>  &lt;type name="optinteger.type" 
        pattern="[0-9]*" emptyToken="none"/&gt;
</pre><p>
For property types specified by listing the values, you can make the tokens and values different for any pair.  For example:</p>
<pre>  &lt;type name="yesno.type"&gt;
    &lt;alt token="oui" value="yes"/&gt;
    &lt;alt token="non" value="no"/&gt;
  &lt;/type&gt;
</pre><p>
Type values and tokens can contain just about any printable character (modulo the issue of zero length tokens).  Type names however are restricted to ASCII letters, digits, '.', '-' and '_'.</p>
</div>
<div id="node-2688" class="section-5">
<h1 class="book-heading">Specifying property files</h1>
<p>A "propFile" element in a script file specifies details about a  file to which configuration properties will be written.  In the simplest case, a "propFile" element specifies a file name and a set of properties to be written.  For example:</p>
<pre>  &lt;propFile fileName="jnode.properties"&gt;
    &lt;property name="jnode.vm.size"
                 type="integer.type"
                 description="Enter VM size in Mbytes"
                 default="512"/&gt;
    &lt;property name="jnode.vdisk.enabled" type="yesNo.type"
              description="Configure a virtual disk"
              default="no"/&gt;
  &lt;/propFile&lt;
</pre><p>This specifies a classic Java properties file called "jnode.properties" which will contain two properties.  The "jnode.vm.size" property will have a value that matches the type named "integer.type", with a default value of "512".  The "jnode.vdisk.enabled" will have a value that matches the "yesno.type", defaulting to "no".</p>
<p>The Configure tool will act as follows for the example above.</p>
<ol>
<li>It will test to see if the "jnode.properties" file exists in the same directory as the script file.
<li>If the file exists, it will be read using the java.util.Properties.load method, and the in-memory property set will be populated from the corresponding properties.
<li>If the property file does not exist, the in-memory property set will be populated from the "default" attributes.
<li>The "screen" elements will be processed as described in the "" page to capture new property values.
<li>Finally, the "jnode.properties" file will be created or updated using the java.util.Properties.save method.
</ol>
<p><u>Attributes of a "property" element</u><br/>
Each "property" element can have the following attributes:</p>
<dl>
<dt>name</dt>
<dd>This attribute gives the name of the property.  Property names should be restricted to ASCII letters, digits, '-', '-' and '_'.  This attribute is mandatory.</dd>
<dt>type</dt>
<dd>This attribute gives the name of the property's type.  This attribute is mandatory.</dd>
<dt>description</dt>
<dd>This attribute gives a short (20 chars or so) description of the property that will be included in the prompt for the property's value.  This attribute is mandatory.</dd>
<dt>default</dt>
<dd>This attribute gives a default value for the property if none is supplied by other mechanisms.  This attribute is optional, but if present it must contain a valid value for the property's type.</dd>
</dl>
<p><u>Attributes of a "propFile" element</u><br/>
The Configure tool will read and write properties in different ways depending on the "propFile" element's attributes:</p>
<dl>
<dt>fileName</dt>
<dd>This attribute specifies the name of the file to be written.  Depending on the other attributes, it may also be a source of default values.  This attribute is mandatory.</dd>
<dt>fileFormat</dt>
<dd>This attribute specifies various alternative file formats.  Possible values are listed below.</dd>
<dt>defaultFile</dt>
<dd>This attribute specifies that default property values should be loaded from a default property file.</dd>
<dt>templateFile</dt>
<dd>This attribute specifies that the output file should be written by expanding the supplied template file, as described below.</dd>
<dt>marker</dt>
<dd>This attribute specifies an alternative marker character for template expansion; the default is '@'.</dd>
</dl>
<p><u>Alternative file formats</u></p>
<p>As described above, the Configure tool supports five different file types: more if you use plugin classes.  These are as follows:</p>
<dl>
<dt>"properties"</dt>
<dd>This denotes a classic Java properties file, as documented in the Sun javadocs for the java.util.Properties class.</dd>
<dt>"xmlProperties"</dt>
<dd>This denotes a XML Java properties file, as documented in the Sun javadocs for the java.util.Prfoperties class (Java 1.5 or later).</dd>
<dt>"xml"</dt>
<dd>This denotes an XML file whose structure is not known.</dd>
<dt>"java"</dt>
<dd>This denotes a Java source code file.  </dd>
<dt>"text"</dt>
<dd>This denotes an arbitrary text file.</dd>
<dt>other</dt>
<dd>org.jnode.configure.adapter.FileAdapter class.  The behavior is as described below<br/>
</dl>
<p>The file types "xml", "java" and "text" require the use of a template file, and do not permit properties to be loaded.</p>
<p><u>Template file expansion</u></p>
<p>If Configure uses a java.util.Properties.saveXXX method to write properties, you do not have a great deal of control over how the file is generated.  For example, you cannot include comments for each property, and you cannot control the order of the properties.</p>
<p>The alternative is to create a template of a file that you want the Configure tool to add properties to.  Here is a simple example:</p>
<pre># This file contains some interesting properties

# The following property is interesting
<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c5acabb1a0b7a0b6b1acaba2f885acabb1a0b7a0b6b1acaba2">[email&#160;protected]</a>@

# The following property is not at all interesting
<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0b69647962656c364b69647962656c">[email&#160;protected]</a>@
</pre><p>If the file above is specified as the "templateFile" for a property set that includes the "interesting" and "boring" properties, the Configure tool will output the property set by expanding the template to replace "@<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="0f66617b6a7d6a7c7b6661684f">[email&#160;protected]</a>" and "@<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="cfada0bda6a1a88f">[email&#160;protected]</a>" with the corresponding property values.</p>
<p>The general syntax for @<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="d9f7f7f799">[email&#160;protected]</a> sequences is:</p>
<pre>    at_sequence ::= '@' name [ '/' modifiers ] '@'
    name        ::= ... # any valid property name
    modifiers   ::= ... # one or more modifier chars
</pre><p>The template expansion process replaces @<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="89a7a7a7c9">[email&#160;protected]</a> sequences as follows:</p>
<ul>
<li>If the &lt;name&gt; matches a property name in the property set, the sequence is replaced with the named property's value, rewritten as described below.
<li>If the @&lt;name&gt;@ <b>does not</b> match a property name in the property set, the sequence is replaced with an empty string.  <i>(This is a change from early versions of the tool which left sequence unchanged.)</i>
<li>The sequence @@ is replaced a single '@' character.
<li>It is an error for an "opening" @ to not have a "closing" @ on the same line.
</ul>
<p>The template expansion is aware of the type of the file being expanded, and performs file-type specific escaping of properties before writing them to the output stream:</p>
<ul>
<li>The expander for a "properties" file escapes the value according to the Java property file syntax.  Three &lt;modifier&gt; values are supported:
<ul>
<li>The '=' modifier causes the property name and value to be expanded; i.e. "&lt;name&gt;=&lt;value&gt;" where the name and value parts are suitably escaped.
<li>The '!' modifier (with '=') causes an empty property value to be suppressed by replacing the @<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="446a6a6a04">[email&#160;protected]</a> sequence with an empty string.
<li>The '#' modifier (with '=') causes an empty property value to be commented out; i.e. "# &lt;name&gt;=&lt;value&gt;"
</ul>
<li>The expanders for "xmlProperties" and "xml" files escapes the value so that it can be embedded in the text content of an element.
<li>The expander for "java" files outputs the value with Java string literal escapes.
</ul>
</div>
<div id="node-2689" class="section-5">
<h1 class="book-heading">Specifying property screens</h1>
<p>The "dialog" between the Configure tool and the user is organized into sequences of questions called screens.  Each screen is a described by a "screen" element in the configuration script.  Here is a typical example:</p>
<pre>  &lt;screen title="Main JNode Build Settings"&gt;
    &lt;item property="jnode.virt.platform"&gt;
The JNode build can generate config files for use with
various virtualization products.
    &lt;/item&gt;
    &lt;item property="expert.mode"&gt;
Some JNode build settings should only be used by experts.
    &lt;/item&gt;
  &lt;/screen&gt;
</pre><p>
When the Configure tool processes a screen, it first outputs the screen's "title" and then iterates over the "item" elements in the screen.  For each item, the tool outputs the multi-line  content of the item, followed by a prompt formed from the designated property's description, type and default value.  The user can enter a value, or just hit <b>ENTER</b> to accept the default.  If the value entered by the user is acceptable, the Configure tool moves to the next item in the screen.  If not, the prompt is repeated.</p>
<p><b>Conditional Screens</b></p>
<p>The screen mechanism allows you to structure the property capture dialog(s) independently of the property files.  But the real power of this mechanism is that screens can be made conditional on properties captured by other screens.  For example:</p>
<pre>  &lt;screen title="Virtualization Platform Settings"
          guardProp="jnode.virt.platform" valueIsNot="none"&gt;
    &lt;item property="jnode.vm.size"&gt;
You can specify the memory size for the virtual PC.  
We recommended a memory size of least 512 Mbytes.
    &lt;/item&gt;
    &lt;item property="jnode.virtual.disk"&gt;
Select a disk image to be mounted as a virtual hard drive.
    &lt;/item&gt;
  &lt;/screen&gt;
</pre><p>This screen is controlled by the state of a guard property; viz the "guardProp" attribute.  In this case, the "valueIsNot" attribute says that property needs to be set to some value other than "none" for the screen to be acted on.  (There is also a "valueIs" attribute with an analogous meaning.)</p>
<p>The Configuration tool uses an algorithm equivalent to the following one to decide which screen to process next:</p>
<ol>
<li>The tool builds a work-list of the screens in the script.  The screens are added to the list in the order that they are encountered by the script file parser.
<li>To find the next screen, the tool iterates over the work list entries, looking for the screen one that satisfies one of the following criteria:
<ul>
<li>a screen with no guard property, <i>or</i>
<li>a screen with whose guard property has been set, <i>and</i>
<ul>
<li>has a "valueIs" attribute whose value equals the guard property's value, <i>or</i>
<li>has a "valueIsNot" atttibute whose value does not equal the guard property's value.
</ul>
</ul>
<li>The selected screen is then removed from the work-list and processed as described previously.
<li>To select the next screen, the tool goes back to step 2), repeating until either the work-list is empty, or none of the remaining screens satisfy the criteria.
</ol>
</div>
<div id="node-2690" class="section-5">
<h1 class="book-heading">Advanced features</h1>
<p><u>The "changed" attribute</u><br/>
The "item" element of a screen can take an attribute called "changed".  If present, this contains a message that will be displayed after a property is captured if the new value is different from the previous (or default) value.  For example, it can be used to remind the user to do a full rebuild when critical parameters are changed.</p>
</div>
</div>
<div id="node-2683" class="section-4">
<h1 class="book-heading">Configuration files</h1>
<p>The primary JNode build configuration file is the "jnode.properties" file in the project root directory.</p>
<p>Other important configuration files are the plugin lists.  These specify the list plugins that make up the JNode boot image and the lists that are available for demand loading in various the Grub boot configurations.</p>
</div>
</div>
<div id="node-64" class="section-3">
<h1 class="book-heading">Build process</h1>
<p>The build process of JNode consists of the following steps.</p>
<ul>
<li>Compilation - Compiles all java source to class files.
<li>Assembling - Combines all class files into a jar file.
<li>Boot image building - Preloads the core object into a bootable image.
<li>Boot disk building - Creates a bootable disk image.
<li>CD-ROM creation (optional) - Creates a bootable CD-ROM (iso) image
</ul>
<p><b>Boot image building</b><br><br/>
When JNode boots, the Grub bootload is used to load a Multiboot compliant kernel image and boot that image. It is the task of the BootImageBuilder to generate that kernel image.</p>
<p>
The BootImageBuilder first loads java classes that are required to start JNode into there internal Class structures. These classes are resolved and the most important classes are compiled into native code.<br/>
The object-tree that results from this loading &amp; compilation process is then written to an image in exactly the same layout as an object in memory is. This means that the the necessary heap headers, object headers and instance variables are all written in the correct sequence and byte-ordering.<br/>
The memory image of all of these objects is linked with the bootstrapper code containing the microkernel. Together they form a kernel image loaded &amp; booted by Grub.</p>
<p><b>Boot disk building</b><br/>
<br><br/>
To run JNode, in a test environment or create a bootable CD-ROM, a bootable disk image is needed. It is the task of the BootDiskBuilder to create such an image.</p>
<p>
The bootable disk image is a 16Mb large disk image containing a bootsector, a partition table and a single partion. This single partition contains a FAT16 filesystem with the kernel image and the Grub stage2 and configuration files.</p>
<div id="node-116" class="section-4">
<h1 class="book-heading">Build &amp; development environment</h1>
<p>This chapter details the environment needed to setup a JNode development environment.</p>
<p><b>Sub-Projects</b></p>
<p>
JNode has been divided into several sub-projects in order to keep it "accessible". These sub-projects are:</p>
<table>
<tr>
<td>JNode-All</td>
<td>The root project where everything comes together<br/>
JNode-Core  The core java classes, the Virtual Machine, the OS kernel and the Driver framework</td>
</tr>
<tr>
<td>JNode-FS</td>
<td>The Filesystems and the various block device drivers</td>
</tr>
<tr>
<td>JNode-GUI</td>
<td>The AWT implementation and the various video &amp; input device drivers</td>
</tr>
<tr>
<td>JNode-Net</td>
<td>The Network implementation and the various network device drivers</td>
</tr>
<tr>
<td>JNode-Shell</td>
<td>The Command line shell and several system commands</td>
</tr>
</table>
<p>Each sub-project has the same directory structure:</p>
<table>
<tr>
<td>&lt;subprj&gt;/build       </td>
<td>All build results </td>
</tr>
<tr>
<td>&lt;subprj&gt;/descriptors </td>
<td>All plugin descriptors</td>
</tr>
<tr>
<td>&lt;subprj&gt;/lib         </td>
<td>All sub-project specific libraries</td>
</tr>
<tr>
<td>&lt;subprj&gt;/src         </td>
<td>All sources </td>
</tr>
<tr>
<td>&lt;subprj&gt;/.classpath  </td>
<td>The eclipse classpath file</td>
</tr>
<tr>
<td>&lt;subprj&gt;/.project    </td>
<td>The eclipse project file</td>
</tr>
<tr>
<td>&lt;subprj&gt;/build.xml   </td>
<td>The Ant buildfile</td>
</tr>
</table>
<p><b>Eclipse</b></p>
<p>JNode is usually developed in Eclipse. (It can be done without)<br/>
The various sub-projects must be imported into eclipse. Since they reference each other, it is advisably to import them in the following order:</p>
<ol>
<li>core</li>
<li>shell</li>
<li>fs</li>
<li>gui</li>
<li>net</li>
<li>builder</li>
<li>distr</li>
<li>all</li>
<li>sound</li>
<li>textui</li>
<li>cli</li>
</ol>
<p>For a more details please have a look at <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/614">this</a> Howto.</p>
<p>
<b>IntelliJ IDEA</b></p>
<p>
JetBrains Inc has donated a Open Source License for Intellij IDEA to the dedicated developers working on JNode.</p>
<p>Developers can get a license by contacting <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#2941484e485b694347464d4c07465b4e">Martin</a>.<br/>
 Setup of the sub-projects is done with using the modules feature like with Eclipse. </p>
<p>One should increase the max memory used in the bin/idea.exe.vmoptions or bin/idea.sh.vmoptions file, edit the -Xmx line to about 350mb. IntelliJ can be downloaded at <a href="https://web.archive.org/web/20200119030613/http://www.jetbrains.com/idea/download/">http://www.jetbrains.com/idea/download/</a> Use at least version 5.1.1. Note that this version can import Eclipse projects.  </p>
<p><b>Requirements for building under Windows</b></p>
<ol>
<li>Make sure that you have a Sun JDK for Java 1.6.0 at or near the most recent patch level.  (Some older patch levels are known to cause obscure problems with JNode builds.)
<li>Make sure that the pathname for the root directory your JNode tree contains no spaces.  (Spaces in the pathname are likely to break the build.)
<li>Create a "bin" directory to holds some utilities; see below.
<li>Use the "System" control panel to add the "bin" directory to your windows %PATH%.
<li>Download the "nasm" assembler from <a href="https://web.archive.org/web/20200119030613/http://nasm.sourceforge.net/">http://nasm.sourceforge.net</a>. (Make sure that you get the Win32 version not the DOS32 version!)
<li>Open the downloaded ZIP file, and copy the "nasm.exe" file to your "bin" directory.  Then rename it to "nasmw.exe".
</ol>
<p>Now, can start a Windows command prompt, change directory to the JNode root, and build JNode as explained the next section.</p>
<p><b>Requirements for building under Linux</b></p>
<ol>
<li>Make sure that you have a Sun JDK for Java 1.6.0 at or near the most recent patch level.  (Some older patch levels are known to cause obscure problems with JNode builds.)
<li>Make sure that the 'nasm' assembler is installed.  If not, use "System&gt;Add/Remove Software" (or your system's equivalent) to install it.
</ol>
<p><b>Building</b></p>
<p>Running "build.sh" or "build.bat" with no arguments to list the available build targets.  Then choose the target that best matches  your target environment / platform.</p>
<p>Alternatively, from within Eclipse, execute the "all" target of all/build.xml. Building in Eclipse is not advised for Eclipse version 2.x because of the amount of memory the build process takes. From Eclipse 3.x make sure to use Ant in an external process.</p>
<p>
A JNode build will typically generate in the following files:</p>
<table>
<tr>
<td>all/build/jnodedisk.pln           </td>
<td>A disk image for use in VMWare 3.0</td>
</tr>
<tr>
<td>all/build/x86/netboot/jnodesys.gz </td>
<td>A  bootable kernel image for use in Grub.</td>
</tr>
<tr>
<td>all/build/x86/netboot/full.jgz    </td>
<td>A initjar for use in Grub.</td>
</tr>
</table>
<p>Some builds also generate an ISO image which you can burn to disk, and then use to boot into JNode from a CD / DVD drive.</p>
<div id="node-622" class="section-5">
<h1 class="book-heading">IntelliJ Howto</h1>
<p>This chapter explains how to use <a href="https://web.archive.org/web/20200119030613/http://www.jetbrains.com/idea/">IntelliJ IDEA 4.5.4</a> with JNode. JetBrains Inc has donated a Open Source License to the dedicated developers working on JNode. The license can optained by contacting <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#95fdf4f2f4e7d5fffbfaf1f0bbfae7f2">Martin</a>.</p>
<p>New developers not yet on the JNode project can get a free 30-day trial license from JetBrains Inc.</p>
<p><b>Starting</b></p>
<p>JNode contains several modules within a single CVS module. To checkout and import these modules in IntelliJ, execute the following steps:</p>
<ol start="1">
<li>Checkout the jnode module from CVS using IntelliJ's "File -&gt; Check Out from CVS".
<p>Dedicated developer should use a Cvs root like ":ssh:<i>developername</i>@cvs.sourceforge.net:/cvsroot/jnode"</p>
<p>Other should use Anonymous CVS Access and use Cvs root ":pserver:<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="44252a2b2a3d292b3137042732376a372b31362721222b3623216a2a2130">[email&#160;protected]</a>:/cvsroot/jnode"
</li>
<li>Open the project with "File -&gt; Open project" and select the folder that was choosen as destination in the CVS check out. In the "jnode" folder select the "JNode.ipr" file.
</li>
</ol>
<p>The rest has been setup in the project and you should now be able to start.</p>
<p><b>Building</b></p>
<p>You can build JNode within IntelliJ by using the build.xml Ant file. In the right side of IntelliJ you find a "Ant Build" tab where the ant file is found. Run the "help" Target to get help on the build system. </p>
<p>Due to the memory requirements of the build process, it could be better to run the build from the commandline using build.bat (on windows) or build.sh (on unix).</p>
</div>
</div>
<div id="node-2665" class="section-4">
<h1 class="book-heading">Building on the Mac OSX / Intel platform</h1>
<p>(These instructions were contributed by "jarrah".)</p>
<p><i>I've successfully built jnode on MacOS X from the trunk and the 2.6 sources. Here's what I needed to do:</p>
<ol>
<li>I'm using 10.5.2. I'm not sure if it works on 10.4.x.
<li>Download and install Java SE 6 from the ADC site. I used Developer Preview 9. Note that this only works on 64 bit compatible machines (MacBook Pro's with Core 2 Duo processors are OK). The link to the downloads page is: <a href="https://web.archive.org/web/20200119030613/https://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/105/wo/aC2LI" title="https://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/105/wo/aC2LI">https://connect.apple.com/cgi-bin/WebObjects/MemberSite.woa/105/wo/aC2LI</a>...
<li>If you don't want to use Java SE 6 as your default Java (I don't), then edit build.sh and add /System/Library/Frameworks/JavaVM.framework/Versions/1.6/Commands/ before the java command.
<li>Download and build cdrtools (I used version 2.01.01) from <a href="https://web.archive.org/web/20200119030613/http://cdrecord.berlios.de/private/cdrecord.html" title="http://cdrecord.berlios.de/private/cdrecord.html">http://cdrecord.berlios.de/private/cdrecord.html</a>. I just installed the mkisofs executable in /usr/local/bin (which is in my path).
<li>Download and install yasm from <a href="https://web.archive.org/web/20200119030613/http://www.tortall.net/projects/yasm/wiki/Download" title="http://www.tortall.net/projects/yasm/wiki/Download">http://www.tortall.net/projects/yasm/wiki/Download</a>. I used version 0.6.2.
<li>Edit all/lib/jnode.xml and change the javac "memoryMaximumSize" attribute to "1024m".
<li>Edit core/src/openjdk/sun/sun/applet/AppletViewerPanel.java and comment out line 34 "import sun.tools.jar.*;"
<li>Run "sh build.sh cd-x86-lite".
</ol>
<p>You should end up with an ISO image called jnode-x86.iso in all/build/cdroms.</p>
<p>Cheers,</p>
<p>Greg</p>
<p></i></p>
</div>
<div id="node-533" class="section-4">
<h1 class="book-heading">Using OSX and PowerPC for JNode development and testing</h1>
<p>Using OSX and PPC for JNode development and testing</p>
<p>What we want is:<br/>
 1. CVS tool<br/>
 2. IDE for development<br/>
 3. A way to build JNode<br/>
 4. A way to boot JNode for testing</p>
<p>First of all we need to install the XCode tools from apple. Usually it is shipped with your OSX, look in /Applications/Installers/. If it is not there you, you can download it from apples site.</p>
<p>1. CVS tool<br/>
Well cvs is already in the OSX installation. There are some GUI tools to make the use of cvs easier. SmartCVS is a good one, which you can use it in your windows/PC computer, or linux etc.</p>
<p>2. IDE<br/>
Eclipse. <img src="/web/20200119030613im_/http://www.jnode.org/modules/smileys/packs/example/wink.png" title="Eye-wink" alt="Eye-wink"/></p>
<p>3. How to build JNode with a ppc machine (not FOR, WITH ppc)<br/>
Good for us, JNode build process is based on apache ant, which as a java tool runs everywhere. The only problem is the native assembly parts of JNode. For them JNode build process uses nasm and yasm.</p>
<p>So the only thing we need is to build them for ppc and use them. They will still make x86 binaries as they are written to do.</p>
<p>First of all we have to get the nasm and yasm sources. The first one is on<br/>
<a href="https://web.archive.org/web/20200119030613/http://nasm.sourceforge.net/" title="http://nasm.sourceforge.net">http://nasm.sourceforge.net</a><br/>
and the other is on<br/>
<a href="https://web.archive.org/web/20200119030613/http://www.tortall.net/projects/yasm/" title="http://www.tortall.net/projects/yasm/">http://www.tortall.net/projects/yasm/</a></p>
<p>After that we unzip them and start the compile.</p>
<p>NASM<br/>
Open a terminal window and go inside the directory with the nasm sources</p>
<p>Run ./configure to create the Makefile for nasm</p>
<p>If everything is ok you now are ready to compile nasm. Just run make nasm. Maybe there will be a problem if you try to compile all the nasm tools by running make (I had), but you dont need them. Nasm is enought.</p>
<p>Now copy nasm in your path. /usr/bin is a good place.</p>
<p>YASM<br/>
The same as for nasm open a terminal window and go to the directory with yasm sources.</p>
<p>Run ./configure</p>
<p>Run make</p>
<p>Now you can either copy yasm to /usr/bin or run make install which will install the yasm tools under /usr/local/bin.</p>
<p>Thats all with nasm and yasm. You are ready to build JNode. You may have problems using the buildl.sh script, but you can always run the build command manually java -Xmx512M -Xms128M -jar core/lib/ant-launcher.jar -lib core/lib/ -lib /usr/lib/java/lib -f all/build.xml cd-x86</p>
<p>4. Booting JNode<br/>
Well there is only one way to do that. Emulation.</p>
<p>There is VirtualPC for OSX, which is pretty good and fast. To use it just create a new virtual PC and start it. When the virtual PC is started right click on the CD-Rom icon at the bottom of the window (hmm I know there is no right click on macs <img src="/web/20200119030613im_/http://www.jnode.org/modules/smileys/packs/example/tongue.png" title="Sticking out tongue" alt="Sticking out tongue"/> I assume you know to press ctrl+click). Now tell the VirtualPC to use the JNode iso image as cdrom drive and boot from it. There you are!</p>
<p>I think there is also qemu for ppc. I have not ever used it, so I dont know how you can configure it.</p>
</div>
</div>
<div id="node-518" class="section-3">
<h1 class="book-heading">Source files &amp; packages</h1>
<p>This chapter explains the structure of the JNode source tree and the JNode package structure.</p>
<div id="node-519" class="section-4">
<h1 class="book-heading">Directory structure</h1>
<p>The JNode sources are divided into the following groups:</p>
<ul>
<li><i>all</i><br/>
Contains the global libraries, the (Ant) build files and some configuration files. This group does not contain java sources.</li>
<li><i>builder</i><br/>
Contains the java source code used to build JNode. This includes several Ant tasks, but also code used to link Elf files and to write the JNode bootimage.</li>
<li><i>core</i><br/>
Contains the JNode virtual machine code (both java and assembler), the classpath java library sources and the core of the JNode operating system, including the plugin manager, the driver framework, the resource manager and the security manager. This is by far the largest and most complex group.</li>
<li><i>distr</i><br/>
Contains the first parts of the JNode distribution. This includes an installation program and various applications.</li>
<li><i>fs</i><br/>
Contains the file system framework, the various file system implementation and the block drivers such as the IDE driver, harddisk driver, CD-ROM etc.</li>
<li><i>gui</i><br/>
Contains the JNode gui implementation. This includes the graphics drivers, the AWT peer implementation, font renderers and the JNode desktop.</li>
<li><i>net</i><br/>
Contains the JNode network layer. This includes the network drivers, the network framework, the TCP/IP stack and the connection between the network layer and the java.net package.</li>
<li><i>shell</i><br/>
Contains the JNode command shell and several system shell commands.</li>
<li><i>textui</i><br/>
Contains a copy of the charva text based AWT implementation.</li>
<li><i>cli</i><br/>
Contains the bulk of JNode's commands.
</ul>
<p>Every group is a directory below the root of the JNode CVS archive. Every group contains one or more standard directories.</p>
<ul>
<li><i>build</i><br/>
This directory is created during the build and contains the intermediate build results.</li>
<li><i>descriptors</i><br/>
This directory contains the plugin descriptors of the plugins defined in this group.</li>
<li><i>lib</i><br/>
This directory contains libraries (jar files) required only by this group. An exception is the All group, for which the lib directory contains libraries used by all groups.</li>
<li><i>src</i><br/>
This directory contains the source files. Below this directory there are one or more source directories (source folders in Eclipse) containing the actual source trees.</li>
</ul>
</div>
<div id="node-2667" class="section-4">
<h1 class="book-heading">JNode coding DOs and DONTs</h1>
<p>This page lists some tips on how to write good JNode code.</p>
<p><i>Please add other tips as required.</i></p>
<dl>
<dt><u>Avoid using System.in, System.out, System.err</u></dt>
<dd>Where possible, avoid using these three variables.  The problem is that they are global to the current isolate, and are not necessarily connected to the place that you expect them to be.</p>
<p>
In a user-level command should use streams provided by the Command API; e.g. by calling the 'getInput()' method from within the command's 'execute' method.  Device drivers, services and so on that do not have access to these streams should use log4j logging.<br></dd>
<dt><u>Avoid cluttering up the console with obscure or unnecessary logging</u></dt>
<dd>If a message is important enough to be written to the console, it should be self explanatory.  If it is unimportant, it should be logged using log4j at an appropriate level.  We really do not need to see console messages left over from someone's attempts to debug something 12 months ago ...<br/>
<br></dd>
<dt><u>Avoid using Unsafe.debug(...) methods</u></dt>
<dd>The org.jnode.vm.Unsafe.debug(...) methods write to the VGA screen and (when kernel debug is enabled) to the serial port.  This is ugly, and should be reserved for important early boot sequence logging, VM and GC debugging, and other situations where log4j logging <i>cannot</i> be used.<br></dd>
<dt><u>Don't call 'Throwable.printStackTrace' and friends</u></dt>
<dd>Commands should allow unexpected exceptions to propagate to the shell level where they are handled according to the user's setting of the 'jnode.debug' property. (The alternative of adding a "--debug" flag to each command, is a bad idea.  It is a lot of work and will tend to lead to inconsistencies of implementation; e.g. commands that don't implement "--debug", send "--debug" output to unexpected places, overload other functionality on the flag, etcetera.)</p>
<p>
Services, etc should make appropriate log4j calls, passing the offending Throwable as an argument.<br></dd>
<dt><u>Do use JNode's Command and syntax.* APIs for commands</u></dt>
<dd>Commands that are implemented using the Command and syntax.* APIs support completion and help, and are more likely to behave "normally"; e.g. with respect to stream redirection.  There are lots of examples in the codebase.</p>
<p>
If the APIs don't do what you want, raise an issue.  Bear in mind that some requests may be deemed to be "to hard", or to application specific.<br></dd>
<dt><u>Do include a 'main' entry point.</u></dt>
<dd>It is a good idea to include a legacy "public static void main(String[])" entry point in each JNode command.  This is currently only used by the old "default" command invoker, but in the future it may be used to run the command in a classic JVM.<br></dd>
<dt><u>Don't use '\n\r' or '\r\n" in output.</u></dt>
<dd>The line separator on JNode is '\n', like on UNIX / Linux.  If you expect your command to only run on JNode, it is not unreasonable to hardwire '\n' in output messages, etc.  But if you want your command to be portable, it should use 'System.getProperty("line.separator")', or one of the PrintWriter / PrintStream's 'println' methods.<br></dd>
</dl>
</div>
<div id="node-2662" class="section-4">
<h1 class="book-heading">JNode Java style rules</h1>
<p>All code that is developed as part of the JNode project <i>must</i> conform to the style set out in <a href="https://web.archive.org/web/20200119030613/http://java.sun.com/docs/codeconv/html/CodeConvTOC.doc.html">Sun's "Java Style Guidelines"</a> (JSG) with variations and exceptions listed below.  Javadocs are also important, <i>so please try to make an effort</i> to make them accurate and comprehensive.</p>
<p>Note that we use <a href="https://web.archive.org/web/20200119030613/http://checkstyle.sourceforge.net/"><b>CheckStyle 4.4</b></a> as our arbiter for Java style correctness.  Run "./build.sh checkstyle" to check your code style before checking it in or submitting it as a patch.  <b>UPDATE:</b> And also, please run "./build.sh javadoc" to make sure that you haven't introduced any new javadoc warnings.</p>
<dl>
<dt><u>No TAB characters.</u></dt>
<dd>No TAB characters (HT or VT) are allowed in JNode Java source code.<br/>
Whitespace TABs should be replaced with the requisite number of spaces or newlines.   Non-whitespace TABs (i.e. in Java strings) should be replaced with "\t" or "\f" escape sequences.<br/>
</dd>
<dt><u>Use 4 space indentation.</u></dt>
<dd>Two or three characters is too little, eight is too much.<br/>
</dd>
<dt><u>Maximum line width 120.</u></dt>
<dd>The JSG recommends 80 characters, but most people use tools that can cope with much wider.</dd>
<dt><u>Put following keywords on same line as <tt>}</tt></u></dt>
<dd>
For example:</p>
<pre>    try {
        if (condition) {
            something();
        } else {
            somethingElse();
        }
    } catch (Exception ex) {
        return 42;
    }
</pre><p>Note that the <tt>else</tt> is on the same line as the preceding <tt>}</tt>, as is the <tt>catch</tt>.<br/>
</dd>
<dt><u>Indent labels by -4.</u></dt>
<dd>For example:</p>
<pre>public void loopy() {
    int i;
LOOP:
    for (i = 100; i &lt; 1000000; i++) {
        if (isPrime(i) &amp;&amp; isPrime(i + 3) &amp;&amp; isPrime(i + 5) {
            break LOOP;
        }
    }
}
</pre></dd>
<dt><u>No empty <tt>{ }</tt> blocks</u></dt>
<dd>A <tt>{ }</tt> block with no code should contain a comment to say why the block is empty.  For example,</p>
<pre>    try {
        myStream.close();
    } catch (IOException ex) {
        // we can safely ignore this
    }
</pre></dd>
<dt><u>No marker comments</u></dt>
<dd>It is generally accepted that marker comments (like the following) add little to the readability of a program.  In fact, most programmers think they are an eyesore and a waste of space.</p>
<pre>    //*******************************************************
    //
    // Start of private methods
    //
    //*******************************************************
</pre></dd>
<dt><u>Avoid copying javadoc</u></dt>
<dd>Instead of copying the javadoc from the parent class or method, use the <i>{@inheritDoc}</i> tag and if needed add some specific javadoc.</p>
<pre>    /**
     * {@inheritDoc}
     */    
    public void myMethod(String param1, int param2) {
    }
</pre></dd>
<dt><u>Give your references in the javadoc</u></dt>
<dd>When you are implementing a class from a reference document, add a link in the javadoc.<br/>
</dd>
</dl>
</div>
<div id="node-520" class="section-4">
<h1 class="book-heading">Packages</h1>
<p>The java classes of JNode are organized using the following package structure.<br/>
Note that not all packages are listed, but only the most important. For a full list, refer to the javadoc documentation.</p>
<p>All packages start with <i>org.jnode</i>.</p>
<h2>Common packages</h2>
<ul>
<li><i>org.jnode.boot</i><br/>
Contains the first classes that run once JNode is booted. These classes initialize the virtual machine and start the operating system.</li>
<li><i>org.jnode.plugin</i><br/>
Contains the interfaces of the plugin manager.</li>
<li><i>org.jnode.util</i><br/>
Contains frequently used utility classes.</li>
<li><i>org.jnode.protocol</i><br/>
Contains the protocol handlers for the various (URL) protocols implemented by JNode. Every protocol maps onto a package below this package, e.g. the plugin protocol handler is implemented in <i>org.jnode.protocol.plugin</i>.</li>
</ul>
<h2>JNode virtual machine</h2>
<ul>
<li><i>org.jnode.vm</i><br/>
Contains the core classes of the JNode virtual machine.</li>
<li><i>org.jnode.vm.classmgr</i><br/>
Contains the internal classes that represent java classes, methods &amp; field. It also contains the classfile decoder.</li>
<li><i>org.jnode.vm.compiler</i><br/>
Contains the base classes for the native code compilers that convert java bytecodes into native code for a specific platform.</li>
<li><i>org.jnode.vm.memmgr</i><br/>
Contains the java heap manager, including the object allocator and the garbage collector.</li>
<li><i>org.jnode.vm.&lt;arch&gt;</i><br/>
For every architecture that is supported by JNode a seperate package exists, that contains the architecture dependent classes, including classes for threads and processors and classes for the native code compilation.</li>
</ul>
<h2>JNode operating system</h2>
<ul>
<li><i>org.jnode.driver</i><br/>
Contains the driver framework.<br/>
All drivers and driver API's have a seperate package below this package. Drivers of a similar type are grouped, e.g. all video drivers have a package below <i>org.jnode.driver.video</i>.</p>
<li><i>org.jnode.system</i><br/>
Contains the interfaces for the various low level resources in the system, such as memory regions, I/O port regions, DMA access.</li>
<li><i>org.jnode.fs</i><br/>
Contains the filesystem framework.<br/>
All file systems have a seperate package below this package, e.g. the EXT2 filesystem implementation is contained in the <i>org.jnode.fs.ext2</i> package and its sub-packages.</li>
<li><i>org.jnode.net</i><br/>
Contains the network layer.<br/>
All network protocols have a seperate package below this package, e.g. the IPv4 protocol and its sub-protocols is contained in the <i>org.jnode.net.ipv4</i> package and its sub-packages.</li>
<li><i>org.jnode.shell</i><br/>
Contains the command shell.<br/>
All system commands are grouped in packages below this package.</li>
</ul>
<h2>Special packages</h2>
<p>There are some packages that do not comply to the rule that all packages start with <i>org.jnode</i>. These are:</p>
<ul>
<li><i>java.*, javax.*</i><br/>
Contains the classpath implementation of the standard java libraries.</p>
<li><i>gnu.*</i><br/>
Contains implementation classes of the the classpath library.</li>
<li><i>org.vmmagic.pragma</i><br/>
Contains exception classes and interfaces that have special meaning to the virtual machine and especially the native code compilers. These classes are mostly shared with the Jikes RVM</li>
<li><i>org.vmmagic.unboxed</i><br/>
Contains non-normal classes that are used as pointers to raw memory, object references and architecture dependent integers (words). These classes have a special meaning to the virtual machine and especially the native code compilers and should never be instantiated or used without a good knowledge of their meaning. These classes are mostly shared with the Jikes RVM</li>
</ul>
</div>
<div id="node-504" class="section-4">
<h1 class="book-heading">Source file requirements</h1>
<h2>Header</h2>
<p>All java source files must contain the standard JNode header found in &lt;jnode&gt;/all/template/header.txt.</p>
<p>Do not add extra information to the header, since this header is updated automatically, at which time these extra pieces of information are lots.</p>
<p>Add any extra information about the class to the classes javadoc comment.  If you make significant contribution to a class, feel free to add yourself as an @author.  However, adding a personal copyright notice is "bad form", and unnecessary from the standpoint of copyright law.  (If you are not comfortable with this, please don't contribute code to the project.)</p>
<h2>Encoding</h2>
<p>All Java source files and other text-based files in the JNode project must be US-ASCII encoded. This means that extended characters in Java code must be encoded in the '\uxxxx' form.  Lines should end with an ASCII linefeed (LF) character, not CR LF or LF CR, and hard tab (HT) characters should not be used.  </p>
<p>If there is a pressing need to break these rules in some configuration or regression data file, we can make an exception.  However, it is advisable to highlight the use of "nasty" characters (e.g. as comments in the file) so that someone doesn't accidentally "fix" them.</p>
</div>
</div>
<div id="node-105" class="section-3">
<h1 class="book-heading">Plugin framework</h1>
<p>In JNode, all code, services and resources are packaged into plugins.</p>
<p>Each plugin has a descriptor that defines the packages it contains, the plugins it depends on, and any extensions. The plugin-descriptors are held in the descriptors/ directory of each subproject. During the build, once the subprojects have been compiled, the plugins are assembled based on the descriptors that are found.</p>
<p>Plugins are collectively packaged into an initjar. This jar file is passed on the command line to grub when booting JNode and defines what is available to JNode during boot (drivers and such), as well after boot (commands/applications).</p>
<h2>-- JNode Plugins --</h2>
<p>A JNode plugin is defined by an xml file, its descriptor, contained in the descriptors/ directory of the subproject it belongs too. Filesystem plugins are in fs/descriptors, shell plugins in shell/descriptors and so on.</p>
<p>The root node of a plugin descriptor is &gt;plugin&lt; which takes a few required arguments that give the id, name, version and license.</p>
<pre>id : the plugin id. This is the name that other plugins will use for dependencies, and the plugin-list will 
     use to include the plugin in an initjar.
name : A short descriptive name of what the plugin is.
version : The version of the plugin. For non-jnode plugins, this should be the version of the software being
          included. For JNode plugins, use @<a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="b7e1f2e5e4fef8f9f799">[email&#160;protected]</a>
license-name : the name of the license the code in the plugin defines. JNode uses lgpl
provider-name : The name of the project that provided the code, JNode.org for jnode plugins.
class(optional) : If the plugin requires special handling when loading/unloading the plugin, it can define a
                  class here that extends org.jnode.plugin.Plugin, overriding the start() and stop() methods.
</pre><p>
Under the &lt;plugin&gt; node are definitions for different parts of the plugin. Here you define what the plugin includes, what it depends on, and any extensions.</p>
<p>The &lt;runtime&gt; node defines what a plugin is to include in its jar-file.</p>
<pre>&lt;runtime&gt;
  &lt;library&gt; name="foo.jar&gt;
    &lt;export name="foo.*"&gt;
  &lt;/library&gt;
&lt;/runtime&gt;
</pre><p>
This will export the classes that match foo.* in foo.jar to a jar file. This is how you would include classes from a non-jnode library into a plugin for use in jnode. To have a plugin include jnode-specific classes, the library name is of the form "jnode-<subproject>.jar" and tells the plugin builder not to look in a jar file, but to pull the classes from the build/ directory of that jnode subproject.</p>
<p>To declare dependencies for a plugin, a list of &lt;import&gt; nodes under a &lt;requires&gt; node is required.</p>
<pre>&lt;requires&gt;
  &lt;import plugin="org.jnode.shell"/&gt;
&lt;/requires&gt;
</pre><p>Will add a dependency to the org.jnode.shell plugin for this plugin. The dependency does two things. When a plugin is included in a plugin-list, its dependencies must also be included, or the initjar builder will fail. </p>
<p>Each plugin has its own classloader. If commands or applications defined in a plugin are run, instead of using a classpath to find classes and jars, the plugin uses the dependencies to search for the proper classes. Every plugin class loader has access to the system plugins, its own plugin, and any plugins listed as dependencies. This means that no plugin needs to require a system plugin.</p>
<p>The last part of a plugin are the extensions. These are not specific to plugins, but rather to different parts of jnode that use the plugin. An extension is defined as :</p>
<pre>&lt;extension point="some.extension.point"&gt;
</pre><p>The content of an extension is defined by its point. Below is a brief list of extension points and where to find documentation on them.</p>
<pre>Shell Extensions
point="org.jnode.shell.aliases"
    Used to define aliases for the alias manager in the shell.

point="org.jnode.shell.syntaxes"
    Used to define a syntax for command line arguments to an alias.

Core Extensions
point="org.jnode.security.permissions"
    Used to define a syntax for command line arguments to an alias.

Core Extensions
point="org.jnode.security.permissions"
    Used to define what permissions the plugin is granted.
</pre><h2>-- Plugin List --</h2>
<p>A plugin list is used to build an initjar and includes all the plugin jars that are defined in its list. The default plugin lists are in all/conf and these lists are read, and their initjars built by default. To change this behavior there are two options in jnode.properties that can be added to tell the build system where to look for custom plugin-lists, and also to turn off building the default plugins.</p>
<p>jnode.properties</p>
<pre>custom.plugin-list.dir = <directory>
    Directory can be any directory. ${root.dir} can be used to prefix the path with the directory of your jnode build.
no.default.initjars = 1
    Set to 1 to disable building the default initjars
</pre><p>
A plugin list has a very simple definition. The root node is &lt;plugin-list&gt; that takes a single name attribute that will be the name of the actual initjar. The list of plugins are defined by adding &lt;plugin id="some.plugin"&gt; entries. If a plugin is included that has dependencies, and those plugins are not in the list, the initjar builder will fail.</p>
<p>You can add entries into the initjar manifest file by adding a &lt;manifest&gt; node with a list of &lt;attribute&gt; nodes. Attributes have two arguments, key and value. At a minimum you will want the following manifest entries :</p>
<pre>&lt;manifest&gt;
  &lt;attribute key="Main-Class" value="org.jnode.shell.CommandShell"/&gt;
  &lt;attribute key="Main-Class-Arg" value="boot"/&gt;
&lt;/manifest&gt;
</pre><p>This tells jnode, when it finishes initializing, and loads the initjar, that it should run CommandShell.main() with a single argument "boot", so that it knows that this shell is the root shell.</p>
<p>There are many reasons to create your own initjar plugin-list. The most basic reason would be to reduce the overhead of building jnode. By turning off building the default initjars, and defining your own plugin-list for a custom initjar, you can reduce the rebuild time of jnode when making simple changes. It can also allow you to create new plugins and define them in a plugin-list without disturbing the default initjar plugin-lists.</p>
<p>For a basic starting point, the shell-plugin-list.xml creates an initjar that has the minimal plugins for loading jnode and starting a CommandShell. From there you can add plugins that you want, to add various features.</p>
<div id="node-136" class="section-4">
<h1 class="book-heading">How to add a plugin to JNode</h1>
<p>
This page will describe how to add a java program to JNode as plugin, so that it can be called via its alias.</p></p>
<p>
First of all you need to set up Eclipse (or your favorit IDE)  as described in the readme, so that JNode builds without errors and you can use it (e.g. use JNode in VMWare).
</p>
<p>
There are different ways of extending JNode with a plugin.<br/>
A plugin can contain a class that extends Plugin and (or) normal java programs.<br/>
Every plugin is described by a descriptor.<br><br/>
For our example we will develop a plugin that contains a normal java program.<br><br/>
We need a name for our plugin : we will use sample, wich is also the packagename of our plugin.<br/>
It belongs to one of the JNodes subprojects in our case we will use the ordername sample in the shell subproject.
</p>
<p>
Every java-file for our plugin has to be in (or in subfolders):<br/>
<br><br><br/>
\shell\src\shell\org\jnode\shell\sample<br><br/>
(for me it is d:\jnode\shell\src\shell\org\jnode\shell\sample)<br/>
<br><br><br/>
Now we will write a small HelloWorld.java wich will be one of our plugin programs.<br/>
Here is the source of the file HelloWorld.java :
</p>
<p>
package org.jnode.shell.sample;<br><br/>
public class HelloWorld{<br><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public static void main(String[] args){<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(HelloWorld  <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="1460667d777f7f7d6760715473796c3a7071">[email&#160;protected]</a>);<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br/>
}
</p>
<p>
thats ok, but it will not be build until we create a descriptor and add our plugin to the JNode full-plugin-list.xml.<br/>
<br><br><br/>
The plugin descriptor (org.jnode.shell.sample.xml stored in the descriptors folder of the shell subproject) and looks like this :
</p>
<p>
&lt;?&#120;&#109;&#108; version="1.0" encoding="UTF-8"? &gt;<br><br/>
&lt;!DOCTYPE plugin SYSTEM "jnode.dtd"&gt;<br><br><br/>
&lt;plugin id="org.jnode.shell.sample"<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name="Sample Plugin"<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;version="0.2"<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;license-name="lgpl"<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;provider-name="Trickkiste"&gt;<br>
</p>
<p>
&lt;requires&gt;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;import plugin="org.jnode.shell"/&gt;<br><br/>
&lt;/requires&gt;
</p>
<p>
&lt;runtime&gt;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;library name="jnode-shell.jar"&gt;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;export name="org.jnode.shell.sample.*"/&gt;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/library&gt;<br><br/>
&lt;/runtime&gt;
</p>
<p>
&lt;extension point="org.jnode.shell.aliases"&gt;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;alias name="HelloWorld" class="org.jnode.shell.sample.HelloWorld"/&gt;<br><br/>
&lt;/extension&gt;
</p>
<p>&lt;/plugin&gt;</p>
<p>
Now we need to add our Plugin to the JNode full-plugin-list.xml, this file is located in jnode\all\conf your entry should look like this :
</p>
<p>
[...]<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugin id="org.jnode.util"/&gt;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugin id="org.jnode.vm"/&gt;<br><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugin id="org.jnode.vm.core"/&gt;<br><br></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;plugin id="org.jnode.shell.sample"/&gt;<br><br></p>
<p>&lt;/plugin-list&gt;
</p>
<p>
thats it, you can now build JNode and test your HelloWorld plugin by typing HelloWorld.<br><br/>
What we can do now is add normal programs to JNode via its provided Pluginstructure.
</p>
</div>
</div>
<div id="node-3012" class="section-3">
<h1 class="book-heading">Command Line Interface</h1>
<div id="node-3013" class="section-4">
<h1 class="book-heading">Arguments - The Basics</h1>
<p>In JNode's command line interface, the Argument types are the Command programmers main tool for interacting with the user. The Argument provides support to the syntax mechanism to accept parameters, or reject malformed parameters, issuing a useful error message. The argument also supplies completion support, allowing a command to provide specific completions on specific domains.</p>
<h1>Organization</h1>
<p>At the moment, Arguments are mostly grouped into the shell project under the <i>org.jnode.shell.syntax</i> package. For the time being they will remain here. There is an effort being made to 'untangle' the syntax/argument APIs so this designation is subject to change in the future.</p>
<p>New arguments that are created should be placed into the cli project under the <i>org.jnode.command.argument</i> package if their only use is by the commands under the cli project.</p>
<h1>How it works</h1>
<p>Every command that accepts an option will require Arguments to capture the options and their associated values. The syntax parser makes use of an argument 'label' to map a syntax node to a specific argument. The parser then asks the Argument to 'accept' the given value. The argument may reject the token if it doesn't not satisfy it's requirements, and provide a suitable error message as to why. If it accepts the token, then it will be captured by the argument for later use by it's command.</p>
<p>Arguments also provide the ability to 'complete' a partial token. In some situations completions are not possible or do not make sense, but in many situations completions can be very helpful and save on typing, reduce errors, and even provide a little help if there are alot of options. The more characters there are in the token, the narrower the list of completions becomes. If the argument supplies only a single completion, this completion will be filled in for the user. This is a very powerful capability that can be used to great effect!</p>
<h1>Using arguments</h1>
<p>Before writing a command, it is important to consult the various specifications that many commands may have. Once you have an idea of the arguments you will need for the command, and you have a syntax put together, you can begin by adding your arguments to the command.</p>
<p>Along with the label that was discussed earlier, commands also take a set of flags. A set of flags is supplied by the Argument class, but individual Argument types may also supply their own specific flags. At the end of this document will be a list of known flags and their purpose, but for now we will discuss the common Argument flags.</p>
<dl>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#SINGLE">SINGLE</a> and <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#MULTIPLE">MULTIPLE</a></dt>
<dd>
    By default arguments are 'SINGLE'. This means that the argument may only contain one value. In order to change this, and allow the argument to capture multiple values, you must set the MULTIPLE flag.<br/>
  </dd>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#OPTIONAL">OPTIONAL</a> and <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#MANDATORY">MANDATORY</a></dt>
<dd>
    By default arguments are 'OPTIONAL'. This means that if the argument is not populated with any values, it will not be considered an error. In order to have the parser fail if the argument is not populated with at least one value, set the MANDATORY flag.<br/>
  </dd>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#EXISTING">EXISTING</a> and <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#NONEXISTENT">NONEXISTENT</a></dt>
<dd>
    These flags are not used by all arguments and may be used to alter the behavior of 'accept' and 'complete' depending on the argument, and their values. As an example, the FileArgument by default will accept most any string that denotes a legal file name. In order to force it to only accept tokens that denote an existing file on the file system than set the EXISTING flag. In order to force it to only accept tokens that denote a file that does <b>not</b> exist already, set the NONEXISTENT flag.<br/>
  </dd>
</dl>
<p>Most arguments have overloaded constructors that allow you to not set any flags. If no such constructor exists, then feel free to create one! Optionally, it is safe to provide '0'(zero) for the flags parameter to mean no flags.</p>
<p>Once you have created the arguments that your command will need, you need to 'register' the arguments. This needs to be done in the Command constructor. Each argument needs to be passed to the <i>registerArguments(Argument...)</i> method. Once this is done, your arguments are ready to be populated the syntax parser.</p>
<p>(Note: Arguments that have been registered, but do not have a matching syntax node with its label will not cause an error at runtime. But they do make trouble for the 'help' command. For this reason it is recommended to not register arguments that have not yet been mapped in the syntax.)</p>
<h1>Using arguments</h1>
<p>When your command enters at the <i>execute()</i> method, the arguments will be populated with any values that were capture from the command line. For the most part, you will only need to be concerned with three methods supplied by Argument.</p>
<dl>
<dt>public boolean <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#isSet()">isSet()</a></dt>
<dd>
    If the argument has accepted and captured a token, then this method will return true. Commands should always check this method before querying for the captured values. If you query an argument for its values when it has none, the behavior is undefined and the return value (or possible exception) is unspecified and subject to change without notice. (The one case where this is not totally true is when an argument has the MANDATORY flag, as in this case this will _always_ return true. Though it is still considered 'good practice' to check this method before querying for values)<br/>
  </dd>
<dt>public V <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#getValue()">getValue()</a></dt>
<dd>
    This method returns the single value of an argument that was registered as SINGLE. If the argument has the MULTIPLE flag set, this method should not be used as it will throw an exception if there is more than one value captured by the argument. If there are no values captured, this currently returns null, but as noted earlier, this may not always be the case, and should not be relied upon.<br/>
  </dd>
<dt>public V[] <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/Argument.html#getValues()">getValues()</a></dt>
<dd>
    This method returns the captured values as an array. Calling this method when there the SINGLE flag is set is perfectly acceptable. Though it is usually more convenient to use the <i>getValue()</i> method.<br/>
  </dd>
</dl>
<p>Thats about it for arguments. Simple huh? Arguments are designed to allow for rapid development of commands and as such provide a nice simple interface for using arguments 'out of the box' so to speak. But the real power of arguments are their ability to be extended and manipulated in many ways so as to provide a more feature filled command line interface. <!-- Add link to advanced arg usage page when its up --></p>
<h1>Basic argument types</h1>
<p>Here are a list of the more common argument types, along with a short description on their purpose, features and usage.</p>
<dl>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/AliasArgument.html">AliasArgument</a></dt>
<dd>
    An argument that accepts an 'alias'. It provides completion against those aliases that have been registered via plugin descriptors, and may also include the bjorne-style aliases if the bjorne interpreter is in use. (I'm not sure if it currently does, if not it should!)<br/>
  </dd>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/FileArgument.html">FileArgument</a></dt>
<dd>
    An argument that accepts a <i>java.io.File</i>. As used in an example above, this argument is affected by the EXISTING and NONEXISTENT flags of Argument. FileArgument also currently provides two of its own flags that may be set. ALLOW_DODGY_NAMES is used to override the 'accept' and 'complete' features to allow filenames that begin with a '-'(hyphen). Normally FileArgument would consider such a filename to be an error, and reject such a token. There is also the HYPHEN_IS_SPECIAL flag, which allows a single '-' to be accepted. The purpose for this is to allow '-' to exist amongst a list of files, denoting stardnard input or output should be used instead. This feature is subject to change (pending some 'better way' of handling this).<br/>
  </dd>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/FlagArgument.html">FlagArgument</a></dt>
<dd>
    This is likely to be the most used argument of all. It is used to denote a option that has no associated argument. This argument does not actually capture a token, instead it holds a single value of true if it has been found. This means that you can use isSet() to map its value to a local/instance boolean value. In some cases, a command may wish to allow a flag to be used multiple times to add advanced meaning. The command can use <i>getValues().length</i> in such a case to determine the number of times it has been specified.<br/>
  </dd>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/IntegerArgument.html">IntegerArgument</a> / <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/LongArgument.html">LongArgument</a> / DecimalArgument(TODO)</dt>
<dd>
    Allows an integer value to be captured on the command line. These arguments do not provide very helpful completion, as their domain of completions is generally too large. Their main purpose is to parse valid integers, rejecting those that are malformed.<br/>
  </dd>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/StringArgument.html">StringArgument</a></dt>
<dd>
    This is one of the most 'accepting' arguments, as it will accept any token that is given to it. It also provides no completion. If your command really needs an unbounded String, then this is the right argument to use. This argument should be extended for cases where you want to accept a string, but the domain of acceptable strings is limited, and you wish to reject those tokens not within that domain and also possibly provide completion for the argument.<br/>
  </dd>
<dt><a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/org/jnode/shell/syntax/URLArgument.html">URLArgument</a></dt>
<dd>
    Similar in some respects to FileArgument, the URLArgument accepts valid tokens that represent a URL. This argument also respects the EXISTING and NONEXISTENT flags. Completion for parts of a url (the scheme for example), may be able to complete, but actual URL completion of domain names and the like may be nearly impossible. It should also be noted that the EXISTING and NONEXISTENT flags will likely cause a DNS lookup to be performed,<br/>
  </dd>
</dl>
</div>
<div id="node-3030" class="section-4">
<h1 class="book-heading">Syntax -  Defining Commands</h1>
<p>The syntax of a command is the definition of options, symbols and arguments that are accepted by commands. Each command defines its own syntax, allowing customization of flags and parameters, as well as defining order. The syntax is constructed using several different mechanisms, which when combined, allow for a great deal of control in restricting what is acceptable in the command line for a given command.</p>
<h2>How it works</h2>
<p>When you define a new command, you must give define a syntax bundle within a syntax extension point. When the plugin is loaded, the syntax bundle is parsed from the descriptor and loaded into the syntax manager. When the bundle is needed, when completing or when preparing for execution, the bundle is retrieved. Because a syntax bundle is immutable, it can be cached completely, and used concurrently.</p>
<p>Also, the help system uses the syntax to create usage statements and to map short &amp; long flags to the description from an argument.</p>
<h2>The puzzle pieces</h2>
<p>See <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2546">this</a> document page for a concise description of the various syntax elements.</p>
<p>When setting out to define the syntax for a command, it is helpful to layout the synopsis and options that the command will need. The synopsis of a command can be used to define separate modes of operation. The syntax block itself is an implied &lt;alternatives&gt;, which means if parsing one fails, the next will be tried. To give an example of how breaking down a command into multiple synopsis can be helpful, we'll setup the syntax for a hypothetical 'config' command that allows listing, setting and clearing of some system configurations.</p>
<p>First, our synopsis...</p>
<pre>config
    Lists all known configuration options and their values
config -l <option>
    Displays the value of the specified option
config -s <option> <value>
    Sets the chosen option to the desired value
config -c <option>
    Clears the value of the chosen option
</pre><p>
And our syntax...</p>
<pre>&lt;syntax alias="config"&gt;
  &lt;empty /&gt;
  &lt;option argLabel="list" shortName="l"&gt;
  &lt;sequence&gt;
    &lt;option argLabel="set" shortName="s"&gt;
    &lt;argument argLabel="value"&gt;
  &lt;/sequence&gt;
  &lt;option argLabel="clear" shortName="c"&gt;
&lt;/syntax&gt;

To be continued...</div>
<div id="node-3015" class="section-4">
<h1 class="book-heading">Utility classes</h1>
<p>The cli project contains a few utility classes to make implementation of common features across multiple commands easier. Because it is recommended that these classes be used when possible, they are quite well documented, and provide fairly specific information on their behavior, and how to use them. A brief outline will be provided here, along with links to the actual javadoc page.</p>
<h2>AbstractDirectoryWalker</h2>
<p>ADW is _the_ tool for doing recursive directory searches. It provides a Visitor pattern interface, with a set of specific callbacks for the implementor to use. It has many options for controlling what it returns, and with the right configuration, can be made to do very specific searching.</p>
<p><b>Control</b></p>
<p>The walker is mainly controlled by <i>FileFilter</i> instances. Multiple filters can be supplied, providing an implied '&amp;&amp;' between each filter. If any of the filters reject the file, then the extending class will not be asked to handle the file. This can be used to create very precise searches by combining multiple boolean filters with specific filter types.</p>
<p>The walker also provides the ability to filter files and directories based on a depth. When the minimum depth is set, files and directories below a given level will not be handled. The directories that are passed to walk() are considered to be at level 0. Therefore setting a min-depth of 0 will not pass those directories to the callbacks. When the maximum depth is set, directories that are at the maximum depth level will not be recursed into. They will however still be passed to the callbacks, pending acceptance by the filter set. Therefore setting a value of 0 to the max level may return the initial directories supplied to walk(), but it will not recurse into them.</p>
<p>Note: Boolean filters are not yet implemented, but they are on the short list.</p>
<p><b>Extending the walker</b></p>
<p>Although you can extend the walker to a class of it's own, the recommended design pattern is to implement the walker as a non-static inner class, or an anonymous inner class. This design gives the implemented callbacks of the walker access to the inner structure of the command it's used in. When the walker runs it will pass accepted files and directories to the appropriate callback methods. The walker also has callbacks for specific events, including the beginning and end of a walk, as well as when a SecurityException is encountered when attempting to access a file or directory.</p>
<dl>
<dt>public abstract void handleFile(File)</dt>
<dd>
    Tells the implementing class that a regular file has been found and accepted.<br/>
  </dd>
<dt>public abstract void handleDir(File)</dt>
<dd>
    Tells the implementing class that a directory has been found and accepted.<br/>
  </dd>
<dt>public void handleSpecialFile(File)</dt>
<dd>
    Tells the implementing class that a file has been found that is neither a directory or a regular file.<br/>
  </dd>
<dt>protected void handleRestrictedFile(File)</dt>
<dd>
    Tells the implementing class that it has found a file that triggered a SecurityException. By default, this method throws an IOException. This will cause walking to completly halt, which is likely undesired, and so it is highly recommended to override this method to provide suitable error message, and optionally continue walking.</p>
<dt>protected void handleStartingDir(File)</dt>
<dd>
    Tells the implementing class that it is about to start walking the file system from the given file. This is triggered before the file itself is actually resolved. So the caller has a chance to do some initialization, like possibly changing the current working directory to make a relative path resolve with a different prefix path.<br/>
  </dd>
<dt>protected void lastAction(boolean)</dt>
<dd>
    Tells the implementing class that walking has finished. If the walker stopped walking because it was requested to do so, then the boolean parameter will be true. Otherwise if the walker finished normally, it will be false.<br/>
  </dd>
</dl>
</div>
</div>
<div id="node-177" class="section-3">
<h1 class="book-heading">Debugging</h1>
<p>Debugging code running on the JNode platform is no easy task.  The platform currently has none of the nice debugging support that you normally find on a mature Java platform; no breakpoints, no looking at object fields, stack frames, etc.</p>
<p>Instead, we typically have to resort to sending messages to the system Logger, adding traceprint statements and calling 'dumpStack' and 'printStackTrace'.  Here are some other pointers:</p>
<ul>
<li>If you are debugging a JNode command, you may be able to use ShellEmu or <a href="/web/20200119030613/http://www.jnode.org/node/2893">TestHarness</a> to run and debug JNode specific code in your development environment.  (This may not work if your command makes use of JNode specific services.)
<li>A lot of classes have no JNode platform dependencies, and can be debugged using JUnit tests running in your development sandbox.
<li>If you are debugging low-level JNode code, you can use "Unsafe.debug(...)" calls and the (so called) <a href="/web/20200119030613/http://www.jnode.org/node/551">Kernel debugger</a> to get trace information without causing object allocation. This is particularly important when debugging the JNode memory management, etc where any object allocation could trigger a kernel panic.
<li>Beware of the effects of adding debug code on JNode system performance, and on timing related bugs; e.g. race conditions.
</ul>
<p>There is also a simple debugger that can be used in textmode to display threads and their stacktraces.  Press <b>Alt-SysRq</b> to enter the debugger and another Alt-SysRq to exit the debugger. Inside the debugger, press 'h' for usage information.</p>
<p><i>Note: the Alt-SysRq debugger isn't working at the moment: see <a href="node/2951">this issue</a>.</i></p>
<div id="node-551" class="section-4">
<h1 class="book-heading">Kernel debugger</h1>
<p>A very simple kernel debugger has been added to the JNode nano-kernel. This debugger is able to send all data outputted to the console (using Unsafe.debug) to another computer via a null-modem cable connected to COM1.</p>
<p>From the other computer you can give simple commands to the debugger, such as dump the processor thread queues and print the current thread.</p>
<p>The kernel debugger can be enabled by adding " kdb" to the grub kernel command line, or by activating it in JNode using a newly added command: "kdb".</p>
<p>Ewout</p>
<div class="forum-topic-navigation clear-block"><a href="/web/20200119030613/http://www.jnode.org/node/2410" class="topic-previous" title="Go to previous forum topic"> Is this a reasonable use of plugin extensions?</a> <a href="/web/20200119030613/http://www.jnode.org/node/2378" class="topic-next" title="Go to next forum topic">explain a bit about GNU classpath </a></div></div>
<div id="node-2595" class="section-4">
<h1 class="book-heading">Using &quot;remoteout&quot; to record console / logger output</h1>
<p>The <i>remoteout</i> command allows you to send a copy of console output and logger output to a remote TCP or UDP receiver.  This allows you to capture console output for bug reports, and in the cases where JNode is crashing.</p>
<p>Before you run the command, you need to set up a receiver application on the remote host to accept and record the output.  More details (including a brief note on the JNode <i>RemoteReceiver</i> application) may be found in the <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2593">remoteout command page</a>.  Please read the Bugs section as well!</p>
</div>
</div>
<div id="node-38" class="section-3">
<h1 class="book-heading">Operating System</h1>
<p>This part contains the technical documentation of the JNode Operating System.</p>
<div id="node-39" class="section-4">
<h1 class="book-heading">Boot and startup</h1>
<p>During the boot process of JNode, the kernel image is loaded by Grub and booted. After the bootstrapper code, we're running plain java code. The fist code executed is in org.jnode.boot.Main#vmMain() which initializes the JVM and starts the plugin system.</p>
</div>
<div id="node-40" class="section-4">
<h1 class="book-heading">Driver framework</h1>
<p>The basic device driver design involves 3 components: </p>
<ul>
<li>
Device: a representation of the actual hardware device
</li>
<li>
Driver: a software driver able to control a Device </li>
<li>
DeviceAPI: a programming interface for a Device, usually implemented by the Driver.</li>
</ul>
<p>There is a DeviceManager where all devices are registered. It delegates to DeviceToDriverMapper instances to find a suitable driver for a given device. Instances of this mapper interface use e.g. the PCI id of a device (in case of PCIDevice) to find a suitable driver. This is configurable via a configuration file. </p>
<p>For a device to operate there are the following resources available: </p>
<ul>
<li>Hardware interrupts. A driver can register an IRQHandler which is called on its own (normal java-) thread. The native kernel signals a hardware interrupt by incrementing a counter for that interrupts, after which the thread scheduler dispatches such events to the correct threads of the IRQHandler's.
</li>
<li>
DMA channels. A driver can claim a DMA channel.<br/>
This channel can be setup, enabled and disabled.
</li>
<li>
IO port access. An Unsafe class has native methods for this. A device must first claim a range of IO ports before it can gain access to it.
</li>
<li>
Memory access. A device can claim a range of the the memory addressspace. A MemoryResource is given to the device. The device can use the methods of the MemoryResource to actually access the memory.
</li>
</ul>
</div>
<div id="node-41" class="section-4">
<h1 class="book-heading">Filesystem framework</h1>
<p>The filesystem support in JNode is split up into a generic part and a filesystem specific part. The role of the generic part is: </p>
<ol>
<li>Keep track of all mounted filesystems.</li>
<li>Map between path names are filesystem entries.</li>
<li>Share filesystem entries between various threads/processes.</li>
</ol>
<p>The role of the filesystem specific part is: </p>
<ol>
<li>Store and retrieve files.</li>
<li>Store and retrieve directories.</li>
</ol>
<p>We should be more specific about what a filesystem is. JNode makes a distinction the a FileSystemType and a FileSystem. A FileSystemType has a name, can detect filesystems of its own type on a device and can create FileSystem instances for a specific device (usually a disk). A FileSystem implements storing/retrieving files and directories. </p>
<p>To access files in JNode, use the regular classes in the java.io package. They are connected to the JNode filesystem implementation. A direct connection to the filesystem implementation is not allowed.</p>
</div>
<div id="node-524" class="section-4">
<h1 class="book-heading">FrameBuffer devices</h1>
<p>This chapter details the FrameBuffer device design and the interfaces involved in the design.</p>
<h2>FrameBufferAPI</h2>
<p>All framebuffer devices must implement this API. </p>
<h2>FrameBufferConfiguration</h2>
<p>TODO write me.</p>
<h2>Surface</h2>
<p>TODO write me.</p>
<h2>HardwareCursorAPI</h2>
<p>TODO write me.</p>
<h2>DisplayDataChannelAPI</h2>
<p>TODO write me.</p>
</div>
<div id="node-525" class="section-4">
<h1 class="book-heading">Network devices</h1>
<p>This chapter details the design of network devices and describe the interfaces involved.</p>
<h2>NetDeviceAPI</h2>
<p>Every network device must implement this API.</p>
<p>The API contains methods to get the hardware address of the device, send data through the device and get/set protocol address information.</p>
<p>When a network deivce receives data, it must deliver that data to the NetworkLayerManager. The AbstractNetworkDriver class (which is usually the baseclass for all network drivers) contains a helper method (onReceive) for this purpose.</p>
</div>
<div id="node-526" class="section-4">
<h1 class="book-heading">Network protocols</h1>
<p>This chapter will detail the interfaces involved in the network protocol layer.</p>
<h2>NetworkLayer</h2>
<p>This interface must be implemented by all network protocol handlers.</p>
<h2>TransportLayer</h2>
<p>This interface must be implemented by OSI transport layer protocols.</p>
<h2>LinkLayer</h2>
<p>This interface must be implemented by OSI link layer protocols.</p>
<h2>Registration</h2>
<p>To register a network layer, the network layer class must be specified in an extension of the "org.jnode.net.networkLayers" extension point.<br/>
This is usually done in the descriptor of the plugin that holds the network layer.</p>
</div>
<div id="node-562" class="section-4">
<h1 class="book-heading">Architecture specifics</h1>
<p>This chapter contains the specific technical operating system details about the various architectures that JNode is operating on.</p>
<div id="node-563" class="section-5">
<h1 class="book-heading">X86 Architecture</h1>
<p>The X86 architecture is targets the Intel IA32 architecture implemented by the Intel Pentium (and up) processors and the AMD Athlon/Duron (etc) processors.</p>
<h2>Physical memory layout</h2>
<p>This architecture uses a physical memory layout as given in the picture below.</p>
<p><img src="/web/20200119030613im_/http://www.jnode.org/images/x86-memory-map.png" title="X86 Memory Map" alt="X86 Memory Map"/></p>
</div>
</div>
</div>
<div id="node-162" class="section-3">
<h1 class="book-heading">Shell</h1>
<div id="node-2546" class="section-4">
<h1 class="book-heading">The new command line syntax mechanism</h1>
<p>In the classical Java world, a command line application is launched by calling the "main" entry point method on a nominated class, passing the user's command arguments as an array of Strings.  The command is responsible for working out which arguments represent options, which represent parameters and so on.  While there are (non-Sun) libraries to help with this task (like the Java version of GNU getOpts), they are rather primitive.</p>
<p>In JNode, we take a more sophisticated approach to the issue of command arguments.  A native JNode command specifies its formal arguments and command line syntax.  The task  of matching actual command line arguments is performed by JNode library classes.  This approach offers a number of advantages over the classical Java approach:</p>
<ul>
<li>The application programmer has less work to do.
<li>The user sees more uniform command syntax.
<li>Diagnostics for incorrect command arguments can be more uniform.
</ul>
<p>In addition, this approach allows us to do some things at the Shell level that are difficult with (for example) UNIX style shells.</p>
<ul>
<li>The JNode shell does intelligent command line completion based on a command's declared syntax and argument types.  For example, if the syntax requires a device name at the cursor position when the user hits <b>TAB</b>, the JNode shell will complete against the device namespace.
<li>The JNode help command uses a command's declared syntax to produce accurate "usage" and parameter type descriptions.  These can be augmented by descriptions embedded in the syntax, or in separate files.
<li>In the new version of the JNode syntax mechanisms, command syntaxes are specified in XML separate from the Java source code.  Users can tailor the command syntax, like UNIX aliases only better.  This can be used to support portable scripting; e.g. Unix-like command syntaxes could be used with a POSIX shell compatible interpreter to run Unix shell scripts.
</ul>
<p>As the above suggests, there are two versions of JNode command syntax and associated mechanisms; i.e parsing, completion, help and so on.  In the first version (the "old" mechanisms) the application class declares a static Argument object for each formal parameter, and creates a static "Help.Info" data structure containing Syntax objects that reference the Arguments.  The command line parser and completer traverse the data structures, binding values to the Arguments.</p>
<p>The problems with the "old" mechanisms include:</p>
<ul>
<li>Use of statics to hold the Argument and Help.Info objects makes JNode commands non-reentrant, leading to unpredictable results when a command is executed in two threads.
<li>The Syntax, Argument and associated classes were never properly documented, making them hard to maintain and hard to use.
<li>There were numerous bugs and implementation issues; e.g. Unix-style named options didn't work, completion didn't work properly with alternative syntaxes, and so on.
<li>Command syntaxes could not be tailored, as described above.
</ul>
<p>The second version (the "new" mechanisms) are a ground-up redesign and reimplementation:</p>
<ul>
<li>Argument objects are created by the command class constructor, and registered to form an ArgumentBundle.  Thus, command syntax is not an impediment to making command classes re-entrant.
<li>Syntax objects are created from XML that is defined in the command's plugin descriptor, and that can be overridden from the JNode shell using the "syntax" command.
<li>The "new" Syntax classes are much richer than the "old" versions.  Each Syntax class has a "prepare" method that emits a simple BNF-like grammar; i.e. the MuSyntax classes.  This grammar is used by the  MuParser which performs n-level backtracking, and supports "normal" and "completion" modes.  (Completion mode parsing works by capturing completions at the appropriate point and then initialing backtracking to find other alternatives.)
</ul>
<div id="node-2836" class="section-5">
<h1 class="book-heading">A worked example: the Cat command.</h1>
<p><i>(This example is based on material provided by gchii)</i></p>
<p>The <b>cat</b> command is a JNode file system command for the concatenation of files.<br/>
The alternative command line syntaxes for the command are as follows:</p>
<pre> cat 
 cat -u | -urls &lt;url&gt; ... |
 cat &lt;file&gt; ... 
</pre><p>
The simplest use of <b>cat</b> is to copy a file to standard output displaying the contents of a file; for example.</p>
<pre> cat d.txt
</pre><p>The following example displays a.txt, followed by b.txt and then c.txt.</p>
<pre> cat a.txt b.txt c.txt
</pre><p>
The following example concatenates a.txt, b.txt and c.txt, writing the resulting file to d.txt.  </p>
<pre> cat a.txt b.txt c.txt &gt; d.txt
</pre><p>In fact, the &gt; output redirection in the example above is performed by the command shell and interpreter, and the "&gt; d.txt" arguments are removed before the command arguments are processed.  As far the command class is concerned, this is equivalent to the previous example.</p>
<p>Finally, the following example displays the raw HTML for the JNode home page:<br/>
 cat --urls http ://www.jnode.org/</p>
<p><i>Syntax specification</i><br/>
The syntax for the <b>cat</b> command is defined in fs/descriptors/org.jnode.fs.command.xml.</p>
<p>The relevant section of the document is as follows:</p>
<pre>   39   &lt;extension point="org.jnode.shell.syntaxes"&gt;
   40     &lt;syntax alias="cat"&gt;
   41       &lt;empty description="copy standard input to standard output"/&gt;
   42       &lt;sequence description="fetch and concatenate urls to standard output"&gt;
   43         &lt;option argLabel="urls" shortName="u" longName="urls"/&gt;
   44         &lt;repeat minCount="1"&gt;
   45           &lt;argument argLabel="url"/&gt;
   46         &lt;/repeat&gt;
   47       &lt;/sequence&gt;
   48       &lt;repeat minCount="1" description="concatenate files to standard output"&gt;
   49         &lt;argument argLabel="file"/&gt;
   50       &lt;/repeat&gt;
   51     &lt;/syntax&gt;
</pre><p>
Line 39: "org.jnode.shell.syntaxes" is an extension point for command syntax.</p>
<p>Line 40: The syntax entity represents the entire syntax for a command. The alias attribute is required and associates a syntax with a command.</p>
<p>Line 41: When parsing a command line, the empty tag does not consume arguments. This is a description of the cat command.</p>
<p>Line 42: A sequence tag represents a group of options and arguments, and others.</p>
<p>Line 43: An option tag is a command line option, such as -u and --urls. Since -u and --urls are actually one and the same option, the argLable attribute identifies an option internally.</p>
<p>Line 44: An option might be used more than once on a command line. When minCount is one or more, an option is required.</p>
<p>Line 45: An argument tag consumes one command line argument.</p>
<p>Line 48: When minCount is 1, an option is required.</p>
<p>Line 49: An argument tag consumes one command line argument.</p>
<p>The <b>cat</b> command is implemented in CatCommand.java.  The salient parts of the command's implementation are as follows.</p>
<pre>   54     private final FileArgument ARG_FILE =
   55         new FileArgument("file", Argument.OPTIONAL | Argument.MULTIPLE,
   56                 "the files to be concatenated");
</pre><p>
This declares a formal argument to capture JNode file/directory pathnames from the command line; see the specification of the org.jnode.shell.syntax.FileArgument. The "Argument.OPTIONAL | Argument.MULTIPLE" parameter gives the argument flags. Argument.OPTIONAL means that this argument may be optional in the syntax.  The Argument.MULTIPLE means that the argument may be repeated in the syntax.  Finally, the "file" label matches the "file" attribute in the XML above at line 49.</p>
<pre>   58     private final URLArgument ARG_URL =
   59         new URLArgument("url", Argument.OPTIONAL | Argument.MULTIPLE,
   60                 "the urls to be concatenated");
</pre><p>
This declares a formal argument to capture URLs from the command line.  This matches the "url" attribute in the XML above at line 45.</p>
<pre>   62     private final FlagArgument FLAG_URLS =
   63         new FlagArgument("urls", Argument.OPTIONAL, "If set, arguments will be urls");
</pre><p>
This declares a formal flag that matches the "urls" attribute in the XML above at line 43.</p>
<pre>   67     public CatCommand() {
   68         super("Concatenate the contents of files, urls or standard input to standard output");
   69         registerArguments(ARG_FILE, ARG_URL, FLAG_URLS);
   70     }
</pre><p>
The constructor for the CatCommand registers the three formal arguments, ARG_FILE, ARG_URL and FLAG_URLS. The registerArguments() method is implemented in AbstractCommand.java.  It simply adds the formal arguments to the command's ArgumentBundle, making them available to the syntax mechanism.</p>
<pre>   79     public void execute() throws IOException {
   80         this.err = getError().getPrintWriter();
   81         OutputStream out = getOutput().getOutputStream();
   82         File[] files = ARG_FILE.getValues();
   83         URL[] urls = ARG_URL.getValues();
   84 
   85         boolean ok = true;
   86         if (urls != null &amp;&amp; urls.length &gt; 0) {
   87             for (URL url : urls) {
   ...
  107         } else if (files != null &amp;&amp; files.length &gt; 0) {
  108             for (File file : files) {
   ...
  127         } else {
  128             process(getInput().getInputStream(), out);
  129         }
  130         out.flush();
  131         if (!ok) {
  132             exit(1);
  133         }
  134     }
</pre><p>
The "execute" method is called after the syntax processing has occurred, and after the command argument values have been converted to the relevant Java types and bound to the formals.  As the code above shows, the method uses a method on the formal argument to retrieve the actual values.  Other methods implemented by AbstractCommand allow the "execute" to access the command's standard input, output and error streams as Stream objects or Reader/Writer objects, and to set the command's return code.</p>
<p>Note: ideally the syntax of the JNode cat command should include this alternative:</p>
<pre> cat ( ( -u | -urls &lt;url&gt; ) | &lt;file&gt; ) ...
</pre><p>or even this:</p>
<pre> cat ( &lt;url&gt; | &lt;file&gt; ) ...
</pre><p>allowing &lt;file&gt; and &lt;url&amp;gt arguments to be interspersed.  The problem with the first alternative syntax above is that the Argument objects do not allow the syntax to capture the complete order of the interspersed &lt;file&gt; and &lt;url&gt; arguments.  In order to support this, we would need to replace ARG_FILE and ARG_URL with a suitably defined ARG_FILE_OR_URL.  The problem with the second alternative syntax above is some legal &lt;url&gt; values are also legal &lt;file&gt; values, and the syntax does not allow the user to control the disambiguation.</p>
<p>For more information, see also org.jnode.fs.command.xml - <a href="https://web.archive.org/web/20200119030613/https://jnode.svn.sourceforge.net/viewvc/jnode/trunk/fs/descriptors/org.jnode.fs.command.xml?view=markup" title="http://jnode.svn.sourceforge.net/viewvc/jnode/trunk/fs/descriptors/org.jnode.fs.command.xml?view=markup">http://jnode.svn.sourceforge.net/viewvc/jnode/trunk/fs/descriptors/org.j...</a> .</p>
<p>CatCommand.java - <a href="https://web.archive.org/web/20200119030613/https://jnode.svn.sourceforge.net/viewvc/jnode/trunk/fs/src/fs/org/jnode/fs/command/CatCommand.java?view=markup" title="http://jnode.svn.sourceforge.net/viewvc/jnode/trunk/fs/src/fs/org/jnode/fs/command/CatCommand.java?view=markup">http://jnode.svn.sourceforge.net/viewvc/jnode/trunk/fs/src/fs/org/jnode/...</a></p>
</div>
<div id="node-2627" class="section-5">
<h1 class="book-heading">Ideas for future Syntax enhancements</h1>
<p>Here are some ideas for work to be done in this area:</p>
<ul>
<li>Extend OptionSetSyntax to support "--" as meaning everything after here is not an option.
<li>Make OptionSetSyntax smarter in its handling of repeated options.  For example completing "cp --recursive " should not offer "--recursive" as a completion.
<li>Improve "help", including improving the output, incorporating more descriptions from the syntax, in preference to descriptions from the Command class, and supporting multi-lingual descriptions.  (In fact, we need to go a lot further ... including supporting <i>full</i> documentation complete with a way to specify markup and cross-references.  But that's a different problem really.)
<li>Extend the Argument APIs so that we can specify (for example) that a FileArgument should match an existing file, an existing directory, a path to an object that does not exist, etc.  This potentially applies to all name arguments over dynamic namespaces.
<li>Extend the Argument APIs to support expansion of patterns against the FS and other namespaces.  This needs to be done in a way that allows the user, shell and command to control whether or not expansion occurs.  We don't want commands to have to understand that there are patterns at all .... except in cases where the command needs to know (e.g. some flavours of rename command).  And we also need to cater for shell languages (e.g. UNIX derived ones) where FS pattern expansion is clearly a shell responsibility.
<li>Add support for command-specific Syntax classes; e.g. to support complex command syntaxes like UNIX style "expr" and "test" commands.
<li>Add command syntax support for command-line interactive commands like old-school UNIX ftp and nslookup.  (In JNode, we already have a tftp client that runs this way.)
<li>Implement a compatibility library to allow JNode commands to be executed in the class Java world.
</ul>
</div>
<div id="node-2547" class="section-5">
<h1 class="book-heading">JNode Command and Syntax APIs</h1>
<p>This page is an overview of the JNode APIs that are involved in the new syntax mechanisms.  For more nitty-gritty details, please refer to the relevant javadocs.<br/>
Note:  </p>
<ol>
<li>These APIs still change a bit from time to time.  (But if your code is in the JNode code base, you won't need to deal with these changes.)
<li>The javadocs on the JNode website currently do not include the "shell" APIs.<br/>
You can generate the javadocs in a JNode build sandbox by running "./build.sh javadoc".</p>
<li>If the javadocs are inadequate, please let us know via a JNode "bug" request.
</ol>
<p>Java package structure</p>
<p>The following classes mostly reside in the "org.jnode.shell.syntax" package.  The exceptions are "Command" and "AbstractCommand" which live in "org.jnode.shell".  (Similarly named classes in the "org.jnode.shell.help" and "org.jnode.shell.help.args" packages are part of the old-style syntax support.)</p>
<p><b>Command</b><br/>
The JNode command shell (or more accurately, the command invokers) understand two entry points for launching classes as "commands".  The first entry point is the "public static void main(String[])" entry point used by classic Java command line applications.  When a command class has (just) a "main" method, the shell will launch it by calling the method, passing the command arguments.  What happens next is up to the command class:</p>
<ul>
<li>A non-JNode application will typically deal with the command arguments itself, or using some third party class like "gnu.getopt.GetOpt".
<li>A JNode-aware application can also use the old-style syntax method directly, by calling a "Help.Info" object's "parse(String[])" method on the argument strings.
</ul>
<p>The preferred entry point for a JNode command class is the "Command.execute(CommandLine, InputStream, PrintStream, PrintStream)" method.  On the face of it, this entry point offers a number of advantages over the "main" entry point:</p>
<ul>
<li>The "execute" method provides command's IO streams explicitly, rather than relying on the "System.{in,out,err}" statics.  (Those statics are problematic, unless you are using proclets or isolates.)
<li>The "execute" method gives the application access to more information gleaned from the command line; e.g. the command name (alias) supplied by the user.
</ul>
<p>Unless you are using the "default" command invoker, a command class with an "execute" entry point will be invoked via that entry point, even it it also has a "main" entry point.  What happens next is up to the command class:</p>
<ul>
<li>The "execute" method may fetch the user's argument strings from the CommandLine object and do its own argument analysis.
<li>If the command class is designed to use old-style syntax mechanisms, the "execute" method will typically call the "parse(String[])" method and proceed as described above.
<li>If the command class is designed to use new-style syntax mechanisms, argument analysis will already have been done.  This can only happen if the command class extends the AbstractCommand class; see below.
</ul>
<p><b>AbstractCommand</b></p>
<p>The AbstractCommand class is a base class for JNode-aware command classes.  For command classes that do their own argument processing, or that use the old-stle syntax mechanisms, use of this class is optional.  For commands that want to use the new-style syntax mechanisms, the command class must be a direct or indirect subclass of AbstractCommand.</p>
<p>The AbstractCommand class provides helper methods useful to all command class.  </p>
<ul>
<li>The "exit(int)" method can be called from the command thread terminate command execution with an return code.  This is roughly equivalent to a classic Java application calling "System.exit(int)".
<li>The "getInput()", "getOutput()", "getError()" and "getIO(int)" methods return "CommandIO" instances that can be used to get a command's "standard io" streams as<br/>
Java Input/OutputStream or Reader/Writer objects.
</ul>
<p>The "getCommandLine" method returns a CommandLine instance that holds the command's command name and unparsed arguments.</p>
<p>But more importantly, the AbstractCommand class provides infrastructure that is key to the new-style syntax mechanism.  Specifically, the AbstractCommand maintains an ArgumentBundle for each command instance.  The ArgumentBundle is created when either of the following happens:</p>
<ol>
<li>The child class constructor chains the AbstractCommand(String) constructor.  In this case an (initially) empty ArgumentBundle is created.
<li>The child class constructor calls the "registerArgument(Argument ...)" method.  In this case, an ArgumentBundle is created (if necessary) and the arguments are added to it.
</ol>
<p>If it was created, the ArgumentBundle is populated with argument values <i>before the "execute" method is called</i>.  The existence of an ArgumentBundle determines whether the shell uses old-style or new-style syntax, for command execution and completion.  (Don't try to mix the two mechanisms: it is liable to lead to inconsistent command behavior.)</p>
<p>Finally, the AbstractCommand class provides an "execute(String[])" method.  This is intended to provide a bridge between the "main" and "execute" entry points for situations where a JNode-aware command class has to be executed via the former entry point.  The "main" method should be implemented as follows:</p>
<pre>    public static void main(String[] args) throws Exception {
        new XxxClass().execute(args);
    }
</pre><p>
<b>CommandIO and its implementation classes</b></p>
<p>The CommandIO interfaces and its implementation classes allow commands to obtain "standard io" streams without knowing whether the underlying data streams are byte or character oriented.  This API also manages the creation of 'print' wrappers. </p>
<p><b>Argument and sub-classes</b></p>
<p>The Argument classes play a central place in the new syntax mechanism.  As we have seen above, the a command class creates Argument instances to act as value holders for its formal arguments, and adds them to its ArgumentBundle.  When the argument parser is invoked, traverses the command syntax and binds values to the Arguments in the bundle.  When the command's "execute" entry point is called, the it can access the values bound to the Arguments.</p>
<p>The most important methods in the Argument API are as follows: </p>
<ul>
<li>The "accept(Token)" method is called by the parser when it has a candidate token for the Argument.  If the supplied Token is acceptable, the Argument uses "addValue(...)" to add the Token to its collection.  If it is not acceptable, "SyntaxErrorException" is thrown.
<li>The "doAccept(Token)" abstract method is called by "accept" after it has done the multiplicity checks.  It is required to either return a non-null value, or throw an exception; typically SyntaxErrorException.
</li>
<li>In completion mode, the parser calls the "complete(...)" method to get Argument specific completions for a partial argument.  The "complete" method is supplied a CompletionInfo object, and should use it to record any completions.
<li>The "isSet()", "getValue()" and "getValues()" methods are called by a command class to obtain the value of values bouond to an Argument.
</ul>
<p>The constructors for the descendent classes of Argument provide the following common parameters:</p>
<ul>
<li>The "label" parameter provides a name for the Attribute that is used to bind the Argument to Syntax elements.  It must be unique in the context of the command's ArgumentBundle.
<li>The "flags" parameter specify the Argument's multiplicity; i.e how many values are allowed or required for the Argument.  The allowed flag values are defined in the Argument class.  A well-formed "flags" parameter consists of OPTIONAL or MANDATORY "or-ed" with SINGLE or MULTIPLE.
<li>The "description" parameter gives a default description for the Argument that can be used in "help" messages.
</ul>
<p>The descendent classes of Argument correspond to different kinds of argument.  For example:</p>
<ul>
<li>StringArgument accepts any String value,
<li>IntegerArgument accepts and (in some cases) completes an Integer value,
<li>FileArgument accepts a pathname argument and completes it against paths for existing objects in the file system, and
<li>DeviceArgument accepts a device name and completes it against the registered device names.
</ul>
<p>There are two abstract sub-classes of Argument:</p>
<ul>
<li>EnumArgument accepts values for a given Java enum.
<li>MappedArgument accepts values based on a String to value mapping supplied as a Java Map.
</ul>
<p>Please refer to the javadoc for an up-to-date list of the Argument classes.</p>
<p><b>Syntax and sub-classes</b></p>
<p>As we have seen above, Argument instances are used to specify the command class'es argument requirements.  These Arguments correspond to nodes in one or more syntaxes for the command.  These syntaxes are represented in memory by the Syntax classes.</p>
<p>A typical command class does not see Syntax objects.  They are typically created by loading XML (as specified <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2549">here</a>), and are used by various components of the shell.  As such, the APIs need not concern the application developer. </p>
<p><b>ArgumentBundle</b></p>
<p>This class is largely internal, and a JNode application programmer doesn't need to access it directly.  Its purpose is to act as the container for the new-style Argument instances that belong to a command class instance.</p>
<p><b>MuSyntax and sub-classes</b></p>
<p>The MuSyntax class and its subclasses represent the BNF-like syntax graphs that the command argument parser actually operate on.  These graphs are created by the "prepare" method of new-style Syntax objects, in two stages.  The first stage is to build a tree of MuSyntax objects, using symbolic references to represent cycles.  The second stage is to traverse the tree, replacing the symbolic references with their referents.</p>
<p>There are currently 6 kinds of MuSyntax node:</p>
<ul>
<li>MuSymbol - this denotes a symbol (keyword) in the syntax.  When a MuSymbol is match, no argument capture takes place.
<li>MuArgument - this denotes a placeholder for an Argument in the syntax.  When a MuArgument is encountered, the corresponding Argument's "accept" method is called to see if the current token is acceptable.  If it is, the token is bound to the Argument; otherwise the parser starts backtracking.
<li>MuPreset - this is a variation on a MuArgument in which a "preset" token is passed to the Argument.  Unlike MuArgument and MuSymbol, a MuPreset does not cause the parser to advance to the next token.
<li>MuSequence - this denotes that a list of child MuSyntax nodes must be matches in a given sequence.
<li>MuAlternation - this denotes that a list of child MuSyntax nodes must be tried one at a time in a given order.
<li>MuBackReference - this denotes a reference to an ancestor node in the MuSyntax tree.  These nodes are replaced with their referents before parsing takes place.
</ul>
<p><b>MuParser</b></p>
<p>The MuParser class does the real work of command line parsing.  The "parse" method takes input parameters that provide a MuSyntax graph, a TokenSource and some control parameters.</p>
<p>The parser maintains three stacks:</p>
<ul>
<li>The "syntaxStack" holds the current "productions" waiting to be matched against the token stream.
<li>The "choicePointStack" holds "choicePoint" objects that represent alternates that the parser hasn't tried yet.  The choicepoints also record the state of the "syntaxStack" when the alternation was encountered, and top of the "argsModified" stack.
<li>The "argsModified" stack keeps track of the Arguments that need to be "unbound" when the parser backtracks.
</ul>
<p>In normal parsing mode, the "parse" method matches tokens until either the parse is complete, or an error occurs.  The parse is complete if the parser reaches the end of the token stream and discovers that the syntax stack is also empty.  The "parse" method then returns, leaving the Arguments bound to the relevant source tokens.  The error case occurs when a MuSyntax does not match the current token, or the parser reaches the end of the TokenSource when there are still unmached MuSyntaxes on the syntax stack.  In this case, the parser backtracks to the last "choicepoint" and then resumes parsing with the next alternative.  If no choicepoints are left, the parse fails.</p>
<p>In completion mode, the "parse" method behaves differently when it encounters the end of the TokenSource.  The first thing it does is to attempt to capture a completion; e.g. by calling the current Argument's "complete(...)" method. Then itstarts backtracking to find more completions.  As a result, a completion parse may do a lot more work than a normal parse.</p>
<p>The astute reader may be wondering what happens if the "MuParser.parse" method is applied to a pathological MuSyntax; e.g. one which loops for ever, or that requires exponential backtracking.  The answer is that the "parse" method has a "stepLimit" parameter that places an upper limit on the number of main loop iterations that the parser will perform.  This indirectly addresses the issue of space usage as well, though we could probably improve on this.  (In theory, we could analyse the MuSyntax for common pathologies, but this would degrade parser performance for non-pathological MuSyntaxes.  Besides, we are not (currently) allowing applications to supply MuSyntax graphs directly, so all we really need to do is ensure that the Syntax classes generate well-behaved MuSyntax graphs.)</p>
</div>
<div id="node-2549" class="section-5">
<h1 class="book-heading">Syntax and XML syntax specifications</h1>
<p>As the parent page describes, the command syntax "picture" has two distinct parts.  A command class registers Argument objects with the infrastructure to specify its formal command parameters.  The concrete syntax for the command line is represented in memory by Syntax objects.</p>
<p>This page documents the syntactic constructs provided by the Syntax objects, and the XML syntax that provides the normal way of specifying a syntax.  </p>
<p>You will notice that there can be a number of ways to build a command syntax from the constructs provided.  This is redundancy is intentional.</p>
<p><b>The Syntax base class</b></p>
<p>The Syntax class is the abstract base class for all classes that represent high-level syntactic constructs in the "new" syntax mechanisms.  A Syntax object has two (optional) attributes that are relevant to the process of specifying syntax:</p>
<ul>
<li>The "label" attribute gives a name for the syntax node that will be used when the node is formatted; e.g. for "help" messages.
<li>The "description" attribute gives a basic description for the syntax node.
</ul>
<p>These attributes are represented in an XML syntax element using optional XML attributes named "label" and "description" respectively.</p>
<p><b>ArgumentSyntax</b></p>
<p>An ArgumentSyntax captures one value for an Argument with a given argument label.  Specifically, an ArgumentSyntax instance will cause the parser to consume one token, and to attempt to bind it to the Argument with the specified argument label in the current ArgumentBundle.  </p>
<p>Note that many Arguments are very non-selective in the tokens that they will match.  For example, while an IntegerArgument will accept "123" as valid, so will "FileArgument" and many other Argument classes.  It is therefore important to take account the parser's handling of ambiguity when designing command syntaxes; see below.</p>
<p>Here are some ArgumentSyntax instances, as specified in XML:</p>
<pre>    &lt;argument argLabel="foo"&gt;
    &lt;argument label="foo" description="this controls the command's fooing" argLabel="foo"&gt;
</pre><p>
An EmptySyntax matches absolutely nothing.  It is typically used when a command requires no arguments.  </p>
<pre>    &lt;empty description="dir with no arguments lists the current directory"&gt;
</pre><p>
<b>OptionSyntax</b></p>
<p>An OptionSyntax also captures a value for an Argument, but it requires the value token to be preceded by a token that gives an option "name".  The OptionSyntax class  supports both short option names (e.g. "-f filename") and long option names (e.g. "--file filename"), depending on the constructor parameters.</p>
<pre>    &lt;option argLabel="filename" shortName="f"&gt;
    &lt;option argLabel="filename" longName="file"&gt;
    &lt;option argLabel="filename" shortName="f" longName="file"&gt;
</pre><p>
If the Argument denoted by the "argLabel" is a FlagArgument, the OptionSyntax matches just an option name (short or long depending on the attributes).</p>
<p><b>SymbolSyntax</b></p>
<p>A SymbolSyntax matches a single token from the command line without capturing any Argument value.  </p>
<p><i>&nbsp;&nbsp;&nbsp;&nbsp;&lt;symbol symbol="subcommand1"&gt;</i></p>
<p><b>VerbSyntax</b></p>
<p>A VerbSyntax matches a single token from the command line, setting an associated Argument's value to "true".  </p>
<pre>    &lt;verb symbol="subcommand1" argLabel="someArg"&gt;
</pre><p>
<b>SequenceSyntax</b></p>
<p>A SequenceSyntax matches a list of child Syntaxes in the order specified.</p>
<pre>    &lt;sequence description="the input and output files"&gt;
        &lt;argument argLabel="input"/&gt;
        &lt;argument argLabel="output"/&gt;
    &lt;/sequence&gt;
</pre><p>
<b>AlternativesSyntax</b></p>
<p>An AlternativesSyntax matches one of a list of alternative child Syntaxes.  The child syntaxes are tried one at a time in the order specified until one is found that matches the tokens.</p>
<pre>    &lt;alternatives description="specify an input or output file"&gt;
        &lt;option shortName="i" argLabel="input"/&gt;
        &lt;option shortName="o" argLabel="output"/&gt;
    &lt;/alternatives&gt;
</pre><p>
<b>RepeatSyntax</b></p>
<p>A RepeatSyntax matches a single child Syntax repeated a number of times.  By default, any number of matches (including zero) will satisfy a RepeatSyntax.  The number of required and allowed repetitions can be constrained using the "minCount" and "maxCount" attributes. The default behavior is to match lazily; i.e. to match as few instances of the child syntax as is possible.  Setting the attribute <i>eager="true"</i> causes the powerset to match as many child instances as possible, within the constraints of the "minCount" and "maxCount" attributes.</p>
<pre>    &lt;repeat description="zero or more files"&gt;
        &lt;argument argLabel="file"/&gt;
    &lt;/repeat&gt;

    &lt;repeat minCount="1" description="one or more files"&gt;
        &lt;argument argLabel="file"/&gt;
    &lt;/repeat&gt;

    &lt;repeat maxCount="5" eager="true" 
              description="as many files as possible, up to 5"&gt;
        &lt;argument argLabel="file"/&gt;
    &lt;/repeat&gt;
</pre><p>
<b>OptionalSyntax</b></p>
<p>An OptionalSyntax <i>optionally</i> matches a sequence of child Syntaxes; i.e. it matches nothing or the sequence.  The default behavior is to match lazily; i.e. to try the "nothing" case first.  Setting the attribute <i>eager="true"</i> causes the "nothing" case to be tried second.</p>
<pre>    &lt;optional description="nothing, or an input file and an output file"&gt;
        &lt;argument argLabel="input"/&gt;
        &lt;argument argLabel="output"/&gt;
    &lt;/optional&gt;

    &lt;optional eager="true"
                 description="an input file and an output file, or nothing"&gt;
        &lt;argument argLabel="input"/&gt;
        &lt;argument argLabel="output"/&gt;
    &lt;/optional&gt;
</pre><p>
<b>PowerSetSyntax</b></p>
<p>A PowerSetSyntax takes a list of child Syntaxes and matches any number of each of them in any order or any interleaving.  The default behavior is to match lazily; i.e. to match as few instances of the child syntax as is possible.  Setting the attribute <i>eager="true"</i> causes the powerset to match as many child instances as possible.</p>
<pre>    &lt;powerSet description="any number of inputs and outputs"&gt;
        &lt;option argLabel="input" shortName="i"/&gt;
        &lt;option argLabel="output" shortName="o"/&gt;
    &lt;/powerSet&gt;
</pre><p>
<b>OptionSetSyntax</b></p>
<p>An OptionSetSyntax is like a PowerSetSyntax with the restriction that the child syntaxes must all be OptionSyntax instances.  But what OptionSetSyntax different is that it allows options for FlagArguments to be combined in the classic Unix idiom; i.e. "-a -b" can be written as "-ab".</p>
<pre>    &lt;optionSet description="flags and value options"&gt;
        &lt;option argLabel="flagOne" shortName="1"/&gt;
        &lt;option argLabel="flagTwo" shortName="2"/&gt;
        &lt;option argLabel="argThree" shortName="3"/&gt;
    &lt;/optionSet&gt;
</pre><p>
Assuming that the "flagOne" and "flagTwo" correspond to FlagArguments, and "argThree" corresponds to (say) a FileArgument, the above syntax will match any of the following:  "-1 -2 -3 three", "-12 -3 three", "-1 -3 three -1", "-3 three" or even an empty argument list.</p>
<p><b>The &lt;syntax ... &gt; element</b></p>
<p>The outermost element of an XML Syntax specification is the &lt;syntax&gt; element.  This element has a mandatory "alias" attribute which associates the syntax with an alias that is in force for the shell.  The actual syntax is given by the &lt;syntax&gt; element's zero or more child elements.  These must be XML elements representing Syntax sub-class instances, as described above.  Conceptually, each of the child elements represents an alternative syntax for the command denoted by the alias.</p>
<p>Here are some examples of complete syntaxes:</p>
<pre>    &lt;syntax alias="cpuid"&gt;
        &lt;empty description="output the computer's id"&gt;
    &lt;/syntax&gt;

    &lt;syntax alias="dir"&gt;
        &lt;empty description="list the current directory"/&gt;
        &lt;argument argLabel="directory" description="list the given directory"/&gt;
    &lt;/syntax&gt;
</pre><p>
<b>Ambiguous Syntax specifications</b></p>
<p>If you have implemented a language grammar using a parser generator (like Yacc, Bison, AntLR and so on), we will recall how the parser generator could be very picky about your input grammar.  For example, these tools will often complain about "shift-reduce" or "reduce-reduce" conflicts.  This is a parser generator's way of saying that the grammar appears (to it) to be ambiguous.</p>
<p>The new-style command syntax parser takes a different approach.  Basically, it does not care if a command syntax supports multiple interpretations of a command line.  Instead, it uses a simple runtime strategy to resolve ambiguity: the first complete parse "wins".</p>
<p>Since the syntax mechanisms don't detect ambiguity, it is up to the syntax designer to be aware of the issue, and take it into account when designing the syntax.  Here is an example:</p>
<pre>    &lt;alternatives&gt;
        &lt;argument argLabel="number"&gt;
        &lt;argument argLabel="file"&gt;
    &lt;/alternatives&gt;
</pre><p>
Assuming that "number" refers to an IntegerArgument, and "file" refers to a FileArgument, the syntax above is actually ambiguous.  For example, a parser could in theory bind "123" to the IntegerArgument or the FileArgument.  In practice, the new-style command argument parser will pick the first alternative that gives a complete parse, and bind "123" to the IntegerArgument.  If you (the syntax designer) don't want this (e.g. because you want the command to work for all legal filenames), you will need to use OptionSyntax or TokenSyntax or something else to allow the end user to force a particular interpretation.</p>
<p><b>SyntaxSpecLoader and friends</b></p>
<p><b>More about the Syntax base class.</b></p>
<p>If you are planning on defining new sub-classes of Syntax, the two key behavioral methods that must be implemented are as follows:</p>
<ul>
<li>The "prepare" method is responsible for translating the syntax node into the MuSyntax graph that will be used by the parser.  This will typically be produced by  preparing any child syntaxes, and assembling them using the appropriate MuSyntax constructors.  If the syntax entails recursion at the MuSyntax levels, this will initially be expressed using MuBackReferences.  The recursion points will then transformed into graph cycles by calling "MuSyntax.resolveBackReferences()".<br/>
Another technique that can be used is to introduce "synthetic" Argument nodes with special semantics.  For example, the OptionSetSyntax uses a special Argument class to deal with combined short options; e.g. where "-a -b" is expressed as "-ab".</p>
<li>The "format" method renders the Syntax in a form that is suitable for "usage" messages.
<li>The "toXML" method creates a "nanoxml.XMLElement" that expresses this Syntax node in XML form.  It is used by the "SyntaxCommand" class when it dumps an syntax specification as text.  It is important that "toXML" produces XML that is compatible with the SyntaxSpecLoader class; see below.
</ul>
</div>
</div>
<div id="node-158" class="section-4">
<h1 class="book-heading">Using Command Line Completion (old syntax mechanism)</h1>
<p>
<i>Note: this page describes the old syntax mechanism which is currently being phased out.  Please refer to the parent menu for the pages on the new syntax mechanism.</i>
</p>
<p>
The JNode Command Line Completion is one of the central aspects of the shell. JNode makes use of a sophisticated object model to declare command line arguments. This also provides for a standard way to extract a help-document that can be viewed by the user in different ways. Additionally, the very same object model can be used to access the arguments in a convenient manner, instead of doing the 133735th command line parsing implementation in computer history.
</p>
<p>
The following terms play an important role in this architecture:</p>
<ul>
<li><b>Parameter</b><br/>
    A key that can be passed to a programm. Typically, this are command line switches like "-h" or "--help", or indicators for the type of the assigned argument.
  </li>
<li><b>Argument</b><br/>
    A value that can be passed to a program. This can be filenames, free texts, integers or whatever type of arguments the program needs.
  </li>
<li><b>Syntax</b><br/>
    A program can define multiple Syntaxes, which provide for structurally different tasks it can handle. A Syntax is defined as a collection of mandatory and optional Parameters.
  </li>
</ul>
</p>
<div id="node-159" class="section-5">
<h1 class="book-heading">A sample command</h1>
<p>
The command used in this document is a ZIP-like command. I will call it <b>sip</b>. It provides for a variety of different parameter types and syntaxes.
</p>
<p>
The sip command,in this example, will have the following syntaxes:<br/>
<br><br/>
sip -c [-password &lt;password&gt;] [-r] &lt;sipfile&gt; [&lt;file&gt; ...]<br><br/>
sip -x [-password &lt;password&gt;] &lt;sipfile&gt; [&lt;file&gt; ...]<br></p></p>
<p>
Named Parameters:</p>
<ul>
<li>-c: compress directory contents to a sipfile</li>
<li>-x: extract a sipfile</li>
<li>-r: recurse through subdirectories</li>
</ul>
</p>
<p>
Arguments:</p>
<ul>
<li>password: the password for the sipfile</li>
<li>sipfile: the sipfile to perform the operation on</li>
<li>file: if given, only includes the files in this list</li>
</ul>
</p>
</div>
<div id="node-160" class="section-5">
<h1 class="book-heading">Declaring Arguments and Parameters</h1>
<p>
Let's set some preconditions, which will be of importance in the following chapters.
<ul>
<li>we will put the command into the package org.jnode.tools.command</li>
<li>the actual java implementation of the packager are found in org.jnode.tools.sip</li>
</ul>
</p>
<p>
Therefore, the first lines of out Command class look like this:<br><br/>
<br><br/>
package org.jnode.tools.command;<br><br/>
<br><br/>
import org.jnode.tools.sip.*;<br><br/>
import org.jnode.shell.Command;<br><br/>
import org.jnode.shell.CommandLine;<br><br/>
import org.jnode.shell.help.*;<br><br/>
<br><br/>
public class SipCommand implements Command{<br><br/>
<br><br/>
After importing the necessary packages, let's dive into the declaration of the Arguments. This is almost necessarily the first step when you want to reuse arguments. Good practise is to always follow this pattern, so you don't have to completely rework the declaration sometime. In short, we will work above definition from bottom up.<br><br/>
You will note that all Arguments, Parameters and Syntaxes will be declared as static. This is needed because of the inner workings of the Command Line Completion, which has to have access to a static HELP_INFO field providing all necessary informations.<br><br/>
<br><br/>
  static StringArgument ARG_PASSWORD = new StringArgument("password", "the password for the sipfile");<br><br/>
  static FileArgument ARG_SIPFILE = new FileArgument("sipfile", "the sipfile to perform the operation on");<br><br/>
  static FileArgument ARG_FILE = new FileArgument("file", "if given, only includes the files in this list", Argument.MULTI);<br><br/>
<br><br/>
Now we can declare the Parameters, beginning with the ones taking no Arguments.<br><br/>
<b>Note: </b>all Parameters are optional by default!<br><br/>
<br><br/>
  // Those two are mandatory, as we will define the two distinct syntaxes given above<br><br/>
  static Parameter PARAM_COMPRESS = new Parameter(<br><br/>
    "c", "compress directory contents to a sipfile", Parameter.MANDATORY);<br><br/>
  static Parameter PARAM_EXTRACT = new Parameter(<br><br/>
    "x", "extract a sipfile", Parameter.MANDATORY);<br><br/>
<br><br/>
  static Parameter PARAM_RECURSE = new Parameter(<br><br/>
    "r", "recurse through subdirectories");<br><br/>
<br><br/>
  static Parameter PARAM_PASSWORD = new Parameter(<br><br/>
    "password", "use a password to en-/decrypt the file", ARG_PASSWORD);<br><br/>
<br><br/>
  // here come our two anonymous Parameters used to pass the files<br><br/>
  static Parameter PARAM_SIPFILE = new Parameter(<br><br/>
    ARG_SIPFILE, Parameter.MANDATORY);<br><br/>
  static Parameter PARAM_FILE = new Parameter(<br><br/>
    ARG_FILE);<br></p></p>
<p>
<b>Wait!</b><br><br/>
There is something special about the second Syntax, the extract one. The command line completion for this one will fail, as it will try to suggest files that are in the current directory, not in the sipfile we want to extract from. We will need a special type of Argument to provide a convenient completion, along with an extra Parameter which uses it.
</p>
</div>
</div>
</div>
<div id="node-2892" class="section-3">
<h1 class="book-heading">Test frameworks</h1>
<p>Whenever you add some new functionality to JNode, please considering implementing some test code to exercise it.</p>
<p>Your options include:</p>
<ul>
<li>implementing JUnit tests for exercising self-contained JNode-specific library classes,
<li>implementing Mauve tests for JNode implementations of standard library classes,
<li>implementing black-box command tests using the org.jnode.test.harness.* framework, or
<li>implementing ad-hoc test classes.
</ul>
<p>We have a long term goal to be able to run all tests automatically on the new test server.  New tests should be written with this in mind.</p>
<div id="node-2893" class="section-4">
<h1 class="book-heading">Black-box command tests with TestHarness</h1>
<p><b><u>Overview</u></b></p>
<p>This page gives some guidelines for specifying "black-box tests" to be run using the TestHarness class; see <a href="/web/20200119030613/http://www.jnode.org/node/2888">Running black-box tests</a>".  </p>
<p>A typical black-box test runs a JNode command or script with specified inputs, and tests that its outputs match the outputs set down by the test specification.  Examples set specification may be found in the "Shell" and "CLI" projects in the respective "src/test" tree; look for files named "*-tests.xml".</p>
<p><b><u>Syntax for test specifications</u></b></p>
<p>Let's start with a simple example.  This test runs "ExprCommand" command class with the arguments "1 + 1", and checks that it writes "2" to standard output and sets the return code to "0".</p>
<pre>&lt;testSpec title="expr 1 + 1" command="org.jnode.shell.command.posix.ExprCommand"
             runMode="AS_ALIAS" rc="0"&gt;
  &lt;arg&gt;1&lt;/arg&gt;
  &lt;arg&gt;+&lt;/arg&gt;
  &lt;arg&gt;1&lt;/arg&gt;
  &lt;output&gt;2
&lt;/output&gt;
&lt;/testSpec&gt;
</pre><p>
Notes:</p>
<ol>
<li>The odd indentation of the closing "output" tag is is not a typo.  This element is specifying that the output should consists of a "2" followed by a newline.  If the closing tag was indented, the test would "expect" a couple of extra space characters after the newline, and this would cause a spurious test failure.
<li>Any literal '&lt;', '&gt;' and '&amp;' characters in the XML file must be suitably "escaped"; e.g. using XML character entities;
</ol>
<p>An "testSpec" element and its nested elements specifies a single test.  The elements and attributes are as follows:</p>
<dl>
<dt>"title" (mandatory attribute)</p>
<dd> gives a title for the test to identify it in test reports.</p>
<dt>"command" (mandatory attribute)</p>
<dd>gives the command name or class name to be used for the command / script.</p>
<dt>"runMode" (optional attribute)</p>
<dd>says whether the test involves running a command alias or class ("AS_ALIAS") in the same way as the JNode CommandShell would do, running a script ("AS_SCRIPT"), or executing a class via its 'main' entry point ("AS_CLASS").  The default for "runMode" is "AS_ALIAS".</p>
<dt>"rc" (optional attribute)</p>
<dd>gives the expected return code for the command.  The default value is "0".  Note that the return code cannot be checked when the "runMode" is "AS_CLASS".</p>
<dt>"trapException" (optional attribute)</p>
<dd>if present, this is the fully qualified classname of an exception.  If the test throws this exception or a subtype, the exception will be trapped, and the harness will proceed to check the test's post-conditions.".</p>
<dt>"arg" (optional repeated elements)</p>
<dd>these elements gives the "command line" arguments for the command.  If they are omitted, no arguments are passed.</p>
<dt>"script" (conditional element)</p>
<dd>if "runMode" is "AS_SCRIPT", this element should contain the text of the script to be executed.  The first line should probably be "#!&lt;interpreter-name&gt;". </p>
<dt>"input" (optional element)</p>
<dd>this gives the character sequence that will be available as the input stream for the command.  If this element is absent, the command will be given an empty input stream. </p>
<dt>"output" (optional element)</p>
<dd>this gives the expected standard output contents for the command.  If this element is absent, nothing is expected to be written to standard output. </p>
<dt>"error" (optional element)</p>
<dd>this gives the expected standard error contents for the command.  If this element is absent, nothing is expected to be written to standard error.  </p>
<dt>"file" (optional repeating element)</p>
<dd>this gives an input or output file for the test, as described below.<br/>
</dl>
<p><b><u>Syntax for "file" elements</u></b></p>
<p>A "file" element specifies an input or output file for a test.  The attributes and content<br/>
are as follows:</p>
<dl>
<dt>"name" (mandatory attribute)</p>
<dd> gives the file name.  This must be relative, and will be resolved relative to the test's temporary directory.</p>
<dt>"input" (optional attribute)</p>
<dd> if "true", the element's contents will be written to a file, then made available for the test or harness to read,  If "false", the element's contents will be checked against the contents of the file after the test has run.</p>
<dt>"directory" (optional attribute)</p>
<dd> if "true", the file denotes a directory to be created or checked.  In this case, the "file" element should have no content.<br/>
</dl>
<p><b><u>Script expansion</u></b></p>
<p>Before a script is executed, it is written to a temporary directory.  Any @<template class="__cf_email__" data-cfemail="abffeee6fbf4efe2f9eb">[email&#160;protected]</template> sequence in the script will be replaced with the name of the directory where input files are created and where output files are expected to appear.</p>
<p><b><u>Syntax for test sets</u></b></p>
<p>While the test harness can handle XML files containing a single &lt;testSpec&gt; element, it is more convenient to assemble multiple tests into a test set.  Here is a simple example:</p>
<pre>&lt;testSet title="expr tests""&gt;
  &lt;include setName="../somewhere/more-tests.xml"/&gt;
  &lt;testSpec title="expr 1 + 1" ...&gt;
...
  &lt;/testSpec&gt;
  &lt;testSpec title="expr 2 * 2" ...&gt;
...
  &lt;/testSpec&gt;
&lt;/testSet&gt;
</pre><p>
The "include" element declares that the tests in another test set should be run as part of this one.  If the "setName" is relative, it will be resolved relative to this testSet's parent directory.  The "testSpec" elements specify tests that are part of this test set.</p>
<p><b><u>Plugin handling</u></b></p>
<p>As a general rule, JNode command classes amd aliases are defined in plugins.  When the test harness is run, it needs to know which plugins need to be loaded or the equivalent if we are running on the development platform.  This is done using "plugin" elements; for example:</p>
<pre>  ...
  &lt;plugin id="org.jnode.shell.bjorne"
             class="org.jnode.test.shell.bjorne.BjornePseudoPlugin"/&gt;
  &lt;plugin id="org.jnode.shell.command.posix"/&gt;
  ...
</pre><p>
These elements may be child elements of both "testSpec" or "testSet" elements.  A given plugin may be specified in more than one place, though if a plugin is specified differently in different places, the results are undefined.  If a "plugin" element is in a "testSpec", the plugin will be loaded before the test is run.  If a "plugin" element is in a "testSet", the plugin will be loaded before any test in the set, as well as any test that are "included".</p>
<p>The "plugin" element has the following attributes:</p>
<dl>
<dt>"id" (mandatory attribute)</p>
<dd>gives the identifier of the plugin to be loaded.</p>
<dt>"version" optional attribute)</p>
<dd>gives the version string for the plugin to be loaded.  This defaults to JNode's default plugin version string.</p>
<dt>"class" optional attribute)</p>
<dd>gives the fully qualified class name for a "pseudo-plugin" class; see below.<br/>
</dl>
<p>When the test harness is run on JNode, a "plugin" element causes the relevant Plugin to be loaded via the JNode plugin manager, using the supplied plugin id and the supplied (or default) version string.</p>
<p>When the test harness is run outside of JNode, the Emu is used to provide a minimal set of services.  Currently, this does not include a plugin manager, so JNode plugins cannot be loaded in the normal way.  Instead, a "plugin" element triggers the following:</p>
<ol>
<li>The plugin descriptor file is located and read to extract any aliases and command syntaxes.  This information is added to Emu's alias and syntax managers.
<li>If the "plugin" element includes a "class" attribute, the corresponding class is loaded and the default constructor is called.  This provides a "hook" for doing some initialization that would normally be done by the real Plugin.  For example, the "plugin" in the bjorne tests use the "BjornePseudoPlugin" class to registers the interpreter with the shell services.  (This is normally done by "BjornePlugin".)
</ol>
</div>
</div>
<div id="node-29" class="section-3">
<h1 class="book-heading">Virtual Machine</h1>
<p>This part contains the technical documentation of the JNode virtual machine.</p>
<div id="node-32" class="section-4">
<h1 class="book-heading">Arrays</h1>
<p>Arrays are allocated just like normal java objects. The number of elements of the array is stored as the first (int) instance variable of the object. The actual data is located just after this length field. </p>
<p>Bytecodes that work on arrays are do the index checking. E.g. on the X86 this is implemented using the bound instruction.</p>
</div>
<div id="node-30" class="section-4">
<h1 class="book-heading">Classes &amp; Objects</h1>
<p>Each class is represented by an internal structure of class information, method information and field information. All this information is stored in normal java objects. </p>
<p>Every object is located somewhere in the heap. It consists of an object header and space for instance variables.</p>
</div>
<div id="node-35" class="section-4">
<h1 class="book-heading">Exceptions</h1>
<p>At the start of each method invocation a frame for that method is created on the stack. This frame contains references to the calling frame and contains a magic number that is used to differentiate between compiled code invocations and interpreted invocations.<br/>
When an exception is thrown, the exception table of the current method is inspected. When an exception handler is found, the calculation stack is cleaned and code executing continues at the handler address.<br/>
When no suitable exception handler is found in the current method, the stackframe of the current method is destroyed and the process continues at the calling method. </p>
<p>When stacktrace of an exception is created from the frames of each method invocation. A class called VmStackFrame has exactly the same layout as a frame on the stack and is used to enumerate all method-invcocations.</p>
</div>
<div id="node-33" class="section-4">
<h1 class="book-heading">Garbage collection</h1>
<p>JNode uses a simple mark&amp;sweep collector. You can read on the differences, used terms and some general implementation details at <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">wikipedia</a>. In these terms JNode uses a non-moving stop-the-world conservative garbage collector.</p>
<p>About the JNode memory manager you should know the following: There is org.jnode.vm.memmgr.def.VmBootHeap. This class manages all objects that got allocated during the bootimage creation.  VmDefaultHeap contains objects allocated during runtime. Each Object on the heap has a header that contains some extra information about the heap. There's information about the object's type, a reference to a monitor (if present) and the object's color (see wikipedia). JNode objects can have one of 4 different colors and one extra finalization bit. The values are defined in org.jnode.vm.classmgr.ObjectFlags.</p>
<p>At the beginning of a gc cycle all objects are either WHITE (i.e. not visited/newly allocated) or YELLOW (this object is awaiting finalization).</p>
<p>The main entry point for the gc is org.jnode.vm.memmgr.def.GCManager#gc() which triggers the gc run. As you can see one of the first things in gc() is a call to "helper.stopThreadsAtSafePoint();" which stops all threads except the garbace collector. The collection then is divided into 3 phases: markHeap, sweep and cleanup. The two optional verify calls at the beginning and end are used for debugging, to watch if the heap is consistent.</p>
<p>The mark phase now has to mark all reachable objects. For that JNode uses org.jnode.vm.memmgr.def.GCStack (the so called mark stack) using a breadth-first search (BFS) on the reference graph. At the beginning all roots get marked where roots are all references in static variables or any reference on any Thread's stack. Using the visitor pattern the Method org.jnode.vm.memmgr.def.GCMarkVisitor#visit get called for each object. If the object is BLACK (object was visited before and all its children got visited. Mind: This does <b>not</b> mean that the children's children got visited!) we simply return and continue with the next reference in the 'root set'. If the object is GREY (object got visited before, but not all children) or in the 'root set' the object gets pushed on the mark stack and mark() gets called.<br/>
Let's make another step down and examine the mark() method. It first pops an Object of the mark stack and trys to get the object type. For all children (either references in Object arrays or fields of Objects) the processChild gets called and each WHITE (not visited yet) object gets modified to be GREY. After that the object gets pushed on the mark stack. It is important to understand at that point that the mark stack might overflow! If that happens the mark stack simply discards the object to push and remembers the overflow. Back at the mark method we know one thing for sure: All children of the current object are marked GREY (or even BLACK from a previous mark()) and this is even true if the mark stack had an overflow. After examining the object's Monitor and TIB it can be turned BLACK.<br/>
Back at GCManager#markHeap() we're either finished with marking the object or the mark stack had an overflow. In the case it had an overflow we have to repeat the mark phase. Since many objects now are allready BLACK it is less likly the stack will overflow again but there's one important point to consider: All roots got marked BLACK but as said above not all children's children need to be BLACK and might be GREY or even WHITE. That's why we have to walk all heaps too in the second iteration.<br/>
At the end of the mark phase all objects are either BLACK (reachable) or WHITE (not reachable) so the WHITE ones can be removed.</p>
<p>The sweep again walks the heap (this time without the 'root set' as they do not contain garbage by definition) and again visits each object via org.jnode.vm.memmgr.def.GCSweepVisitor#visit. As WHITE objects are not reachable anymore it first tests if the object got previously finalized. If it was it will be freed, if not and the object has a Finalizer it will be marked YELLOW (Awaiting finalization) else it will be freed too. If the object is neither WHITE nor YELLOW it will be marked WHITE for the next gc cycle.</p>
<p>The cleanup phase at the end sets all objects in the bootHeap to WHITE (as they will not be swept above) as they might be BLACK and afterwards calls defragment() for every heap.</p>
<p><b>Some other thoughts regarding the JNode implementation include:</b></p>
<p>It should be also noted that JNode does not know about the stack's details. I.e. if the mark phase visits all objects of a Thread's stack it never knows for a value if it is a reference or a simple int,float,.. value. This is why the JNode garbage collector can be called conservative. Every value on the stack might be a reference pointing to a valid object. So even if it is a float on the stack, as we don't know for sure we have to visit the object and run a mark() cycle. This means on the one hand that we might mark memory as reachable that in reality is garbage on the other hand it means that we might point to YELLOW objects from the stack. As YELLOW objects are awaiting finalization (and except the case the finalizer will reactivate the object) they are garbage and so they can not be in the 'root set' (except the case where we have a random value on the stack that we incorrectly consider to be a reference). This is also the reason for the current "workaround" in GCMarkVisitor#visit() where YELLOW objects in the 'root set' trigger error messages instead of killing JNode.</p>
<p>There is some primilary code for <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Write_barrier">WriteBarrier</a> support in JNode. This is a start to make the gc concurrent. If the WriteBarrier is enabled during build time, the JNode JIT will include some special code into the compiled native code. For each bytecode that sets a reference to any field or local the writebarrier gets called and the object gets marked GREY. So the gc will know that the heap changed during mark. It is very tricky to do all that with proper synchronization and the current code still has bugs, which is the reason why it's not activated yet.</p>
</div>
<div id="node-156" class="section-4">
<h1 class="book-heading">Java Security</h1>
<p>This chapter covers the Java security implemented in JNode. This involves the security manager, access controller and privileged actions.<br/>
It does not involve user management.</p>
<p>The Java security in JNode is an implementation of the standard Java security API. This means that permissions are checked against an AccessControlContext which contains ProtectionDomain's. See the <a href="https://web.archive.org/web/20200119030613/http://java.sun.com/j2se/1.4.2/docs/guide/security/spec/security-spec.doc.html">Security Architecture</a> for more information.</p>
<p>In JNode the security manager is always on. This ensures that permissions are always checked.<br/>
The security manager (or better the AccessController) executes the security policy implemented by JNodePolicy. This policy is an implementation of the standard java.security.Policy class.<br/>
This policy contains some static permissions (mainly for access to certain system properties) and handles dynamic (plugin) permissions.</p>
<p>The dynamic permissions are plugin based. Every plugin may request certain permissions. The Policy implementation decides if these permissions are granted to the plugin.</p>
<p>To request permissions for a plugin, add an extension to the plugin-descriptor on connected to the "org.jnode.security.permission" extension-point.<br/>
This extension has the following structure:</p>
<p><dd>&lt;permission class="..." name="..." actions="..."/&gt;<br>...</dd>
<p><table>
<tr>
<td>class</td>
<td>The full classname of the permission. e.g. "java.util.PropertyPermission"</td>
</tr>
<tr>
<td>name</td>
<td>The name of the permission. This attribute is permission class dependent. e.g. "os.name"</td>
</tr>
<tr>
<td>actions</td>
<td>The actions of the permission. This attribute is permission class dependent. e.g. "read"</td>
</tr>
</table>
<p>Multiple permission's can be added to a single extension.</p>
<p>If you need specific permissions, make sure to run that code in a PrivilegedAction. Besides you're own actions, the following standard PrivilegedAction's are available:</p>
<p><table>
<tr>
<td>gnu.java.security.actions.GetPropertyAction</td>
<td>Wraps System.getProperty</td>
</tr>
<tr>
<td>gnu.java.security.actions.GetIntegerAction</td>
<td>Wraps Integer.getInteger</td>
</tr>
<tr>
<td>gnu.java.security.actions.GetBooleanAction</td>
<td>Wraps Boolean.getBoolean</td>
</tr>
<tr>
<td>gnu.java.security.actions.GetPolicyAction</td>
<td>Wraps Policy.getPolicy</td>
</tr>
<tr>
<td>gnu.java.security.actions.InvokeAction</td>
<td>Wraps Method.invoke</td>
</tr>
</table>
</div>
<div id="node-36" class="section-4">
<h1 class="book-heading">Multi-threading</h1>
<p>Multithreading in JNode involves the scheduling of multiple java.lang.Thread instances between 1 or more physical processors. (In reality, multiprocessor support is not yet stable).  The current implementation uses the <i>yieldpoint scheduling</i> model as described below. </p>
<p><b>Yieldpoint scheduling</b><br><br/>
Yieldpoint scheduling means that every thread checks at certain points (called "yieldpoints") in the native code to see if it should let other threads run. The native code compiler adds yieldpoints into the native code stream at the beginning and end of a method, at backward jumps, and at method invocations. The yieldpoint code checks to see if the "yield" flag has been set for the current thread, and if is has, it issues a yield (software-)interrupt.  The kernel takes over and schedules a new thread.</p>
<p>The "yield" flag can be set by a timer interrupt, or by the (kernel) software itself, e.g. to perform an explicit yield or in case of locking synchronization methods.</p>
<p>The scheduler invoked by the (native code) kernel is implemented in the VmProcessor class. This class (one instance for every processor) contains a list of threads ready to run, a list of sleeping threads and a current thread. On a reschedule, the current thread is appended to the end of the ready to run thread-list. Then the sleep list is inspected first for threads that should wake-up. These threads are added to the ready to run thread-list. After that the first thread in the ready to run thread-list is removed and used as current thread. The reschedule method returns and the (native code) kernel does the actual thread switching.</p>
<p>The scheduler itself runs in the context of the kernel and should not be interrupted.  A special flag is set to prevent yieldpoints in the scheduler methods themselves from triggering reentrant yieldpoint interrupts.  The flag is only cleared when the reschedule is complete</p>
<p><b>Why use yieldpoint scheduling?</b><br><br/>
JNode uses yield point scheduling to simplify the implementation of the garbage collector and to reduce the space needed to hold GC descriptors.</p>
<p>When the JNode garbage collector runs, it needs to find all "live" object references so that it can work out which objects are not garbage.  A bit later, it needs to update any references for objects that have been moved in memory. Most object references live either in other objects in the heap, or in local variables and parameters held on one of the thread stacks.  However, when a thread is interrupted, the contents of the hardware registers are saved in a "register save" area, an this may include object references.</p>
<p>The garbage collector is able to find these reference because the native compiler creates descriptors giving the offsets of references.  For each class, there is a descriptor giving the offsets of its reference attributes and statics in their respective frames.  For each method or constructor, another descriptor gives the corresponding stack frame layout.  But we still have to deal with the saved registers.</p>
<p>If we allowed a JNode thread to be interrupted at any point, the native compiler would need to create descriptors all possible saved register sets.  In theory, we might need a different descriptor corresponding to every bytecode.  By using yield points, we can guarantee that "yields" only occur at a fixed places, thereby reducing the number of descriptors that that need to be kept.</p>
<p>However, the obvious downside of yieldpoints is the performance penalty of repeatedly testing the "yield" flag, especially when executing a tight loop.</p>
<p>
<b>Thread priorities</b><br><br/>
Thread can have different priorities, ranging from Thread.LOW_PRIORITY to Thread.HIGH_PRIORITY. In JNode these priorities are implemented via the ready to run thread-list. This list is (almost) always sorted on priority, which means that the threads with the highest priority comes first.</p>
<p>There is one exception on this rule, which is in the case of busy-waiting in the synchronization system. Claiming access to a monitor (internals) involves a busy-waiting loop with an explicit yield. This yield ignores the thread priority to avoid starvation of lower-priority threads, which will lead to an endless waiting time for the high priority thread.</p>
<p><b>Classes involved</b><br><br/>
The following classes are involved in the scheduling system. All of these classes are in the <i>org.jnode.vm</i> package.</p>
<ul>
<li>VmProcessor</li>
<li>VmThread contains the internal (JNode specific) data for a single thread. This class is extended for each specific platform</li>
</ul>
<p></div>
<div id="node-37" class="section-4">
<h1 class="book-heading">Native code compilation</h1>
<p>All methods are compiled before being executed. At first, the method is "compiled" to a stub that calls the most basic compiler and then invokes the compiled code.</p>
<p>Better compilers are invoked when the VM detects that a method is invoked often. These compilers perform more optimizations.</p>
<div id="node-101" class="section-5">
<h1 class="book-heading">Intel X86 compilers</h1>
<p>JNode has now two different native code compilers for the Intel X86 platform and 1 stub compiler.</p>
<p><b>STUB</b> is a stub compiler that generates a stub for each method that invokes the L1 compiler for a method and then invokes the generated code itself. This compiler ensures that method are compiled before being executed, but avoids compilation time when the method is not invoked at all.</p>
<p><b>L1A</b> is a basic compiler that translated java bytecode directly to decent X86 instructions. This compiler uses register allocation and a virtual stack to eliminate much of the stack operations. The focus of this compiler is on fast compilation and reasonably fast generated code.</p>
<p><b>L2</b> is an optimizing compiler that focuses on generating very fast code, not on compilation speed. This compiler is currently under construction.</p>
<p>All X86 compilers can be found below the org.jnode.vm.x86.compiler package.</p>
</div>
<div id="node-100" class="section-5">
<h1 class="book-heading">IR representation</h1>
<p>Optimizing compilers use an intermediate representation instead of java bytecodes. The intermediate representation (IR) is an abstract representation of machine operations which are eventually mapped to machine instructions for a particular processor. Many optimizations can be performed without concern for machine details, so the IR is a good start. Additional machine dependent optimizations can be performed at a later stage. In general, the most important optimizations are machine independent, whereas machine dependent optimizations will typically yield lesser gains in performance.</p>
<p>The IR is typically represented as set of multiple operand operations, usually called triples or quads in the literature. The L2 compiler defines an abstract class org.jnode.vm.compiler.ir.quad.Quad to describe an abstract operation. Many concrete implementations are defined, such as BinaryQuad, which represents binary operations, such as a = x + y. Note that the left hand side (lhs) of the operation is also part of the quad.</p>
<p>A set of Quads representing bytecodes for a given method are preprared by org.jnode.vm.compiler.ir.IRGenerator.</p>
</div>
<div id="node-102" class="section-5">
<h1 class="book-heading">L2 Compiler Phases</h1>
<p>The L2 compiler operates in four phases:</p>
<p>1. Generate intermediate representation (IR)<br/>
2. Perform second pass optimizations (pass2)<br/>
3. Register allocation<br/>
4. Generate native code</p>
<p>The first phase parses bytecodes and generates a set of Quads. This phase also performs simple optimizations, such as copy propagation and constant folding.</p>
<p>Pass2 simplifies operands and tries to eliminate dead code.</p>
<p>Register allocation is an attempt to assign live variable ranges to available machine registers. As register access is significantly faster than memory access, register allocation is an important optimization technique. In general, it is not always possible to assign all live variable ranges to machine registers. Variables that cannot be allocated to registers are said to be 'spilled' and must reside in memory.</p>
<p>Code is generated by iterating over the set of IR quads and producing machine instructions.</p>
</div>
</div>
<div id="node-31" class="section-4">
<h1 class="book-heading">Object allocation</h1>
<p>All new statements used to allocate new objects are forwarded to a HeapManager. This class allocates &amp; initializes the object. The objects are allocated from one of several heaps. Each heap contains objects of various sizes. Allocation is currently as simple as finding the next free space that is large enough to fit all instance variables of the new object and claiming it. </p>
<p>An object is blanked on allocation, so all instance variables are initialized to their default (null) values. Finally the object header is initialized, and the object is returned. </p>
<p>To directly manipulate memory at a given address, a class called Unsafe is used. This class contains native methods to get/set the various java types.</p>
</div>
<div id="node-34" class="section-4">
<h1 class="book-heading">Synchronization</h1>
<p>Synchronization involves the implementation of <b>synchronized</b> methods and blocks and the <b>wait</b>, <b>notify</b>, <b>notifyAll</b> method of java.lang.Object.</p>
<p>Both items are implemented using the classes Monitor and MonitorManager. </p>
<p><b>Lightweight locks</b><br><br/>
JNode implement a lightweight locking mechanism for synchronized methods and blocks. For this purpose a lockword is added to the header of each object. Depending on the state of the object on which a thread wants to synchronize a different route it taken.</p>
<p>This is in principle how the various states are handled.</p>
<ol>
<li><i>The object is not locked</i>: the lockword it set to a merge of the id of this thread and a lockcount of '1'.</li>
<li><i>The object is locked by this thread</i>: the lockcount part of the lockword is incremented.</li>
<li><i>The object is locked by another thread</i>: an inflated lock is installed for the object and this thread is added to the waiting list of the inflated lock.</li>
</ol>
<p>All manipulation of the lockword is performed using atomic instructions prefixed with multiprocessor LOCK flags.<br/>
<br><br/>
When the lockcount part of the lockword is full, an inflated lock is also installed.<br/>
<br><br/>
Once an object has an inflated lock installed, this inflated lock will always be used.</p>
<p><b>Wait, notify</b><br><br/>
Wait and notify(all) requires that the current thread is owner of the object on which wait/notify are invoked. The wait/notify implementation will install an inflated lock on the object if the object does not already have an inflated lock installed.</p>
</div>
</div>
<div id="node-658" class="section-3">
<h1 class="book-heading">Reports</h1>
<p>The following reports are generated nightly reflecting the state of SVN trunk.</p>
<p>Plugins:</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://jnode.sf.net/report-data/plugins/index.html">Overview</a></li>
</ul>
<p>Javadocs:</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://jnode.sf.net/report-data/javadoc/small/index.html">Major API's</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://jnode.sf.net/report-data/javadoc/full/index.html">All API's</a></li>
</ul>
<p><!-- remove this later of not needed<br />
JNode compared to:</p>
<ul>
<li><a href="/report-data/japi/jnode-jdk10.html">J2SDK 1.0</a></li>
<li><a href="/report-data/japi/jnode-jdk11.html">J2SDK 1.1</a></li>
<li><a href="/report-data/japi/jnode-jdk12.html">J2SDK 1.2</a></li>
<li><a href="/report-data/japi/jnode-jdk13.html">J2SDK 1.3</a></li>
<li><a href="/report-data/japi/jnode-jdk14.html">J2SDK 1.4</a></li>
<li><a href="/report-data/japi/jnode-jdk15.html">J2SDK 1.5</a></li>
<li><a href="/report-data/japi/jnode-jdk16.html">J2SDK 1.6</a></li>
</ul>
<p>These comparisons are generated using <a href="http://sab39.netreach.com/japi/">japitools</a>.<br />
--></p>
<p>Nightly build:</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://jnode.sf.net/report-data/nightly-build/log.txt">Build log</a></li>
</ul>
<p><!--<br />
Hourly testsuite run results:</p>
<ul>
<li><a href="http://testsuite.jnode.bucksch.org/">Results</a></li>
</ul>
<p>--></p>
</div>
</div>
<div id="node-567" class="section-2">
<h1 class="book-heading">Tester guide</h1>
<p>This part is intended for JNode testers.</p>
<div id="node-568" class="section-3">
<h1 class="book-heading">Filesystem</h1>
<p>Here you can find informations related to the tests on filesystems.<br/>
<br><br/>
<b>Running the tests outside of JNode</b></p>
<p>With Ant run the target <b>tests</b> in the file <i>/JNode-All/build.xml</i>.</p>
<p>The results are sent to the standard output and unexpected exceptions are also sent as for any other JAVA application.</p>
<p>To debug the functionalities whose tests are failing, you can use Log4j that is configured through the file <i>/JNode-FS/src/test/org/jnode/test/log4jForTests.properties</i>.<br/>
By default traces are sent to the localhost on the port 4445. I recommand to use <a href="https://web.archive.org/web/20200119030613/http://traxel.com/lumbermill/">Lumbermill</a> as a server to receive the log4j messages.<br/>
<br><br/>
<b>Running the tests in JNode</b></p>
<p>Type <b>AllFSTest</b> in the JNode shell. The results and unexpected exceptions are sent to the console. Log4j is automatically configured by JNode itself and manually with the shell command <b>log4j</b>.</p>
</div>
<div id="node-1581" class="section-3">
<h1 class="book-heading">Network</h1>
<p>We assume in the following tests that IP address of JNode is 192.168.44.3.</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/527">configure the network in JNode</a></li>
<li><u>Testing the telnet server</u>
<ol>
<li><u>In JNode shell</u> : type <b>telnetd</b>. The telnet server will start on port 6666</li>
<li><u>In another OS (Linux, Windows...)</u> :  connect to the telnet server by typing <b>telnet 192.168.44.3 6666</b>.</li>
</ol>
</li>
</ul>
</div>
<div id="node-2888" class="section-3">
<h1 class="book-heading">Running black-box tests</h1>
<p>The JNode-shell project includes a test harness for running "black-box" tests on JNode commands and scripts.  The harness is designed to allow tests to be run both in a development sandbox and on a running JNode system.</p>
<p>The test methodology is very straight-forward.  Each testcase consists of a JNode alias, Java classname or inline script, together with an optional set of arguments and an optional inline input file.  The command (alias or class) or script it run with the prescribed arguments and input, and the resulting output stream, error stream and return code are compared with expected results in the testcase.  If there are any discrepancies between the expected and actual results, the testcase is counted as "failed".  If there are any uncaught exceptions, this counts as a test "error".</p>
<p>The testcases are specified in XML files.  Examples may be found in the JNode-Shell project in the "src/test" tree; e.g. "src/test/org/jnode/test/shell/bjorne/bjorne-shell-tests.xml".  Each file typically specifies a number of distinct testcases, as outlined above. The "all-tests.xml" file (i.e. "shell/src/test/org/jnode/test/shell/all-tests.xml") should include all tests in the shell tree.</p>
<p><b><u>Running tests from Eclipse</u></b><br/>
The following steps can be used to run a set of tests from Eclipse.</p>
<ol>
<li>Launch Eclipse, switch to your JNode workspace, and open the JNode-shell project.
<li>Navigate to the class "org.jnode.test.shell.harness.TestHarness" ... it is in the "src/test" tree.
<li>Use "Run as&gt;Open Run dialog" to create an app launcher for the TestHarness class.
<li>Set the full classname as above and set the Arguments to the name of a "...-tests.xml" file.
<li>If you are testing commands in a different project from "shell", make sure that the project is on the launcher's classpath.
<li>Use the launcher to run the TestHarness.
</ol>
<p>You should now see a Console view displaying the output from running the tests.  The last line should give a count of tests run, failures and errors. </p>
<p><b><u>Running tests from the Linux shell</u></b><br/>
Running the tests from the Linux shell is simply a matter of doing what the Eclipse launcher is doing.  Put the relevant "JNode-*/classes" directories on the classpath, then run:</p>
<pre>    java org.jnode.test.shell.harness.TestHarness &lt;xxx-tests.xml&gt;
</pre><p>
<b><u>Running tests from within JNode.</u></b><br/>
In order to run the tests on the JNode platform, you must first boot JNode with the all plugins and tests loaded.  Then, run the following command at the JNode command prompt:</p>
<pre>    org.jnode.test.shell.harness.TestHarness -r /org/jnode/test/shell/all-tests.xml
</pre><p>Notes:</p>
<ol>
<li>The "-r" option tells the test harness to locate the test suite specification as a resource using the classloader.  So you need to make sure that the specification and dependent specifications are included in the relevant test plugins.
<li>When using "-r", the resource path should be specified using "/" as the path separator, not ".".  The resource path will be treated as absolute whether or not it starts with a "/".
<li>An alternative to "-r" might be to arrange that the test suite / test specification are accessible through JNode's file system; e.g. by uploading them to JNode before running the test harness.
</ol>
<p><b><u>TestHarness command syntax.</u></b></p>
<p>The TestHarness command has the following syntax:</p>
<pre>    command [ &lt;opt&gt; ...] &lt;spec-file&gt; ...
</pre><p>where &lt;opt&gt; is one of:</p>
<pre>        --verbose | - v       # output more information about tests run
        --debug | - d         # enable extra debugging
        --stopOnError | -E    # stop test harness on the first 'error'
        --stopOnFailure | -F  # stop test harness on the first 'failure'
        --sandbox | -s &lt;dir-name&gt; # specifies the dev't sandbox root directory
        --resource | -r       # looks for &lt;spec-file&gt; as a resource on the classpath
</pre><p>The first two options enable more output.  In particular, "-d" causes all output captured by the harness to be echoed to the console as it is captured.  </p>
<p>The "-s" option can be used when the running the test harness outside of JNode when the root of the development sandbox is not "..".  </p>
<p>The "-r" option tells the harness to try to find the test specification files on TestHarness's classpath rather in the file system.  This allows the test harness to be run on JNode without the hassle of copying test and test suite specification files into the JNode filesystem.</p>
<p>Note that the TestHarness command class does not implement JNode's "Command" API, so command completion is not available when running on JNode.  This is a deliberate design decision, not an oversight.</p>
<p><b><u>Reading and writing test specifications.</u></b></p>
<p>If a test fails, you will probably need to read and understand the test's specification as a first step in diagnosing the problem. For a description of specification file syntax and what they mean, please refer to the <a href="/web/20200119030613/http://www.jnode.org/node/2893">Black-box command tests with TestHarness</a> page.</p>
</div>
<div id="node-739" class="section-3">
<h1 class="book-heading">Running Mauve Tests</h1>
<p>To run the <a href="https://web.archive.org/web/20200119030613/http://sources.redhat.com/mauve/">mauve</a> tests, proceed as follow :<br/>
- boot JNode and choose the choose the option "all plugins + tests" (should be the latest choice in the menu), that will allow you to use the mauve plugin.<br/>
- when boot is finished, type the command <b>cd /jnode/tmp</b> to go in a writable directory<br/>
- type <b>mauve-filter</b> and answer to the asked questions, that will create a file named "tests" in the current directory<br/>
- type <b>testCommand</b> and the tests will run </p>
<p>If you find some bugs by this way, don't forget to <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/add/project_issue/538">submit it</a> or fix it. Depending on the case, it is possible that a patch to fix the bug is needed on Classpath/Openjdk side ... and/or on JNode side.</p>
</div>
<div id="node-3009" class="section-3">
<h1 class="book-heading">Running sandbox tests</h1>
<p>We have created a straight-forward way to run various tests from the Linux commandline in the development sandbox.  The procedure is as follows:</p>
<ol>
<li>Change directory to the sandbox root.
<li>Run the "test.sh" script as follows:<br/>
<pre>     $ ./test.sh all
</pre></ol>
<p>For brief help on the script's arguments, just run "./build.sh" with no arguments.</p>
<p>The "./build.sh" script is just a wrapper script for using Ant to run tests that are<br/>
defined as targets in the "&lt;project&gt;/build-tests.xml" files.  You can add new<br/>
tests to be run by adding targets, or (if required) cloning an existing file into<br/>
a project that doesn't have one.</p>
</div>
<div id="node-2847" class="section-3">
<h1 class="book-heading">Running the test server (JTestServer)</h1>
<p>TODO</p>
</div>
</div>
<div id="node-512" class="section-2">
<h1 class="book-heading">Porting guide</h1>
<p>This guide is intended for developers porting JNode to different platforms.</p>
<p>Porting JNode to another platform involves the components:</p>
<ul>
<li>The nano-kernel (assembler)</li>
<li>The native methods (assembler)</li>
<li>The architecture specific classes</li>
<li>The native code compilers</li>
<li>The build process</li>
</ul>
<h2>Nano-kernel</h2>
<p>The nano-kernel is the piece of code that is executed when JNode boots. It is responsible for setting the CPU into the correct mode and initialize the physical memory management structures (like page tables, segments etc).</p>
<p>The nano-kernel is also responsible for caching and dispatching hardware interrupts.</p>
<h2>Native methods</h2>
<p>The Unsafe class contains some native methods that must be implemented according to the given architecture.</p>
<h2>Architecture specific classes</h2>
<p>The JNode system requires some specific classes for each architecture. These classes describe the architecture like the size of an object reference and implement architecture specific items like thread states and processor information.</p>
<p>The essential classes needed for every architecture are:</p>
<ul>
<li>A class derived from VmArchitecture</li>
<li>A class derived from VmProcessor</li>
<li>A class derived from VmThread</li>
</ul>
<h2>Native code compilers</h2>
<p>At least 1 native code compiler must be written for an architecture. This compiler generates native code for java methods.</p>
<p>It is possible to implement multiple native code compilers for a specific architecture. Every compiler has a specific optimization level.</p>
<p>Part of the native code compiler infrastructure is usually an assembler. This assembler is a java class that writes/encodes native code instructions. The assembler is used by the native code compilers and usually the build process.</p>
<h2>Build process</h2>
<p>A final but important part of a port to a specific architecture is the build process. The standard JNode build files will compile all java code, prepare plugins and initial jar files, but will not build any architecture dependent structures.</p>
<p>The build process contains an architecture specific ant-file which will call a task used to create the JNode kernel. This task is derived from AbstractBootImageBuilder.</p>
</div>
<div id="node-2680" class="section-2">
<h1 class="book-heading">Blogs</h1>
<p><a href="https://web.archive.org/web/20200119030613/http://www.duminy.fr/blog/" target="_new">Fabien Duminy (en, fr)</a><br/>
<a href="https://web.archive.org/web/20200119030613/https://lsantha.blogspot.com/" target="_new">Levente Sntha (en)</a><br/>
<a href="https://web.archive.org/web/20200119030613/https://zenmindweblog.wordpress.com/" target="_new">Fabien Lesire (fr)</a></p>
</div>
<div id="node-125" class="section-2">
<h1 class="book-heading">Project development</h1>
<p>This part contains all release plans, the projects organization and the development process in general.</p>
<div id="node-46" class="section-3">
<h1 class="book-heading">Project organization</h1>
<div id="node-48" class="section-4">
<h1 class="book-heading">Development teams</h1>
<p>Development in the JNode project is done in development teams.<br/>
    These teams have been introduced to:</p>
<ul>
<li>Focus development efforts</li>
<li>Shorten learning curve for new developers</li>
<li>Delegate project control</li>
</ul>
<p>    Overall coordination of the JNode project remains in the hands of the<br/>
    projects founder: <a href="/web/20200119030613/http://www.jnode.org/user/view/1">Ewout Prangsma</a>.
    </p>
<div id="node-49" class="section-5">
<h1 class="book-heading">JNode-Core</h1>
<p>This team will develop the virtual machine itself and the basic structure of the JNode kernel.</p>
<p>Team members</p>
<ul>
<li><a href="/web/20200119030613/http://www.jnode.org/user/view/1">Ewout Prangsma</a>, teamleader</li>
<li><a href="/web/20200119030613/http://www.jnode.org/user/view/20">Madhu Siddalingaiah</a></li>
<li><a href="/web/20200119030613/http://www.jnode.org/user/view/34">Patrik Reali</a></li>
</ul>
<p>Topics:<br/>
The plugin framework, The device framework, The VM, classloaders, native code compilers, memory management, The build &amp; boot process, PCI drivers.</p>
<p>All development issues are discusses in our <a href="/web/20200119030613/http://www.jnode.org/forum/7">forum</a>.</p>
<p>Targets for the near future:</p>
<ul>
<li>Finalize  integrate optimizing native code compiler</li>
<li>Load/unload/reload plugins at runtime</li>
<li>Load/unload/reload drivers at runtime </li>
<li>Start security system</li>
<li>Plugin install, upgrade &amp; uninstall framework</li>
</ul>
<p>Targets for the longer term:</p>
<ul>
<li>Fully concurrent GC</li>
<li>Improve memory allocation speed</li>
</ul>
</div>
<div id="node-57" class="section-5">
<h1 class="book-heading">JNode-FS</h1>
<p>This team will develop the filesystem layer of JNode.</p>
<p>
Team leader: <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#c1a6a3a8af81b4b2a4b3b2efb2aeb4b3a2a4a7aeb3a6a4efafa4b5">Guillaume BINET</a>.</p>
<p>Topics:<br/>
The filesystem framework, The various filesystems, The integration with java.io, java.nio, Block device drivers (IDE, Floppy, SCSI, Ramdisk)</p>
<p>All development issues are discusses in our <a href="/web/20200119030613/http://www.jnode.org/forum/8">forum</a>.</p>
</div>
<div id="node-58" class="section-5">
<h1 class="book-heading">JNode-GUI</h1>
<p>This team will develop the graphics layer of JNode.</p>
<p>Team leader: <a href="/web/20200119030613/http://www.jnode.org/user/view/3">Valentin Chira</a>.</p>
<p>Topics:<br/>
The AWT implementation, The window manager, The input handlers (keyboard/mouse) &amp; drivers, Video drivers</p>
<p>All development issues are discusses in our <a href="/web/20200119030613/http://www.jnode.org/forum/9">forum</a>.</p>
<p></div>
<div id="node-60" class="section-5">
<h1 class="book-heading">JNode-Net</h1>
<p>This team will develop the network layer of JNode.</p>
<p>Team leader: <a href="/web/20200119030613/http://www.jnode.org/user/view/4">Martin Husted Hartvig</a>.</p>
<p>Topics:<br/>
The networking framework, The various network protocols, The integration with java.net, Network drivers</p>
<p>Team members:<br/>
<br><br><br/>
<a href="/web/20200119030613/http://www.jnode.org/user/view/112">Lesire Fabien</a><br><br/>
<a href="/web/20200119030613/http://www.jnode.org/user/view/41">Mark Hale</a><br><br/>
<a href="/web/20200119030613/http://www.jnode.org/user/view/24">Pavlos Georgiadis</a><br><br/>
<a href="/web/20200119030613/http://www.jnode.org/user/view/118">Christopher Cole</a><br><br/>
<a href="/web/20200119030613/http://www.jnode.org/user/view/">Eduardo Millan</a></p>
<p>All development issues are discusses in our <a href="/web/20200119030613/http://www.jnode.org/forum/10">forum</a>.</p>
<p></div>
<div id="node-59" class="section-5">
<h1 class="book-heading">JNode-Shell</h1>
<p>This team will develop the command line shell and the basic commands.</p>
<p>Team leader: <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#bcded9d2dbc8defcc9cfd9cecf92cfd3c9cedfd9dad3cedbd992d2d9c8">Bengt Baverman</a>.</p>
<p>Topics:<br/>
The command line shell, including the help system, The basic commands, Help the development of other parts of JNode to support the Shell</p>
<p>All development issues are discusses in our <a href="/web/20200119030613/http://www.jnode.org/forum/11">forum</a>.</p>
</div>
</div>
<div id="node-645" class="section-4">
<h1 class="book-heading">How to join the development team</h1>
<p>We always welcome new dedicated developers.</p>
<p><b>Following content is outdated since we have <a href="https://web.archive.org/web/20200119030613/https://github.com/jnode">moved to GitHub</a></b>.</p>
<p>If you want to join the development team, contact one of the developers who is working on an <a href="/web/20200119030613/http://www.jnode.org/project/issues/538">issue</a> you want to contribute to, or contact the <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#244857454a504c45644f4a0a564b">project admin</a> for more information.</p>
<p>You will be asked to submit your first patches via email, before you'll be granted access to the SVN repository.</p>
</div>
</div>
<div id="node-126" class="section-3">
<h1 class="book-heading">Draft 0.2 plan</h1>
<p>The document lays out the feature set for the next major release of JNode designated release 0.2.</p>
<p>
This plan is intended to guide the development towards our first major release. It is not a fixed plan that cannot be deviated from. Suggestions &amp; remarks are always welcome and will be considered.</p>
<p><b>Release target</b><br><br/>
We want this release to be the first usable version of JNode where we can run real world Java programs on.<br/>
This means that we need a working filesystem, a stable virtual machine, a class library mostly compatible with JDK 1.1, a working TCP/IP implementation and way to install it on a PC. It is not expected to have a fully working GUI yet.</p>
<p><b>Additional features</b><br><br/>
To achieve the target outlined above, each team will have to add/complement a number of features. These features are listed below. The percentages specify finised work, so 100% means completed.</p>
<p>JNode-Core</p>
<ul>
<li>100%  - Dynamically (re)loadable plugins</li>
<li>10%  - Plugin install, upgrade &amp; uninstall framework</li>
<li>50%  - Second level native code compiler target as good (native) code quality</li>
<li>100% - Security system</li>
<li>0%   - Setup utility</li>
<li>80%  - Implementation of java.lang package</li>
<li>80%  - Implementation of java.math package</li>
<li>60%  - Implementation of java.security package</li>
<li>90%  - Implementation of java.util package</li>
<li>80%  - Implementation of java.util.jar package</li>
<li>80%  - Implementation of java.util.zip package</li>
</ul>
<p>JNode-FS</p>
<ul>
<li>80%  - Virtual filesystem (in progress)</li>
<li>60%  - Implementation of java.io package</li>
<li>90%  - R/w ext2 implementation</li>
<li>20%  - R/w fdisk services</li>
<li>?    - Format services for ext2</li>
<li>95%  - ATAPI driver</li>
<li>95%  - CDROM (ISO9660) filesystem</li>
</ul>
<p>JNode-GUI</p>
<ul>
<li>0%   - Textmode userinterface for use in installer</li>
</ul>
<p>JNode-Net</p>
<ul>
<li>25%  - TCP/IP stack, client &amp; server</li>
<li>75%  - Implementation of java.net package</li>
</ul>
<p>JNode-Shell</p>
<ul>
<li>100% - Commands to modify the classpath</li>
<li>100% - Commands to run java code, both .class and .jar files from any location</li>
</ul>
<p><b>Release milestones</b><br><br/>
Right now no date is set for this release. There will be intermediate releases reflecting the state of development on the 0.1.x series until the target is reached.</p>
<p><b>Looking towards the future; 0.3</b><br><br/>
The next major release after 0.2 should bring a graphical user interface, we should really consider using J2SDK 1.5 features like generic types and add numerous drivers for CDROMs, USB, Video cards.</p>
<p></div>
<div id="node-636" class="section-3">
<h1 class="book-heading">Draft 0.3 plan</h1>
<p>The document lays out the feature set for the next major release of JNode designated release 0.3.</p>
<p>This plan is intended to guide the development towards our second major release. It is not a fixed plan (as we have seen with the 0.2 release). Suggestions &amp; remarks are always welcome and will be considered.</p>
<h2>Release target</h2>
<p>This release will improve the stability of the JNode operating system and enhance the usability.</p>
<p><!--<br />
No release date is set for the 0.3 release, but we hope to have this release available at the end of 2005 or early 2006. Until then, we'll continue our intermediate release cycle of about one 0.2.x release every 2 month.<br />
--></p>
<h2>Global enhancements</h2>
<p>A major goal of this release is to reduce the memory footprint required by JNode. The VM will be enhanced to support this, and all parts of JNode will have to be more concerned about their memory usage.</p>
<p>JNode will become localizable and translations for some locales will be added.<br/>
Every new part of JNode will have to be localizable according to a set of rules that will be determined.<br/>
The one and only language for the source code of JNode is and will remain to be English.</p>
<p>The remainder of this page will describe the targets and enhancements of the various subprojects of JNode. The names between brackets in the enhancements sections are the names of the lead developer for that enhancement.</p>
<p>The enhancements are given a priority:</p>
<ul>
<li class="prio1">Highest priority</li>
<li class="prio2">Second priority</li>
<li>Lowest priority</li>
</ul>
<h2>Core: Virtual Machine &amp; Operating system</h2>
<p>The virtual machine will become more stable, reduce memory usage and will add support for Isolates (JSR 121). Furthermore it will enhance the J2SDK compatibility level.<br/>
The operating system will add support for power management and make enhancements for that in the driver framework.</p>
<p>An installer will be developed that is used to install JNode onto a PC system. This installer will put the essential structures/files on the harddisk of the PC.</p>
<p>A persistent storage mechanism for plugin preferences will be added. </p>
<p>Enhancements:</p>
<ul>
<li class="prio2"><a href="/web/20200119030613/http://www.jnode.org/node/593"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Isolate support [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li class="prio2"><a href="/web/20200119030613/http://www.jnode.org/node/638"><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></a> Annotation support [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/596"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Multi CPU support [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/683"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Integrate MMTK garbage collector [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/600"><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></a> Smart field alignment, to reduce the size of objects [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li class="prio1"><a href="/web/20200119030613/http://www.jnode.org/node/637"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Overall memory reduction [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li>Power management support [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li>API for halt, sleep &amp; reboot of JNode [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li class="prio1"><a href="/web/20200119030613/http://www.jnode.org/node/594"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Installer [<a href="/web/20200119030613/http://www.jnode.org/user/4">martin</a>]</li>
<li class="prio1"><a href="/web/20200119030613/http://www.jnode.org/node/625"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Persistent storage for plugin preferences</li>
<li>Access to detailed information about system information such as classes &amp; their usage</li>
<li class="prio1"><a href="/web/20200119030613/http://www.jnode.org/node/649"><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></a> Fragmented plugin support [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
</ul>
<h2>Networking</h2>
<p>The network layer will be enhanced to fully support wireless networks. Furthermore, the existing TCP/IP stack will be improved in terms of reliability, safety and speed.</p>
<p>Enhancements:</p>
<ul>
<li>Wireless network support [<a href="/web/20200119030613/http://www.jnode.org/user/4">martin</a>]</li>
<li>Wireless netcard drivers [<a href="/web/20200119030613/http://www.jnode.org/user/4">martin</a>]</li>
<li>TCP server side fixes [<a href="/web/20200119030613/http://www.jnode.org/user/112">galatnm</a>]</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/621"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> EEPRO100 driver [<a href="/web/20200119030613/http://www.jnode.org/user/112">galatnm</a>]</li>
</ul>
<h2>File system</h2>
<p>The filesystem layer will become more stable and will be refactored to make use to the NIO classes.<br/>
Support will be added for a virtual filesystem that allows links between filesystems.</p>
<p>A new "system" filesystem will be added that gives access to a distributed filesystem that contains the JNode system information. This system information is about plugins, kernels &amp; preferences.</p>
<p>Enhancements:</p>
<ul>
<li><a href="/web/20200119030613/http://www.jnode.org/node/639"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Change file system api's to use ByteBuffers [<a href="/web/20200119030613/http://www.jnode.org/user/65">fabien</a>]</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/640"><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></a> Update java.io to latest classpath version based on NIO classes [<a href="/web/20200119030613/http://www.jnode.org/user/65">fabien</a>]</li>
<li class="prio1">System filesystem [<a href="/web/20200119030613/http://www.jnode.org/user/1">ewout</a>]</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/648"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> USB storage driver [<a href="/web/20200119030613/http://www.jnode.org/user/112">galatnm</a>]</li>
<li>Extend support for EXT2 to EXT3</li>
<li>Add write &amp; format support to NTFS</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/641"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Generic block cache for block devices [<a href="/web/20200119030613/http://www.jnode.org/user/65">fabien</a>]</li>
</ul>
<h2>GUI</h2>
<p>The existing GUI will be improved in terms of stability, Java2D support and speed.<br/>
The video driver interface may be adjusted to make better use of hardware acceleration.</p>
<p>A user friendly desktop environment will be developed or integrated.</p>
<p>Enhancements:</p>
<ul>
<li>Enhance java2D support</li>
<li>Improve use of hardware acceleration</li>
<li class="prio2">Improve font rendering</li>
<li class="prio1"><a href="/web/20200119030613/http://www.jnode.org/node/661"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Improve Swing awt peers [<a href="/web/20200119030613/http://www.jnode.org/user/6">levente</a>]</li>
<li>User friendly desktop environment [<a href="/web/20200119030613/http://www.jnode.org/user/6">levente</a>]</li>
</ul>
<h2>Shell</h2>
<p>The shell will be extended with a graphical console, in order to display not ASCII characters.</p>
<p>Enhancements:</p>
<ul>
<li>Graphical console</li>
<li>Add Isolate command invoker</li>
</ul>
<h2>Developer support</h2>
<p>We want to make life of the JNode developer much easier. This will mean adding good documentation and also provide ways to develop JNode in JNode.</p>
<p>Enhancements:</p>
<ul>
<li>VM support for debugging</li>
<li>Implement JDWP debugging protocol [<a href="/web/20200119030613/http://www.jnode.org/user/6">levente</a>]</li>
<li><a href="/web/20200119030613/http://www.jnode.org/node/660"><img src="/web/20200119030613im_/http://www.jnode.org/misc/ok.png" title="Ok Icon" alt="Ok Icon"/></a> <a href="/web/20200119030613/http://www.jnode.org/node/660"><img src="/web/20200119030613im_/http://www.jnode.org/misc/info.png" title="Info Icon" alt="Info Icon"/></a> Support for a java compiler in JNode [<a href="/web/20200119030613/http://www.jnode.org/user/6">levente</a>]</li>
</ul>
</div>
<div id="node-906" class="section-3">
<h1 class="book-heading">TODO list</h1>
<p>The document states some of the TODOs with regard to future releases of JNode. There is no particular date when the targets should be finished, but it should give you some hints, what you could look at :</p>
<ul>
<li><b>XYZ Filesystem:</b> There are many other filesystems that could be added to JNode. Or existing readonly filesystems could be extended for write support. A list of possibilities includes: NFS, Samba, ssh fs, ftp write support, ntfs write support, ...
<li><b>Partitiontool:</b> We need harddisk partitioning support. That includes a commandline version like fdisk but could also be extended for a graphical version. The GUI version can be written using charva or swing or both <img src="/web/20200119030613im_/http://www.jnode.org/modules/smileys/packs/example/smile.png" title="Smiling" alt="Smiling"/></li>
<li><b>Grubinstaller:</b> Some code to be able to install grub to the harddisk. That means, install stage1 into MBR, stage1.5 as needed and for both files the hidden data structures have to be updated. A "highlevel editor" for the menu.lst file would be fine, too. </li>
<li><b>HTMLDemo:</b> Classpath contains a little "webbrowser", it would be nice as a showcase for JNode. It's contained in examples.zip, but it has to be extended, because at the moment it's only usable for testing classpaths HTML renderer</li>
<li><b>Device Drivers:</b> Device Drivers are a very important part of an operating system. If you have a peace of hardware that isn't included in JNode yet, and you have some hardware/lowlevel skills you're welcome to add support for it. This includes either adding support for a new hardware for an existing API (e.g. network cards, graphic cards, HIDs,...) but also adding hardware that was not present in JNode before (e.g. Framegrabber (bttv,..), CD Writer,...).</li>
<li><b>SWTswing:</b> Port of <a href="https://web.archive.org/web/20200119030613/http://swtswing.sourceforge.net/main/index.html">SWTswing</a> to JNode. This is needed to be able to run <a href="https://web.archive.org/web/20200119030613/https://www.eclipse.org/">eclipse</a> inside JNode. BTW, if that works, porting eclipse is the next TODO on the list <img src="/web/20200119030613im_/http://www.jnode.org/modules/smileys/packs/example/smile.png" title="Smiling" alt="Smiling"/></li>
<li><b>JSR80:</b> Interfacing the current JNode usb api to the javax.usb api as descriped in <a href="https://web.archive.org/web/20200119030613/http://javax-usb.org/jsr80.pdf">JSR80 API Specification</a>.</li>
<li><b>JNodeTools:</b> Implement a tool to create and edit the plugin descriptors. Either as a eclipse tool or standalone app (so it can be used in JNode too). See also <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/608">here</a></li>
<li><b>JNode Commands:</b> We need to expand and improve the suite of JNode utility commands that can be run from the command line.  Rather than reinventing the wheel, JNode commands should aim to be compatible with commands defined in the relevant POSIX specification; i.e. <a href="https://web.archive.org/web/20200119030613/https://www.opengroup.org/onlinepubs/009695399/">IEEE Std 1003.1, 2004 Edition</a></li>
</ul>
<div id="node-3100" class="section-4">
<h1 class="book-heading">Student Projects</h1>
<p>In order to imply students in JNode, I will expose here some projects.</p>
<p><b><u>Git repository</u></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;The gitorious project is located here : <a href="https://web.archive.org/web/20200119030613/https://gitorious.org/jnode" title="http://gitorious.org/jnode">http://gitorious.org/jnode</a>.<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;It's compound of:</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://gitorious.org/jnode/svn-mirror">svn-mirror</a>, which is a mirror of the subversion repository</li>
<li>a set a clones of <a href="https://web.archive.org/web/20200119030613/https://gitorious.org/jnode/svn-mirror">svn-mirror</a>, one for each student project</li>
</ul>
<p><b><u>Contact</u></b><br/>
&nbsp;&nbsp;&nbsp;&nbsp;If you are interested, you can contact me (<a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/65">Fabien DUMINY</a>) :</p>
<ul>
<li>with my <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/65/contact">jnode.org contact form</a> (in english or french)</li>
<li>with my blog contact form :
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.duminy.fr/blog/?page_id=891&amp;language=fr">en franais</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.duminy.fr/blog/?page_id=895&amp;language=en">in english</a></li>
</ul>
</li>
</ul>
<p>
<b><u>Remarks</u></b></p>
<ul>
<li>Since it's <u>a draft</u>, that document may evolve</li>
<li>In order to have some warranty of real work, I have contacted some schools to imply students in these tasks. These students will be served first and in the order of their arrival</li>
</ul>
<div id="node-3102" class="section-5">
<h1 class="book-heading">Classical projects</h1>
<p>Here is a list of classical projects.</p>
<p><u>Legend</u> :<br/>
(A) : project assigned</p>
<p><u>Level</u> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*) : easy<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(**) : average<br/>
&nbsp;&nbsp;&nbsp;(***) : difficult<br/>
&nbsp;&nbsp;(****) : very hard<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: unknow</p>
<div id="node-3111" class="section-6">
<h1 class="book-heading">Complete AMD 64 support</h1>
<ul>
<li>Description : The 64bit port has some bugs but it's not exactly known where and how many. This task is especially difficult as the bugs have to be spotted first. Is this enough work for a student project ?</li>
<li>Level : Timeconsuming (Depends on finding the bugs)</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3105" class="section-6">
<h1 class="book-heading">Complete multi CPU support</h1>
<ul>
<li>Description: Multi-<a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/CPU">CPU</a> support is broken. There are bugs in JNode's <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Advanced_Programmable_Interrupt_Controller">Apic</a> implementation and the scheduler is suboptimal in regard to SMP. This project involves fixing the <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/LAPIC">(L)Apic</a> handling and if time permits replacing the scheduler with an <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Symmetric_multiprocessing">SMP</a> efficient one.</li>
<li>Level : average/hard (many informations are needed to complete the task)</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3104" class="section-6">
<h1 class="book-heading">Complete the vesa driver</h1>
<ul>
<li>Description : The current <a href="https://web.archive.org/web/20200119030613/http://www.vesa.org/">vesa</a> driver need <a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/grub/">grub</a> support to detect and set the video mode at boot time. The driver should be extended to become independant of grub (and be able to switch to any supported graphic mode).</li>
<li>Level : hard (many informations are needed to complete the task)</li>
<li>References : implements the <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/uploads/vbe3_0.pdf">vbe3 specifications</a> and <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/2778">other references</a> gathered on jnode site</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3115" class="section-6">
<h1 class="book-heading">Implement full ddx support without 2d and 3d</h1>
<ul>
<li>Description : With ddx, which stands for full modesetting, you can detect the monitor, you can set any resolution, (sometimes you can rotate the screen) and you have multihead support. From the performance point of view, it will faster than a vesa driver but slower than a chipset specific driver</li>
<li>Level : moderate/hard</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3101" class="section-6">
<h1 class="book-heading">Implement javax.comm API (A)</h1>
<ul>
<li>Description : The javax.comm API allows to access serial and parallel ports in java. I have been told that the javax.comm package can't be used to avoid legal issues : the rxtx project has choosen the gnu.io package instead.
<li>References : <a href="https://web.archive.org/web/20200119030613/http://java.sun.com/products/javacomm/">specifications of the API</a>, <a href="https://web.archive.org/web/20200119030613/http://java.sun.com/products/javacomm/reference/api/index.html">its javadoc</a></li>
<li>Tips : use the <a href="https://web.archive.org/web/20200119030613/http://www.rxtx.org/">RXTX</a> library</li>
<li>Level : easy</li>
<li>Assigned to : <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/10729">Mihail Argranat</a> (<a href="https://web.archive.org/web/20200119030613/https://influt.livejournal.com/tag/jnode">blog</a>)</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Git_%28software%29">git</a> repository is located <a href="https://web.archive.org/web/20200119030613/https://gitorious.org/~fduminy/jnode/javax-comm-api">here</a></p>
</div>
<div id="node-3108" class="section-6">
<h1 class="book-heading">Implement new GC algorithms for better performances (A)</h1>
<ul>
<li>Advice : contact <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/667">Peter</a> since he has ideas about the subject and could give good practices to avoid breaking jnode for such a task</li>
<li>You should have read <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">this</a> and understood at least the Basic Algorithm. In the terms of that page, JNode's gc is a conservative, non-moving, non-generational, stop-the-world mark&amp;sweep algorithm. Improvements can be many-fold, basicaly removing one of the "non"s <img src="/web/20200119030613im_/http://www.jnode.org/modules/smileys/packs/example/smile.png" title="Smiling" alt="Smiling"/> Good information with much stuff about memory management and garbage collection can also be found on <a href="https://web.archive.org/web/20200119030613/http://www.memorymanagement.org/">this</a> site. You can find another explanation of the naive mark&amp;sweep, with a graph on <a href="https://web.archive.org/web/20200119030613/http://www.brpreiss.com/books/opus5/html/page424.html">this</a> site</li>
<li>Level : This can be anything from easy to extremly hard. Depends on actual task.</li>
<li>Assigned to : <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/10006">Loc Rouchon</a>, <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/10008">Benoit Sautel</a> and <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/11547">Ismael Merzaq</a></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Git_%28software%29">git</a> repository is located <a href="https://web.archive.org/web/20200119030613/https://gitorious.org/+jnode-new-gc-algo-developers/jnode/new-gc-algorithms">here</a></p>
</div>
<div id="node-3113" class="section-6">
<h1 class="book-heading">Implement realtime specification for Java</h1>
<ul>
<li>Description : It's also know as <a href="https://web.archive.org/web/20200119030613/http://www.rtsj.org/">RTSJ</a> and <a href="https://web.archive.org/web/20200119030613/https://jcp.org/en/jsr/detail?id=282">JSR-282</a></li>
<li>Level : extremely hard</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3107" class="section-6">
<h1 class="book-heading">Implement virtio drivers for jnode (A) (*/**) </h1>
<ul>
<li>Description : Virtio allows to have drivers (network, hard drive ...) faster than regular ones running in virtualized environments (<a href="https://web.archive.org/web/20200119030613/http://www.linux-kvm.org/">kvm</a>, <a href="https://web.archive.org/web/20200119030613/https://www.virtualbox.org/">VirtualBox</a>, <a href="https://web.archive.org/web/20200119030613/https://downloads.vmware.com/d/info/datacenter_downloads/vmware_server/2_0">vmware</a>, <a href="https://web.archive.org/web/20200119030613/http://www.xen.org/">xen</a> ...).</li>
<li>References :
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Rusty_Russell">Rusty Russell</a> (a linux kernel developer) is writting <a href="https://web.archive.org/web/20200119030613/https://ozlabs.org/~rusty/virtio-spec/virtio-spec-0.8.1.pdf">specifications of virtio</a>. He will really appreciate your feedback (his mail is in the document).</li>
<li>You can also have a look in the <a href="https://web.archive.org/web/20200119030613/http://lxr.linux.no/#linux+v2.6.31/drivers/virtio/">sources of the virtio drivers for the linux kernel</a>. You should also have a look at the <a href="https://web.archive.org/web/20200119030613/http://lxr.linux.no/#linux+v2.6.31/include/linux/">includes directory</a> (search for virtio*.h files).</li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.linux-kvm.org/page/Virtio" title="http://www.linux-kvm.org/page/Virtio">http://www.linux-kvm.org/page/Virtio</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://lwn.net/Articles/239238/" title="http://lwn.net/Articles/239238/">http://lwn.net/Articles/239238/</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://portal.acm.org/citation.cfm?id=1400108&amp;dl=GUIDE&amp;coll=GUIDE&amp;CFID=55419847&amp;CFTOKEN=12653837" title="http://portal.acm.org/citation.cfm?id=1400108&amp;dl=GUIDE&amp;coll=GUIDE&amp;CFID=55419847&amp;CFTOKEN=12653837">http://portal.acm.org/citation.cfm?id=1400108&amp;dl=GUIDE&amp;coll=GUIDE&amp;CFID=5...</a></li>
<li>small doc explaining the basic idea : <a href="https://web.archive.org/web/20200119030613/https://ozlabs.org/~rusty/index.cgi/tech/2007-05-21.html" title="http://ozlabs.org/~rusty/index.cgi/tech/2007-05-21.html">http://ozlabs.org/~rusty/index.cgi/tech/2007-05-21.html</a></li>
<li>also look at existing implementations (in kvm)</li>
</ul>
</li>
<li>Steps
<ol>
<li>write a <a href="https://web.archive.org/web/20200119030613/http://www.jnode.eu/report-data/javadoc/full/index.html?org/jnode/driver/DeviceToDriverMapper.html">DeviceToDriverMapper</a> that will detect virtio devices in jnode. Look at the function <a href="https://web.archive.org/web/20200119030613/http://lxr.linux.no/#linux+v2.6.31/drivers/virtio/virtio_pci.c#L591">virtio_pci_probe</a> in the linux kernel.</li>
<li>write a driver for the virtio devices
<ol>
<li>block : Look at <a href="https://web.archive.org/web/20200119030613/http://lxr.linux.no/linux+*/include/linux/virtio_blk.h">virtio_blk.h</a> and <a href="https://web.archive.org/web/20200119030613/http://lxr.linux.no/#linux+v2.6.31/drivers/block/virtio_blk.c">virtio_blk.c</a> in the linux kernel</li>
<li>network : Look at <a href="https://web.archive.org/web/20200119030613/http://lxr.linux.no/linux+*/include/linux/virtio_net.h">virtio_net.h</a> and <a href="https://web.archive.org/web/20200119030613/http://lxr.linux.no/#linux+v2.6.31/drivers/net/virtio_net.c">virtio_net.c</a> in the linux kernel</li>
</ol>
</li>
</ol>
<li>Level : easy/average</li>
<li>Assigned to : <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/10144">Ibrahim Ghiyati</a> and <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/10296">Yi Xenfung</a></li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;The <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Git_%28software%29">git</a> repository is located <a href="https://web.archive.org/web/20200119030613/https://gitorious.org/+jnode-virtio-drivers-developers/jnode/virtio-drivers">here</a></p>
</div>
<div id="node-3120" class="section-6">
<h1 class="book-heading">Implement write support for the iso 9660 file system</h1>
<ul>
<li>Description : iso 9660 is a norm that defines how data are stored in compact discs (cdrom, dvdrom ...). For now, we have only a limited read support for cdroms.</li>
<li>Level : Hard ?</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3117" class="section-6">
<h1 class="book-heading">Integrate JDistro</h1>
<ul>
<li>Description : It would be great to have that advanced desktop in JNode. I am not sure if there is really a licensing issue or not (<a href="https://web.archive.org/web/20200119030613/http://www.jdistro.com/">JDistro</a> is GPL and JNode is LGPL)</li>
<li>Level : Hard</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3106" class="section-6">
<h1 class="book-heading">Port jnode to another CPU</h1>
<ul>
<li>Description : For now, we only support <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/X86">x86</a> <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/CPU">CPU</a>s but it would be great to have support for other <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/CPU">CPU</a>s. Examples : <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/ARM_architecture">ARM</a> (used in small devices like mobiles), <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/PowerPC">PowerPC</a>, ...
<li>Level : hard</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3103" class="section-6">
<h1 class="book-heading">Port jnode to grub 2</h1>
<ul>
<li>Description : Currently, JNode uses the <a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/grub/">grub</a> <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Booting">bootloader</a>. Using <a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/grub/grub-2.en.html">grub 2</a> would allow to openup to more plateforms like, for example, non <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/BIOS">BIOS</a>-based architectures (aka <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Extensible_Firmware_Interface">EFI</a> ones).</li>
<li>Level : average/hard (many informations are needed to complete the task)</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3109" class="section-6">
<h1 class="book-heading">Write a driver for a sound card</h1>
<ul>
<li>Tips : implement a driver for <a href="https://web.archive.org/web/20200119030613/https://www.intel.com/design/chipsets/hdaudio.htm">intelhda</a> since all sound chips nowadays comply with it.</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3110" class="section-6">
<h1 class="book-heading">Write a driver for Serial ATA (sata)</h1>
<ul>
<li>Reference : Wikipedia page about <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Serial_ATA">Serial ATA (sata)</a>
<li>Tips : implement compliance with <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/Advanced_Host_Controller_Interface">ahci</a>.</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3119" class="section-6">
<h1 class="book-heading">Write a file system checker (**/***)</h1>
<ul>
<li>Description : Writing a file system checker would not only help ensure that a file system is clean at boot time (like linux distro are doing). It will also allow to help fixing bugs in the current implementations of the file systems. For each of these file systems, a checker could be a student project by itself : ext2, fat32, fat12/16, ntfs (I am not sure about that one since it's hard to get ntfs specifications). The first student to work on a file system checker will have to define an API because we don't have yet one.</li>
<li>Level : Average (depends on the file system complexity)</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3116" class="section-6">
<h1 class="book-heading">write a virtual keyboard</h1>
<ul>
<li>Description : look at <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/973#comment-3099">that topic</a> for more informations</li>
<li>Tips : <a href="https://web.archive.org/web/20200119030613/http://www.jdistro.com/">JDistro</a> has virtual keyboard which should be made standalone for reuse in JNode but I am not sure if there is really a licensing issue or not (JDistro is GPL and JNode is LGPL) ...</li>
<li>Level : easy</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3114" class="section-6">
<h1 class="book-heading">write an open GL driver</h1>
<ul>
<li>References : <a href="https://web.archive.org/web/20200119030613/https://www.opengl.org/">open GL organisation</a></li>
<li>Level : extremely hard</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3118" class="section-6">
<h1 class="book-heading">Write another desktop for JNode</h1>
<ul>
<li>Description : To be specified with the student.</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3112" class="section-6">
<h1 class="book-heading">Write SWT peers</h1>
<ul>
<li>Description : <a href="https://web.archive.org/web/20200119030613/https://www.eclipse.org/swt/">SWT</a> is the widget toolkit used by <a href="https://web.archive.org/web/20200119030613/https://www.eclipse.org/">eclipse</a>. It has a java API and rely on native peers for the actual display of widgets. To be able to use SWT, one should implement SWT peers for JNode.</li>
<li>Level : average/hard</li>
<li>Assigned to :</li>
</ul>
</div>
</div>
<div id="node-3121" class="section-5">
<h1 class="book-heading">Generic projects</h1>
<p>Here is a list of generic projects</p>
<p><u>Legend</u> :<br/>
(A) : project assigned</p>
<p><u>Level</u> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*) : easy<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(**) : average<br/>
&nbsp;&nbsp;&nbsp;(***) : difficult<br/>
&nbsp;&nbsp;(****) : very hard<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: unknow</p>
<div id="node-3126" class="section-6">
<h1 class="book-heading">Implement an API</h1>
<ul>
<li>Description : which APIs ?</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3123" class="section-6">
<h1 class="book-heading">Write a command</h1>
<ul>
<li>Description : It could be a big command or a set of smaller commands. It should be Linux commands.</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3124" class="section-6">
<h1 class="book-heading">Write a plugin for eclipse ?</h1>
<ul>
<li>Description : for doing what ?</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3125" class="section-6">
<h1 class="book-heading">Write drivers for old legacy devices</h1>
<ul>
<li>Description : which devices ?</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
</div>
<div id="node-3122" class="section-5">
<h1 class="book-heading">Experimental projects</h1>
<p>Here is a list of experimental projects</p>
<p><u>Legend</u> :<br/>
(A) : project assigned</p>
<p><u>Level</u> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(*) : easy<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(**) : average<br/>
&nbsp;&nbsp;&nbsp;(***) : difficult<br/>
&nbsp;&nbsp;(****) : very hard<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: unknow</p>
<div id="node-3128" class="section-6">
<h1 class="book-heading">Study and experiment usage of gradle as a replacement of our build system</h1>
<ul>
<li>Description : For now, we are using ant + a set of custom ant tasks. I think <a href="https://web.archive.org/web/20200119030613/http://www.gradle.org/">gradle</a>, in addition to keep things from <a href="https://web.archive.org/web/20200119030613/https://ant.apache.org/">ant</a>, <a href="https://web.archive.org/web/20200119030613/https://maven.apache.org/">maven</a> and <a href="https://web.archive.org/web/20200119030613/https://ant.apache.org/ivy/">ivy</a>, add interesting possibilities :
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://groovy.codehaus.org/">groovy</a> scripting ability : more flexibility than xml based build systems. For example, you can do something before and/or after a given (set of) task(s) : it could be used to transform ant's jar task into a jnode's plugin packager (a jnode plugin is a regular jar file which contain a plugin descriptor file)
           </li>
<li>interaction with ivy : look at <a href="https://web.archive.org/web/20200119030613/http://faq.gradle.org/ivy">gradle's faq for ivy</a></li>
<li>interaction with maven 2 : look at <a>gradle for maven 2 users</a> and <a href="https://web.archive.org/web/20200119030613/http://faq.gradle.org/maven">gradle's faq for maven</a></li>
<li>interaction with ant : look at <a href="https://web.archive.org/web/20200119030613/http://faq.gradle.org/ant">gradle's faq for ant</a></li>
<li>you can find main features <a href="https://web.archive.org/web/20200119030613/http://www.gradle.org/0.8/docs/userguide/overview.html">here</a></li>
</ul>
</li>
<li>Level :</li>
<li>Assigned to :</li>
</ul>
</div>
<div id="node-3127" class="section-6">
<h1 class="book-heading">Study and experiment usage of OSGi to manage plugins</h1>
<ul>
<li>Study and experiment usage of <a href="https://web.archive.org/web/20200119030613/http://www.osgi.org/">OSGi</a> as a replacement of current jnode's specific plugin framework (inspired by eclipse's one)</li>
<li>Advice : The developer will have to deal with with Classloaders. It sounds to be a very hard task; It might even happen that's not a suitable replacement for our current plugin framework;<br/>
       Moreover, the incoming modules for openjdk7 (<a href="https://web.archive.org/web/20200119030613/http://www.openjdk.org/projects/jigsaw/">project jigsaw</a>) might come in the way/interfere with osgi. So, in my opinion, it's an <b><u>heavily experimental task</u></b> !</li>
<li>Tips : Look at one of these implementations of OSGi :
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://felix.apache.org/">Apache Felix</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://www.eclipse.org/equinox/">Eclipse equinox</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.knopflerfish.org/">knopflerfish</a></li>
</ul>
</li>
<li>Assigned to :</li>
</ul>
</div>
</div>
</div>
</div>
<div id="node-47" class="section-3">
<h1 class="book-heading">Contact</h1>
<h2>Forums</h2>
<p>JNode is discussed in several <a href="/web/20200119030613/http://www.jnode.org/forum">forums</a>. These forums are now prefered above the Sourceforge mailinglists.</p>
<h2>IRC</h2>
<p>You can also use the <a href="https://web.archive.org/web/20200119030613/irc://irc.oftc.net/JNode.org">#JNode.org at irc.oftc.net</a> IRC channel.</p>
<h2>GIT commits</h2>
<p>Follow us on <a href="https://web.archive.org/web/20200119030613/https://github.com/jnode/jnode">GitHub</a> to track all code changes.</p>
<h2>Twitter</h2>
<p>Use #JNode to talk about JNode on twitter.</p>
<h2>Or else</h2>
<p>For all other questions, suggestion and remarks, please contact the project admins: <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#3f5a48504a4b7f4f4d5e51584c525e11515a4b"> Ewout Prangsma (aka epr)</a>, <a href="/web/20200119030613/http://www.jnode.org/cdn-cgi/l/email-protection#e48897858a908c85a48e8a8b8081ca968b">Levente Santha (aka lsantha)</a>.</p>
</div>
<div id="node-127" class="section-3">
<h1 class="book-heading">Release procedure</h1>
<p>This document describes what is needed to make and publish a new release of JNode.</p>
<p><b>Preparation</b></p>
<ol>
<li>Start with a clean copy of the SVN trunk (no extra files, no missing files)</li>
<li>Update all patches to be included in the release</li>
<li>If the checked-in copy of "builder/lib/jnode-configure-dist.jar" is older than any of the source code for the tool (in "builder/src/configure"), run the following:<br/>
<pre>$ cp all/build/descriptors/jnode-configure.jar \
     builder/lib/jnode-configure-dist.jar
$ svn commit builder/lib/jnode-configure-dist.jar
</pre><li>Set the new version number in the "jnode-ver" property in build.xml</li>
<li>Execute "build clean"</li>
<li>Execute "build" and verify the build</li>
<li>Boot and test the system from the network</li>
<li>Boot and test the system in VMWare</li>
<li>Execute "build cd-x86"</li>
<li>Boot and test the system from the CDROM</li>
<li>Boot and test the system from the CDROM DHCP target</li>
</ol>
<p><b>Uploading</b></p>
<ol>
<li>Execute "ant -f all\build.xml upload"</li>
<li>Create release in SF File Release system</li>
<li>Mark release hidden</li>
<li>Write release notes and changelog</li>
<li>Attach jnode-{version}.iso.gz to release</li>
<li>Set attributes to "i386", "gz"</li>
<li>Attach jnodesources-{version}.tar.gz to release</li>
<li>Set attributes to "Platform independent", "gz"</li>
<li>Verify the upload by downloading the uploaded files</li>
<li>Mark release active</li>
</ol>
<p><b>Website adjustments</b></p>
<ol>
<li>Add new changelog book page "from {previous-version} to {version}", copy entries from changelog "from {previous-version} to current SVN version"</li>
<li>Empty changelog "from {previous-version} to current SVN version"</li>
<li>Create static page "Release {version}", with Download term and mark or change the "Website" option from "&lt;none&gt;" to "Downloads"</li>
</ol>
<p><b>SVN actions</b></p>
<ol>
<li>Copy the entire trunk to a branch "jnode_x_y_z" where x, y, z is the version number</li>
<li>Set the next development version number (x.y.(z+1)-dev) in the "jnode-ver" property in build.xml and check that in</li>
</ol>
</div>
</div>
<div id="node-2936" class="section-2">
<h1 class="book-heading">Glossary</h1>
<p>This page gives working definitions for common terms that we use in the JNode documentation.  While we will try to be consistent with terminology used in other places, we reserve the right to be inconsistent.</p>
<dl>
<dt>Java Virtual Machine</dt>
<dd>A Java Virtual Machine (JVM) is an execution engine for Java programs.  A JVM 'executes' bytecodes using various techniques including bytecode interpretation and compilation to / execution of native code.</dd>
<dt>Native Code Compiler</dt>
<dd>A native code compiler is a compiler that translates a program to native code; i.e. instructions in the instruction set of a physical machine.  In the JNode context, the input to the native compiler consists of Java bytecode files.</dd>
<dt>Native Compiler</dt>
<dd>Short for "native code compiler".</dd>
<dt>Bytecode Compiler</dt>
<dd>A bytecode compiler is a compiler that translates to Java bytecode files.  The input to a bytecode compiler could be Java source code or (in theory) source code in some other programming language.</dd>
<dt>JIT Compiler</dt>
<dd>A JIT compiler or "Just-in-time" compiler is a native compiler that compiles code at or after class load time.  The JNode native code compilers operate as JIT compilers when they run on JNode, and as ahead-of-time (non-JIT) compilers when they used in the build environment to compile code for the JNode boot image.</dd>
<dt>Hotspot (tm)</dt>
<dd>Hotspot is the name of a family of Sun Java virtual machines; see this <a href="https://web.archive.org/web/20200119030613/https://en.wikipedia.org/wiki/HotSpot">Wikipedia page</a>.</dd>
<dt>Hotspot</dt>
<dd>A hotspot is method or section of code that is determined (by profiling) to be executed very frequently.  A profiler-based JIT compiler will typically focus on compiling hotspot methods to native code.</dd>
<dt>Boot Image</dt>
<dd>This is the memory image loaded by a bootstrap loader to start an operating system such as JNode.</dd>
<dt>Boot Image Builder</dt>
<dd>The JNode boot image builder creates the JNode boot image as described on the <a href="/web/20200119030613/http://www.jnode.org/node/64">Build Process</a> page.</dd>
<dt>Garbage Collector</dt>
<dd>The system component that is responsible for reclaiming memory resources for Java objects that have become unreachable.</dd>
<dt>Plugin</dt>
<dd>An assembly of related classes that are loaded and unloaded together.  JNode's plugin mechanism is described in the <a href="/web/20200119030613/http://www.jnode.org/node/136">Plugin Framework</a> page. </dd>
<dt>Plugin descriptor</dt>
<dd>An XML file that defines the metadata for a plugin and lists its dependencies and exports.  A plugin descriptor may also list security permissions granted to classes in the plugin, command aliases and syntaxes, and various plugin-specific configuration information.</dd>
<dt>Driver</dt>
<dd>A driver is an operating system component that adapts an abstract service API to a particular technology.  In JNode, we have "device drivers" that adapt the Device API to hardware devices, file system drivers that adapt the FileSystem APIs for specific file system types, network drivers, frame-buffer drivers and so on.</dd>
<dt>Binary Device Driver</dt>
<dd>JNode does not support vendor-supplied binary device drivers as a matter of principle.  So don't bother asking!</dd>
<dt>Service</dt>
<dd>A service is a JNode object that performs some important operating system level function.  JNode services are typically located using the InitialNamingService.</dd>
<dt>Manager</dt>
<dd>A manager is a JNode service that manages a collection of resources.  For example, the DeviceManager manages the Device instances that have been configured.</dd>
<dt>Console</dt>
<dd>A console is an abstraction that combines a keyboard and a character oriented display to provide an analog for an old-style "terminal".</dd>
<dt>Console mode</dt>
<dd>This describes the system state where the (PC) display is in VGA mode, showing an array of (typically) 24x80 fixed width characters.</dd>
<dt>Virtual console</dt>
<dd>In console mode, JNode supports a number of virtual consoles that are mapped to the physical keyboard and the display.  <b>ALT-Fn</b> is used to switch between virtual consoles.</dd>
<dt>Shell</dt>
<dd>A shell is a JNode object that provides a keyboard-oriented interface for entering commands to be run.</dd>
<dt>Command class</dt>
<dd>A command class is a Java class with an entry point method that allows a Java application to be run from a command line or script.</dd>
<dt>Command Interpreter</dt>
<dd>A command interpreter is an object that a JNode shell uses to split command input (and scripts) into commands, and manage their execution.  JNode supports multiple command interpreters with different levels of functionality.  Command interpreters variously handle such things as stream redirection, setting and expansion of shell variables, file pattern expansion, compound command handling and shell function execution.</dd>
<dt>Command Invoker</dt>
<dd>A command invoker is an object that a JNode shell uses to run a command class.  There are a number of different invokers that run commands in different ways; e.g. in a new Java Thread, a new Proclet or a new Isolate.</dd>
<dt>Isolate</dt>
<dd>The Isolate mechanism allows applications to be run in JNode that shields them from unwanted affects of other applications.  A command or application that is run an isolate appears to be running in its own JVM.  Isolates can be safely suspended, resumed and killed.  JNode's implementation of Isolates is not yet complete.</dd>
<dt>Proclet</dt>
<dd>The Proclet mechanism is a JNode specific alternative to Isolates that tries to provide applications with the illusion that they "own" some key bits of global state; i.e. the System.in,out,err streams, the System Properties object and the System Environment object.  Since, the illusion is not perfect, we are likely to de-support proclets when the isolate implementation is completed.</dd>
<dt>Alias</dt>
<dd>An alias is a short name for a command class that is used run it from the command line.  For example, "cat" is an alias for "org.jnode.shell.command.CatCommand".  Aliases are typically defined in the plugin descriptor file for the command classes plugin.</dd>
<dt>Command Syntax</dt>
<dd>JNode native commands typically rely on the Command Syntax subsystem to parse the arguments passed to the command.  A command registers an abstract syntax for its arguments, and a concrete syntax is defined as a separate XML fragment / file.  Common libraries do the work of parsing the arguments, and also provide context sensitive argument completion and command help.</p>
<dt>Unsafe</dt>
<dd>Unsafe is a special JNode class (implemented in assembler) that performs certain low-level tasks such as reading and writing to hardware IO ports, and handling low-level 'debug' output; see "kdb".</dd>
<dt>Magic</dt>
<dd>Magic classes are special classes recognized by the JNode native compiler.  These classes typically circumvent the Java type system in some way.</dd>
<dt>MagicPermission</dt>
<dd>Only classes that are granted this permission may call methods on Magic classes.  Examples of classes that require magic permission include hardware device drivers and the heap managers.</dd>
<dt>NanoKernel<br/>
<dt>
<dd>This term is historically used to refer to that tiny part of the JNode core which is implemented in x86 assembler.  This code mostly deals with bootstrapping and writing to the serial port.  The JNode NanoKernel is not a real "nano-kernel" in the conventional sense of the word.</dd>
<dt>kdb</dt>
<dd>The "kdb" or Kernel DeBugger is JNode NanoKernel functionality that redirects all output from "Unsafe.debug(...)" calls to the serial port. It is used for debugging via low-level system trace-prints and for capturing output from kernel panics.  (It is not really a debugger in the conventional sense.)</dd>
<dt>Multiboot</dt>
<dd>The <a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/grub/manual/multiboot/html_node/index.html">Multiboot specification </a> is defacto standard for booting operating systems that is supported by many boot loaders and operating systems. JNode's boot image is multiboot compatible.</dd>
</dl>
<p>Please feel free to add extra terms or offer better definitions as comments.</p>
</div>
<div id="node-163" class="section-2">
<h1 class="book-heading">Proposals</h1>
<p>In this part of the documentation, new feature, design &amp; architecture proposals are worked out.</p>
<p>Each proposal should contain at least to following topics:</p>
<ul>
<li>The goal; what does this proposal want to achieve</li>
<li>A functional description of the item(s) proposed</li>
<li>If possible a first architecture and design idea</li>
<li>References, like standards, other proposals etc</li>
<li>Names of the submitter(s) of the proposal</li>
</ul>
<p>Anyone is invited to comment on the proposals.</p>
<div id="node-261" class="section-3">
<h1 class="book-heading">A New Garbage Collection Algorithm</h1>
<p>A while ago I had a suggestion for garbage collection that relied on the MMU units of modern processors. EPR didn't like this for want of a simple/generic solution. So this is a second attempt.<br/>
<br><br/>
Deep breath, here goes.... </p>
<p>
<b>Introduction</b><br/>
<br><br/>
There are two goals of a OS Java GC: </p>
<ol>
<li>Efficiency ideally less than 10% of execution time spent garbage collecting.</li>
<li>Interactivity. No good if the system halts for 5 minutes GC and preventing use of the system. This is obviously completely inappropiate for a desktop system. </li>
</ol>
<p>I hope people agree with me so far. So what is the state of play with current algorithms? They mostly seem to be based on the Generational GC principle. That is only GC the memory allocated since the last GC unless the system is out of memory, in which case collect the generation before that and so on. </p>
<p>
The problem with this approach, is it delays the inevitable. Eventually a full system GC is required. This halts the system for a large amount of time. Also a simple write barrier is required on pointer writes. This is so the roots to the lastest generation can be detected. </p>
<p>
Having said this, generational GC is a good system that works in most environments, it's efficient and modern VM's use generational GC. In my opinion generational GC would work very well with a OS VM if the pause time for the occasional full memory GC could be mitigated. This is what my proposal concerns. </p>
<p>
<b>Overview</b><br/>
<br><br/>
So lets interleave a slow running full system GC with normal program operation. The problem is the directed connectivaty graph of the program is constantly changing. By requiring to much co-operation between the mutator (running threads) and the GC slows down the mutator. You might end up with a fine grained GC algorithm with no pause times but the whole system would run slowly. </p>
<p>
I see the answer as a compromise. Break the memory into chunks. The GC can halt the entire system while it collects the chunk. The bigger the chunk the bigger the pause time but the more efficient the overall system. The advantage of this approach is the integration of the mutator with the GC is very small. In fact no larger than would be required with a traditional generational GC algorithm. </p>
<p>
<b>Trapping intra-block pointer writes</b><br/>
<br><br/>
So elaborating on the chunk idea, what is required is that we trap all pointer references between chunks. by doing this we have a set of all possible roots to a chunk. For efficiencies sake lets assume all chunks are the same size and are a power of 2. There are no gaps between the chunks and the first starts at byte n * chunksize. Location 0 is memory is a bad page to trap null pointer exceptions. what we're essentially talking about is memory blocks. </p>
<p>
Its possible to trap intra-block pointers with three instructions on every pointer write. A smart compiler can cut down the times even this check is done by using the notion that pointer copying local to an object can never trigger the case. This assumes that objects never cross block boundaries. There are exceptions for this, for instance large objects bigger than the blocksize but these can be handled separately. </p>
<p>
The code to trap intra block pointer writes looks like the following: </p>
<p><i><br/>
xor sourcePointer, destPointer<br><br/>
or result, blockSizeMinus1<br><br/>
jnz codeToHandleIntraBlockPointers<br><br/>
</i>
<p>
As people can see, including the jump its only three instructions on the x86 (I think!!!)<br/>
This only has to be triggered when a member pointer of one class is set. Not for intermediate local variables. </p>
<p>
<b>Storing intra-block pointer writes</b><br/>
<br><br/>
Pointers that are detected as being intra-block need to be stored for later analysis. What this document proposes, is to have a system wide array of pointers with as many elements in it as blocks.  The size of this array would be determined by the following equation:</p>
<p>
<i>size of array = amount of system memory / size of block</i></p>
<p>
Each element in the array corresponds to a block in memory.  Each array element contains a list of pointers pointing to elements held in the corresponding block.  </p>
<p> The address of the source pointer is added to the linked list pointed to by the array element that corresponds to the block that contains the destination pointer. The effect of this is each block now has a set of addresses of pointers pointing into it. Of course there can be duplicates, but the critical thing is this list is time ordered. Thats very important. </p>
<p>
Now the elements in these lists do not get modified by the mutator after they are created. This means that a thread running in parrallel can scan these lists and do the following:<br/>
<br></p>
<ul>
<li>Remove obsolete references</li>
<li>Remove duplicates</li>
</ul>
<p>This will trim the list down to the bare root set of a given block. The time taken to do the above is proportional to the size of the list which is directly proportional to the number of intra-block pointer writes. Essentially what we're doing is delaying the processing of the lists so we can process a longer list in one go. This increases the change of duplicates in the list and therefore can make the process a lot more efficient. We can also run the list scanning algorithms on different threads therefore processors and possibly schedule more at system idle time. </p>
<p>
But how are duplicates in the list detected and obsolete references. </p>
<p>
Firstly to detect duplicates. With modern architectures we generally cant locate an object across a machine word. This means for instance that on a 32 bit architecture which is 4 bytes the bottom 3 bits of all pointers will be zero. This could be used as an information store. When scanning the list the pointers can be marked. If a pointer is allready marked dont add it to the new list thats building. </p>
<p>
Secondly what about obsolete references? This is simple, if the pointer points to some other block now, its obsolete. </p>
<p>
So the algorithm so far is this. Run a paralled thread to the mutators to cut down the pointers into a certain block. This incoming pointer list for the block will keep growing so we can say as soon as a certain percentage of the list is processed all the mutators are halted. The next step is to process the remained part of the list for the block we are just about to garbage collect. Now contained in that list we should have a valid set of roots for the block. We can garbage collect the block and move all the reachable objects to the new heap thats growing. Fix up the roots to point to the new object locations and the old block is now ready to be recycled. </p>
<p>
the more observant readers will have asked about intra-block cycles.  The technique I use is to have two categories of reached objects:</p>
<ol>
<li>strongly reached</li>
<li>weakly reached</li>
</ol>
<p>The idea of strongly reached objects is that there was a proveable link to the object sometime during the last cycle.  Weakly reached objects could either be junk or referenced.  Strong reached objects are copied out to a new heap.  Weakly reached objects can either be left of place or copied to a weakly reached heap.  When we have no referenced from the strongly reached haep to anywhere else we know we can stop garbage collecting.</p>
<p>
... more to come ...</p>
</div>
<div id="node-131" class="section-3">
<h1 class="book-heading">Graphics framework</h1>
<p>This is where the graphics framework requirements &amp; specification will come.<br/>
<br><br><br/>
Current project members:</p>
<ul>
<li>Valentin</li>
<li>Levente</li>
<li>Nathan</li>
</ul>
<p><br><br/>
My current thoughts on the graphics framework is that the graphics driver is passed the basic hardware resources it needs.  It cannot access any other hardware resources.<br/>
<br><br/>
<br><br/>
The driver needs to provide a list of supported video modes, resolutions and refresh rates.  The driver might also provide infromation about the attached video display device.  E.g. flat panel, resolution, make model refresh rate etc.<br/>
<br><br/>
<br><br/>
There needs to be a standard way to query the driver about the supported display modes.  Either we have the display driver implementing an interface or have an abstract method on a base class.<br/>
<br><br><br/>
<b>
<ul>
<li>public String getVideoCardManufacturer();</li>
<li>public String getVideoCardModel();</li>
<li>public int getAmountOfVideoMemory();</li>
<li>public DisplayMode[] getSupportedDisplayModes();</li>
<li>public DisplayMode getCurrentDisplayMode();</li>
<li>public void setDisplayMode(DisplayMode m) throws DisplayModeNotSupportedException; </li>
</ul>
<p></b><br/>
The DisplayMode interface might have the following methods:<br/>
<br><br/>
<b>
<ul>
<li>public boolean isTextMode();</li>
<li>public Dimension getResolution();</li>
<li>public int getRefreshRate();</li>
<li>public PixelFormat getPixelFormat();</li>
<li>public boolean has3DAcceleration();</li>
<p></b></ul>
<p><br><br/>
The above interface begs the question whether there should be two sub-interfaces, TextDisplayMode and GraphicsDisplayMode.  Should the graphics driver export the two lists separately?  Most graphics cards enter a text display mode by default I think.  Some export their own special text display modes.</p>
<p><br><br><br/>
<b><br/>
Coments from Valentin:<br/>
</b><br/>
<br><br><br/>
My Opinion is that we should pack this informations that the driver can send back into an external class called GraphichDriverInfo and that we should have 2 other interfaces called TextDisplayMode and GraphicsDisplayMode that extend DisplayMode interface. So the list of classes/interfaces(and there methods) should look like this:<br/>
<br><br><br/>
<b>
<ul>
<li>public interface GraphicDriver;</li>
<ul>
<li>public GraphicDriverInfo getInfo();</li>
</ul>
<li>public class GraphicDriverInfo;</li>
<ul>
<li>public String getVideoCardManufacturer();</li>
<li>public String getVideoCardModel();</li>
<li>public int getAmountOfVideoMemory();</li>
<li>public DisplayMode[] getSupportedDisplayModes();</li>
<li>public DisplayMode getCurrentDisplayMode();</li>
<li>public void setDisplayMode(DisplayMode m) throws DisplayModeNotSupportedException; </li>
</ul>
<li>public interface DisplayMode;</li>
<ul>
<li>public Dimension getResolution();</li>
<li>public int getRefreshRate();</li>
</ul>
<li>public interface TextDisplayMode extends DisplayMode;</li>
<ul>
<li>public boolean isColorTextSupported();</li>
</ul>
<li>public interface GraphicDisplayMode extends DisplayMode;</li>
<ul>
<li>public PixelFormat getPixelFormat();</li>
<li>public boolean has3DAcceleration();</li>
</ul>
<p></b></ul>
<p><br><br/>
 Everyone's input on this is wellcomed.</p>
</div>
<div id="node-811" class="section-3">
<h1 class="book-heading">Isolate proposal</h1>
<p><b>Goal</b><br/>
Isolates are intended to seperate java programs from each other, in order to protect java programs from (intentional) errors in other programs.</p>
<p><b>Proposal (in concept)</b><br/>
I propose to make an Isolates implementation that is somewhere between full isolatation and full sharing. With the goal in mind, programs should be protected from each other, which means that they should not interfere each other in terms of resources, which are typically:</p>
<ul>
<li>Memory</li>
<li>Threads</li>
<li>Locks</li>
</ul>
<p>This means that everything that can be used to interfere other programs on these items must somehow be protected. Everything else must be as shared as possible, in order to minimize resource usage.</p>
<p>Think can be achieved by isolating certain resources, and making serveral services aware of the fact that there are isolates. E.g. a network stack should be aware that network bandwidth is shared nicely across all users, in order to prevent a single program from eating away all network bandwitdh.</p>
<p><b>What is Isolated v.s. Shared</b><br/>
Isolated:</p>
<ul>
<li>Static variables</li>
<li>Java class structures (Class, Field, Method)</li>
<li>Class initialization</li>
<li>Java threads (java.lang.Thread)</li>
<li>Java object heaps</li>
</ul>
<p>Shared:</p>
<ul>
<li>Static variable indexes (in statics table)</li>
<li>Internal class structures (VmType, VmField, VmMethod)</li>
<li>Compiled (native) code</li>
<li>Internal thread structures (VmThread)</li>
<li>OS services (drivers, filesystems, networking)</li>
<li>System resources (memory, IRQ)</li>
<li>Raw memory blocks (MemoryBlockManager)</li>
</ul>
<p>Explaination:<br/>
Static variables in JNode are implemented in statics tables. The index (of a static variable) in this table must be constant across all isolates, otherwise the compiled code needs to retrieve the index on every static variable get/set which is very expensive. Havig said this, this does imply that statics table will become pretty large. This can be solved by implementing a cleanup strategy that frees indexes when they are no longer used.</p>
<p>For the rest, the seperation is made in terms of publicly accessible versus internal. E.g. a java program can synchronize on a Class instance, but since these are isolated, this will not block all other programs. </p>
<p>Isolated java heaps will have significant implications on the code of the shared services, so this will something to do in step 2.</p>
<div id="node-816" class="section-4">
<h1 class="book-heading">Isolated java heaps</h1>
<p>Isolating memory allocation will cause some problems that need to be dealed with.</p>
<p><b>Problems</b><br/>
When an object is allocated in one isolate, and this isolate is closed, the object is also removed. But what if this object is registered somewhere in another isolate?<br/>
Answer: A problem. Objects may not cross isolate bounderies.</p>
</div>
</div>
<div id="node-164" class="section-3">
<h1 class="book-heading">JNode Installer proposal</h1>
<p><dl>
<dt><b><i>Name of the submitter:</i></b></dt>
<dd>Valentin Chira</dd>
<p><br></p>
<dt><b><i>Goal of the proposal:</i></b></dt>
<dd>Unify the way modules are installed / maintained in JNode. By module one must understand any application, library, driver or plug-in.The installer repository must be also used to lunch installed applications.</dd>
<p><br></p>
<dt><b><i>Functional description:</i></b></dt>
<dd>The Installer should serve as a main administration tool for the installed modules and as a tool to be used to install new modules in JNode. One of the modules should be JNode itself. Each module definition must be a list of its sub-modules, own files, external library references (needed to run the module), security requirements, external installer, etc. The user must be able to interact with the installer through a command line/graphical interface and perform administrative operations like updating a module, installing new modules or removing a module. For ease of use the user must be able define modules clusters and aggregate more modules in a cluster. For example one of this clusters can be called system and be JNode itself. One important function that the installer must support is version administration for modules. The installer must support the administration of modules at the level of version so that multiple version of the same module can be installed. The first use case for the installer is JNode installation itself. The JNode installation should consist of installing a minimal JNode version on the HDD edit the system cluster modules list and than call the installer to update/install the modules from the list, ex: installer u system.</dd>
<p><br></p>
<dt><b><i>Architecture</b></i></dt>
<dd>
The installer module should be based on a standard Java technology. This is why I believe we should use JNLP which offers a standard way to install modules. The installer should be a JNLP client that has a cache/repository attached. The Installer should cache the JNLP files for all installed modules and also keep an index file for the installed modules. I propose that this index file to be an xml file called index.xml. The storage representation should look like this:</p>
<p><br><br/>
<br></p>
<dl>
<dt> /jnode/installer/repository/</dt>
<dd>.../app1/app1.jnlp</dd>
<dd>.../app1/submodule1.jnlp</dd>
<dd>.../app2/app2.jnlp</dd>
<dd>.../app2_ver_0.01/app2.jnlp</dd>
<dd>.../lib1/lib1.jnlp</dd>
<dd>.../driver1/driver1.jnlp</dd>
<dt> /jnode/installer/index.xml</dt>
</dl>
<p><br><br/>
The index.xml file will contains at least one entry for each installed module and all created clusters. This is should look pretty much like a database(maybe we could use here a small xml database engine). The index file is loaded at first use of the installer and should be cached in memory. The index.xml structure should be something like this:<br/>
<br><br><br/>
<i></p>
<dl>
<dt>module&gt;</dt>
<dd>name="app1"</dd>
<dd>version=0.01</dd>
<dd>cluster="system"</dd>
<dd>JNLPfile="app1.jnlp"</dd>
<dd>updateURL="www.jnode.org/autoupdate/system/app1.jnlp"</dd>
<dt>/module&gt;</dt>
<dt>cluster&gt;</dt>
<dd>name="drivers"</dd>
<dd>cluster="system"</dd>
<dt>/cluster&gt;</dt>
<dt>cluster&gt;</dt>
<dd>name="system"</dd>
<dt>/cluster&gt;</dt>
</dl>
<p></i><br/>
<br><br/>
The process of installing a new application should be no more than downloading the jnlp file, copy the files described there and than modify the index.xml file to add the new installed application. Here we could have problems if another application with the same name is installed. In this case I think we should just ask the user for an alternative name. Maybe in the index.xml we could store not just 1 name but 2: originalname="app1" and name="editor". In this way one could install applications with the same jnlp name. A trickier problem is version handling. <br><br/>
The most important operation that the installer must support is updating the packages which are already installed. This operation must care for all dependant packages and should start by downloading the new jnlp file into a temp folder. Lets assume the following scenario:<br/>
The user runs in console the following command:<br/>
<br><br/>
"/&gt; installer u system"<br/>
<br><br/>
What the installer should do first is find what is associated with name system. Lets say that system is a cluster of modules than the installer should update all modules from system cluster. This means finding all the modules that belong to this cluster or sub-clusters read their updateURL entry and download the new JNLP files and execute them. In the process of installation of a new version the installer must check if the external resources of the new version have the version described in the JNLP file and if they dont than this resources must be updated as well. The update of resources must be done only if no other module uses the current version of the resource. In our example lets say that module service-manager has a new version which needs ant version 1.6 but locally we have ant 1.5 installed than ant must be updated as well if no other modules use ant 1.5. If ant 1.5 is still used than the new version of ant must be installed separately and the old version kept.</p>
</dd>
<p><br></p>
<dt><b><i>References:</b></i></dt>
<dd><a href="https://web.archive.org/web/20200119030613/http://java.sun.com/products/javawebstart/developers.html">Sun JNLP specification</a></dd>
<dd><a href="https://web.archive.org/web/20200119030613/https://www.gentoo.org/doc/en/portage-manual.xml">Portage application developed for Gentoo Linux distribution</a></dd>
</dl>
</p>
<p><b>Addendums</b></p>
<p>markhale: Details on use of JNLP files.<br><br/>
Three types of modules have been identified; applications/applets, libraries and system level plugins (includes drivers). The purpose of this note is to detail how each type of module is described by a JNLP file.
</p>
<dl>
<dt>Applications/applets</dt>
<dd>Well-known description using <i>application-desc</i> or <i>applet-desc</i>.</dd>
<dt>Libraries</dt>
<dd>Using <i>component-desc</i>.</dd>
<dt>System plugins</dt>
<dd>Propose the introduction of <i>jnode:plugin-desc</i>. To do: give a mapping of existing plugin xml to jnlp xml. import-&gt;part,export-&gt;package???</dd>
</dl>
<p>
To allow for finer-grain control of security, introduce <i>jnode:permission</i> child element of jnlp <i>security</i> element.<br/>
<i>jnode:permission</i> will have the following required attributes: <i>class</i>, <i>name</i>, <i>actions</i>.
</p>
</div>
<div id="node-276" class="section-3">
<h1 class="book-heading">JNode System-file Tree Structure</h1>
<p>It is time for us to start thinking about how JNode should run from a normal harddisk based system, how it should be installed and maintained.</p>
<p>
An essential part of this, is how and where system files should be stored, and what system files are. This page answers the question of what system files are and proposes a tree structure for system files to be stored.</p>
<p><b>What are system files</b><br><br/>
In JNode there are a few different types of system files. These are:</p>
<ol>
<li><i>Kernel image</i>, (jnodesys.gz) which contain the nano-kernel, the system plugins and the system classes.</li>
<li><i>Initial jars</i>, (e.g. default.jgz) which contain the plugins needed to start the system.</li>
<li><i>Plugins</i>, which contain services (drivers, apps, ...) and are loaded on demand.</li>
<li><i>Configuration data</i>, which contain configuration data specific to the device it is installed on.</li>
<li><i>Bootloader files</i>, (stage2, menu.lst) used by Grub to boot the system.</li>
</ol>
<p><b>Tree structure</b><br><br/>
In JNode system files should be placed in a container in a structure that is "well known".<br><br/>
A container can be a filesystem, but can also be some kind of database. See the next paragraph for a discussion on this.</p>
<p>
The proposed tree is as follows:</p>
<table>
<tr>
<td>/jnode</td>
<td>The root of the container</td>
</tr>
<tr>
<td>/jnode/system</td>
<td>Contains kernel and the initial jars</td>
</tr>
<tr>
<td>/jnode/plugins</td>
<td>Contains the plugins</td>
</tr>
<tr>
<td>/jnode/boot</td>
<td>Contains the bootloader files</td>
</tr>
<tr>
<td>/jnode/config</td>
<td>Contains the configuration data</td>
</tr>
</table>
<p><b>System file container</b><br><br/>
Traditionally the system files are stored in a directory on a "root" filesystem. This filesystem is identified by a parameter, or some flag in a partition table.<br><br/>
This method is easy, because all normal filesystem tools can be used on them, but makes it harder to protect these files against virusses, ignorent users etc. Also this method limits the system files to being harddisk based. (E.g. look at the trouble Linux had to have an NFS root filesystem).</p>
<p>
For these reasons, I propose a more generic method, that of an abstract container interface for system file access. This interface can have implementation ranging from a single file based container to a network loader. The essential part is that the actual implementation is hidden from the part of JNode that uses it (either to load files, or to install them).</p>
<p>This is all for now, please <b>comment</b> on this proposal.</p>
<p>Ewout</p>
</div>
<div id="node-348" class="section-3">
<h1 class="book-heading">Networking proposals</h1>
<p>This is a branch for the proposals of the networking subsystem</p>
<div id="node-349" class="section-4">
<h1 class="book-heading">A new networking framework</h1>
<p>Networking framework</p>
<p>The goals of this proposal:<br/>
- Flexibility, more capabilities<br/>
- Simplicity, better Object-Oriented design</p>
<p>The following are the 3 basic types of entities within this framework:<br/>
- Network devices<br/>
- Network filters<br/>
- Applications.</p>
<p>The network devices are the device drivers of the Network interfaces or virtual network drivers (like the local loopback). We assume that a device driver like that takes a packet stored in a memory buffer and write it on the media (wire, air or anything else). Also it receives a packet from the media and writes it to a memory buffer. The device drivers that do some job of the networking system, such as checksum calculation or crypto work, may be treated also as Network filters (they will be discussed later).</p>
<p>At the opposite hand are the applications. This is any software that creates packets and injects them, or receives a packet from the networking subsystem. For example: a ping command, or dns server software, and also the java SocketImpl system.</p>
<p>Both Network device drivers and applications are the endpoints of this model. From them the packets are coming in and out of the networking subsystem of the OS. Between them we have the Filters.</p>
<p>The filters take packets from any component and forward them to other components. A subcategory of them, are the protocol stacks. The filters are the components that are used to transform the packets or do other things with these packets. For example a TCP/IP stack is a filter that parses the incoming byte arrays (RawPacket from the device driver) to TCP/IP packets, or encapsulates data into TCP/IP packets to be sent later over another protocol. There is more that the TCP/IP stack will do internally, but its a matter of the TCP/IP stack implementation and not of this framework proposal.</p>
<p>These filters have one or more PacketStreams. Most components may have two packet streams. Any packet stream implements two interfaces, the PacketListener and the PacketFeeder. Any PacketListener may be registered to a feeder to receive packets from him. This way we can have Chains of packet streams, some of them may split (?)*. Also a filter may be just a PacketFeeder or PacketListener. For example a component that captures packets directly to the filesystem, a counter for some specific packets, a traffic generator, etc (but they may not be treated as endpoints).</p>
<p>For performance reasons we can use a listening under criteria system. And only when these criteria are matched the feeder will send the packet to this listener. We can have an interface ListenerCriteria with a simple listener specific method that reads some bytes or anything else from the incoming packet and return true or false. This method will be called from the packet feeder, before he sends the packet to the listener. For example an IPListenerCriteria will check the ethertype bytes if the packet feeder is EthernetLayer. Or another ListenerCriteria implementer may check the class of a packet to see if it is instance of the ICMPPacket. Listening under criteria will be a way to filter packets that will be passed from stream to stream.</p>
<p>The PacketFeeders will have a registry, where they store the currently registered listeners to them. For this registry I suggest to use a List of bindings, where every binding of this list will have as key a PacketCriteria type instance and as value a list of the PacketListeners that are listening under these criteria.</p>
<p>For performance reasons, a packet feeder may have two or more different registries of listeners, one for the high priority listeners and one for the others or one registry for the protocol to protocol submission and one for the others (and if they exist).</p>
<p>To avoid deadlocks between components and performance degradation, when a feeder passes a packet to a listener, the listener may use incoming queue and have its own thread to handle the packet. Except if the packet handling that he would do is something very quick.</p>
<p>Another issue, is how all this relations between the components will be managed. A command or a set of commands will be useful. This is a part of Ifconfig mainly.</p>
<p>The result of all these will be a web of networking components, where everyone can communicate to everyone. Think the possibilities, I have found many already.</p>
<p>This is an abstract of what I am thinking. The details is better to be discussed here.</p>
<p>Pavlos Georgiadis</p>
</div>
<div id="node-350" class="section-4">
<h1 class="book-heading">Packet representation</h1>
<p>Packet representation</p>
<p>The goal of this proposal is mainly to speed up the packet handling and to provide the developers a simpler and more Object Oriented packet representation. It aims to remove the current SocketBuffer and replace it with Packets.</p>
<p>Currently the packets are represented with the SocketBuffer class. The SocketBuffer is something like a dynamic buffer (to be more accurate it is more like a list of dynamic buffers). When a program wants to send a network packet, it creates the protocol headers, and then the headers are inserted in this buffer list with the packet payload (if there is a payload). Finally the NIC driver copies all the bytes of the packet into another fixed array to be used from the driver.<br/>
When we send a packet we move all the packet data 2 times (from the headers to the SocketBuffer and from it to the final fixed array). When we receive a packet, the SocketBuffer acts like a fixed array, which provides us with some useful methods to read data from him.</p>
<p>What I suggest is to represent the packets asPackets. All the protocol packets are the same thing. They have a header and a payload (some of them have a tail too). Every packet is able to know its size and how to handle its data (including the payload).</p>
<p>So lets say we have the interface Packet.</p>
<p>What we need from the Packet implementers:<br/>
- Set and Get methods for the data of the packets (class specific and wont be in the Packet interface)<br/>
- A way to store the data in an object and to have a method that will return the entire packet as a byte[] (when we send the packet).<br/>
- Methods that will parse a byte array to create the Packet object (when we receive a packet).</p>
<p>Any packet is represented with a class that implements the Packet interface. For example IPv4Packet, ICMPPacket, TCPPacket etc. Every component of the networking can access the data of this packet with the appropriate set and get methods (If a program uses a packet knows its specific assessors).</p>
<p>To accomplish the second and the third we need the following methods for the interface Packet:</p>
<p>public void getData(byte[] b);<br/>
public void getData(byte[] b, int offset);<br/>
public void getSize();</p>
<p>The getData(byte[] b) writes the packet in the given byte array. If the length of this array is not enough we can throw an exception. The getData(byte[] b, int offset) writes a packet to the array b, starting from the offset position. The getSize method will return the length of this packet, including the length of its payload.</p>
<p>These methods will be called mainly from the network drivers. This is the point where the packet is converted from object to a memory buffer and vice versa.</p>
<p>When the Ethernet protocol sends a packet to the driver the driver will call the getSize() of the Ethernet packet to determine how big will be the array that will store the entire packet. The Ethernet packet getSize() method will return for example 14+payload.getSize(). Remember that the payload is also a packet, lets say an IP packet that may return for example 20+payload.getSize(). As the driver has determine the length of the entire packet, it will create the memory buffer b and it will call the getData(byte[] b) to the Ethernet packet, which will write the first 14 bytes and also it will internally call payload.getData(b, 14). This way we move the data only once, from the objects to the final byte array.</p>
<p>A common class that implements the Packet interface is the RawPacket, which is a packet that maps a byte array, or a portion of this array as packet.</p>
<p>The Raw packet will be mainly used:<br/>
- To store the data payload of a packet (for example the data payload of a TCP packet)<br/>
- To map a received packet before it will be parsed from the networking components.</p>
<p>A practical example for the second:</p>
<p>When a packet is received from a NIC, the driver will create a RawPacket with the array that stores the currently received frame. Later this RawPacket will be send for example to the Ethernet protocol, which will parse the first 14 bytes to its attributes and create another (or modify the same) RawPacket that will map the same byte[] from the position 15 to the end. This RawPacket will be the payload of this Ethernet packet, that later will be send to the IPv4 stack for example and so on.</p>
<p>Pavlos Georgiadis</p>
</div>
</div>
</div>
<div id="node-43" class="section-2">
<h1 class="book-heading">FAQ</h1>
<div id="node-44" class="section-3">
<h1 class="book-heading">Are there any plans to support GNU Classpath?</h1>
<p>GNU classpath is currently used. There are however some minor differences.</p>
<p>It is intended that Classpath is used out of the box somewhere in the future. In the mean time, classpath is part of the JNode source repository and is synced on a somewhat regular based with the latest version from classpath.org.</p>
<p><b>Edited by <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/user/65">Fabien D</a> :</b><br/>
Since it is open sourced, we are moving to <a href="https://web.archive.org/web/20200119030613/https://openjdk.java.net/">openjdk</a> (instead of using GNU Classpath).</p>
</div>
<div id="node-1497" class="section-3">
<h1 class="book-heading">Are you using openjdk ?</h1>
<p>Since it is open sourced, we are moving to <a href="https://web.archive.org/web/20200119030613/https://openjdk.java.net/">openjdk</a> (instead of using GNU Classpath).</p>
<p>At the time I am writing this article, we have misc sources from both GNU Classpath, openjdk and icedtea(the parts that are not free in jdk will be replaced by free parts from GNU world)</p>
</div>
<div id="node-527" class="section-3">
<h1 class="book-heading">How do I configure the network in JNode?</h1>
<p>The network can be configured with dynamic IP address or with a fixed IP address.</p>
<p><u>Note</u> : To find the name of your network card, just type "ifconfig" and you will get a list of available devices.</p>
<p><u>Configuring the "loopback" interface</u><br/>
    You need to configure the <i>loopback</i> interface for the DNS setup performed by the <i>dhcp</i> to work.</p>
<ul>
<li>Run <i>ifconfig</i> as follows:<br/>
<i>ifconfig loopback 127.0.0.1 255.255.255.255</i></li>
</ul>
<p><u>Configuring JNode with a dynamic address</u></p>
<ul>
<li>Configure "loopback" as above.</li>
<li>Run the <i>dhcp</i> command followed by the name of the network card. For example:<br/>
<i>dhcp eth-pci(0,17,0)</i></li>
<li>If <i>dhcp</i> fails with an exception that talks about a timeout, try the command again.</li>
</ul>
<p><u>Configuring JNode with a fixed IP address</u></p>
<ul>
<li>Use the <b>ifconfig</b> command to set your desired IP address. For example:<br/>
<i>ifconfig eth-pci(0,17,0) 192.168.0.10</i></li>
<li>Now, use the <b>route</b> command. For example:<br/>
<i>route add 192.168.0.1 eth-pci(0,17,0)</i></li>
</ul>
<p>To read more about the commands and their options see <a href="https://web.archive.org/web/20200119030613/http://www.jnode.org/node/88">the user docs</a>.</p>
</div>
<div id="node-646" class="section-3">
<h1 class="book-heading">How to join the development team</h1>
<p>The answer is on <a href="/web/20200119030613/http://www.jnode.org/node/645">this</a> page.</p>
</div>
<div id="node-528" class="section-3">
<h1 class="book-heading">What is the minimal required hardware?</h1>
<p>To run JNode on and X86 PC, you must have at least the following hardware.</p>
<p>Pentium processor<br/>
256Mb RAM</p>
<p>To run it a bit more interesting, the following hardware is recommended (or better).</p>
<p>Pentium 3 processor<br/>
512Mb RAM<br/>
32-bit graphics card</p>
</div>
<div id="node-1498" class="section-3">
<h1 class="book-heading">Will XYZ run on JNode?</h1>
<p>People often want to know if their favorite Java-based application or library runs on JNode.</p>
<p>The short answer is usually: "We don't know; why don't you give it a try?".</p>
<p>The long answer is that it depends on the nature of the application.  Here are some guidelines:</p>
<ul>
<li>Non-GUI based applications that are pure Java and that use only J2SE libraries have a chance of working right now.
<li>Applications that use AWT/Swing or that stress garbage collection, multi-threading and the security model may have problems right now.  JNode's deficiencies are being addressed; please feel free to help.
<li>If the application has (or depends on) C/C++ libraries, then it will not work <i>unless</i> the libraries are recoded in Java.
<li>If the application relies on external (non Java) programs then it will not work <i>unless</li>
<p> those programs can be coded in Java and ported to JNode.
</ul>
</div>
</div>
<div id="node-681" class="section-2">
<h1 class="book-heading">Papers &amp; presentations</h1>
<p>The page contains references to papers and presentations written about JNode.<br/>
If you're paper/presentation is not yet listed here, <a href="/web/20200119030613/http://www.jnode.org/user/1/contact">contact</a> the admin.</p>
<p>Papers:</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://monochromata.de/jnodejini.html">Jini on the JNode Java OS</a> by Sebastian Lohmeier</li>
</ul>
<p>Presentations:</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://jnode.svn.sourceforge.net/viewvc/*checkout*/jnode/trunk/docs/presentations/lsm-jul-2005.pdf">"Why Java is practical for modern operating systems"</a>, by Ewout Prangsma at Libre Software meeting 2005.
</ul>
</div>
<div id="node-92" class="section-2">
<h1 class="book-heading">References</h1>
<p><a name="refs"></a>References</p>
<ul>
<li>
<a href="https://web.archive.org/web/20200119030613/http://joeq.sf.net/">JOEQ another Java VM</a>
</li>
<li>
<a href="https://web.archive.org/web/20200119030613/http://www.classpath.org/">Classpath, an open source Java library implementation</a>
</li>
<li>
<a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/classpath/docs/vmintegration.html">Classpath vm integration guide</a>
</li>
<li>
<a href="https://web.archive.org/web/20200119030613/http://www.zaval.org/products/lwvcl/">Zaval LwVCL graphics component library</a>
</li>
<li>
<a href="https://web.archive.org/web/20200119030613/http://jikesrvm.org/">Jikes Research VM by IBM (Jikes RVM)</a>
</li>
<li>
<a href="https://web.archive.org/web/20200119030613/http://jikesrvm.org/MMTk">Memory Manager Toolkit (MMTk, part of Jikes RVM)</a>
</li>
<li>
<a href="https://web.archive.org/web/20200119030613/http://www4.informatik.uni-erlangen.de/Projects/JX/">JX Operating System</a>
</li>
<li>
<a href="https://web.archive.org/web/20200119030613/http://www.cs.utah.edu/flux/janos/">JanosVM</a>
</li>
</ul>
<p>Grub boot loader</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.gnu.org/software/grub/manual/multiboot/html_node/Boot-information-format.html#Boot-information-format">Multiboot header specifications</a></li>
</ul>
<div id="node-2775" class="section-3">
<h1 class="book-heading">File systems</h1>
<p><b><u>Ext2</u></b></p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.linuxgazette.com/issue21/ext2.html">A Non-Technical Look Inside the EXT2 File System</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.virtualblueness.net/Ext2fs-overview/Ext2fs-overview-0.1-12.html">The superblock</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://www.nongnu.org/ext2-doc/ext2.html">Internal Layout</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://uranus.it.swin.edu.au/~jn/explore2fs/es2fs.htm">John's ext2 spec</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.charmed.com/txt/ext2.txt">The Second Extended Filesystem</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.science.unitn.it/~fiorella/guidelinux/tlk/node95.html">ext2 spec</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://www.oreilly.com/catalog/linuxkernel2/chapter/ch17.pdf">Understanding the Linux kernel - chapter 17</a></li>
</ul>
<p><b><u>BeFS</u></b></p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.nobius.org/~dbg/practical-file-system-design.pdf">Practical File System Design</a></li>
</ul>
<p><b><u>HFS/HFS+/HFSX</u></b></p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://developer.apple.com/technotes/tn/tn1150.html">Apple technical note</a></li>
</ul>
</div>
<div id="node-2778" class="section-3">
<h1 class="book-heading">Graphic specifications</h1>
<p><b><u>General Graphics standards</u></b></p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.vesa.org/public/VBE/vbe3.pdf">VESA Bios Extension (VBE) 3 specifications</a> (broken link : the file is now attached)</li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.vesa.org/Public/GTF/GTF_V1R1.xls">Vesa Generalized Timing Formula (VESA-1999-9) implemented in a spread sheet</a></li>
</ul>
<p><b><u>Graphics Card Specifications</u></b></p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.tjd.phlegethon.org/gd5446trm.pdf.gz">Cirrus GD5446 graphics card found in the kvm/bochs "PCs"</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://wiki.opengraphics.org/">The Open Graphics Project</a>
</ul>
</div>
<div id="node-2773" class="section-3">
<h1 class="book-heading">Relevant JSRs</h1>
<ul>
<li>
<a href="https://web.archive.org/web/20200119030613/https://jcp.org/en/jsr/detail?id=121">121 Application Isolation API Specification</a> <a href="https://web.archive.org/web/20200119030613/http://java.sun.com/j2se/jcp/AppIsolationAPI/javadoc/overview-tree.html">(api)</a></p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://bitser.net/isolate-interest/">Isolate interest</a></li>
</ul>
</li>
<li><a href="https://web.archive.org/web/20200119030613/https://jcp.org/en/jsr/detail?id=107">107 JCACHE - Java Temporary Caching API</a> <a href="https://web.archive.org/web/20200119030613/https://jsr-107-interest.dev.java.net/javadoc/javax/cache/package-summary.html">(draft api)</a>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://jsr-107-interest.dev.java.net/">JSR 107 interest</a></li>
</ul>
</li>
</ul>
</div>
<div id="node-2774" class="section-3">
<h1 class="book-heading">Specification sites</h1>
<ul>
<li>Operating systems</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://www.osdev.org/wiki/Main_Page">OS Development</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.mjmwired.net/kernel/Documentation/">Linux kernel documentation (drivers, irq, ...)</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://pdos.csail.mit.edu/6.828/2009/index.html">Operating System Engineering</a></li>
</ul>
<li>Hardware</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/http://suif.stanford.edu/~csapuntz/ide.html">Guide to ATA/ATAPI documentation</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://www.microsoft.com/whdc/resources/respec/specs/default.mspx">Microsoft WDEV</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://www.microsoft.com/whdc/system/pnppwr/powermgmt/default.mspx">Microsoft ACPI/Power management (hot plug&amp;play, ...)</a></li>
<li><a href="https://web.archive.org/web/20200119030613/https://www.phoenix.com/NR/rdonlyres/98D3219C-9CC9-4DF5-B496-A286D893E36A/0/specscdrom.pdf">El Torito Bootable CD-ROM Format Specification Version 1.0 (January 25, 1995)</a>
  </ul>
<li>Fonts</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://developer.apple.com/fonts/TTRefMan">TrueType Reference Manual (TTF)</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://www.truetype-typography.com/">TrueType typography (TTF)</a></li>
<li><a href="https://web.archive.org/web/20200119030613/http://freetype.sourceforge.net/freetype2/docs/glyphs/glyphs-3.html">Font metrics and glyph (explanation of terms)</a></li>
</ul>
<li>Compiler</li>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.research.ibm.com/journal/rd/485/suganuma.pdf">Evolution of a Java Just-in-Time Compiler for IA-32 Platforms</a> describing the idea behind JNode's l1a compiler.
  </ul>
</ul>
</div>
</div>
<div id="node-682" class="section-2">
<h1 class="book-heading">Research</h1>
<p>The page contains references to research done with and around JNode.<br/>
If you're research topic is not yet listed here, <a href="/web/20200119030613/http://www.jnode.org/user/1/contact">contact</a> the admin.</p>
<ul>
<li><a href="https://web.archive.org/web/20200119030613/https://www.cs.manchester.ac.uk/apt/projects/jamaica/">Jamaica project</a> at the University of Manchester</li>
</ul>
</div>
</div>

<script data-cfasync="false" src="/web/20200119030613js_/http://www.jnode.org/cdn-cgi/scripts/5c5dd728/cloudflare-static/email-decode.min.js"></script></body>
</html>
<!--
     FILE ARCHIVED ON 03:06:13 Jan 19, 2020 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 15:17:09 Feb 18, 2023.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  captures_list: 74.535
  exclusion.robots: 0.084
  exclusion.robots.policy: 0.075
  cdx.remote: 0.064
  esindex: 0.007
  LoadShardBlock: 47.967 (3)
  PetaboxLoader3.datanode: 61.61 (4)
  load_resource: 741.977
  PetaboxLoader3.resolve: 686.168
-->